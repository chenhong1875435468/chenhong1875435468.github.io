<!DOCTYPE html><html lang="zn-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>电脑商城项目教程 | Clarence</title><meta name="author" content="Clarence"><meta name="copyright" content="Clarence"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="静态资源及sql文件分享 链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1X-yjmQcPD3PqS21x0HplNA?pwd&#x3D;23gr 提取码：23gr   项目完整代码分享 链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1qcJdPeXas7HPXgMhlXO7Aw?pwd&#x3D;uzic 提取码：uzic   文章目录    项目环境搭建   1.项目分析 2.项目基本环境 3.">
<meta property="og:type" content="article">
<meta property="og:title" content="电脑商城项目教程">
<meta property="og:url" content="https://www.orangecatdpman.cn/2022/10/15/%E7%94%B5%E8%84%91%E5%95%86%E5%9F%8E/index.html">
<meta property="og:site_name" content="Clarence">
<meta property="og:description" content="静态资源及sql文件分享 链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1X-yjmQcPD3PqS21x0HplNA?pwd&#x3D;23gr 提取码：23gr   项目完整代码分享 链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1qcJdPeXas7HPXgMhlXO7Aw?pwd&#x3D;uzic 提取码：uzic   文章目录    项目环境搭建   1.项目分析 2.项目基本环境 3.">
<meta property="og:locale" content="zn_CN">
<meta property="og:image" content="https://www.orangecatdpman.cn/img/Bg4.png">
<meta property="article:published_time" content="2022-10-15T12:28:36.431Z">
<meta property="article:modified_time" content="2022-10-15T12:38:24.339Z">
<meta property="article:author" content="Clarence">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.orangecatdpman.cn/img/Bg4.png"><link rel="shortcut icon" href="/img/head.png"><link rel="canonical" href="https://www.orangecatdpman.cn/2022/10/15/%E7%94%B5%E8%84%91%E5%95%86%E5%9F%8E/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '电脑商城项目教程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-15 20:38:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macblack.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/pictures/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/Bg4.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Clarence</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/pictures/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">电脑商城项目教程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-10-15T12:28:36.431Z" title="Created 2022-10-15 20:28:36">2022-10-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-10-15T12:38:24.339Z" title="Updated 2022-10-15 20:38:24">2022-10-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">44.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>174min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="电脑商城项目教程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>静态资源及sql文件分享<br />
链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1X-yjmQcPD3PqS21x0HplNA?pwd=23gr">https://pan.baidu.com/s/1X-yjmQcPD3PqS21x0HplNA?pwd=23gr</a><br />
提取码：23gr</p>
</blockquote>
<blockquote>
<p>项目完整代码分享<br />
链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1qcJdPeXas7HPXgMhlXO7Aw?pwd=uzic">https://pan.baidu.com/s/1qcJdPeXas7HPXgMhlXO7Aw?pwd=uzic</a><br />
提取码：uzic</p>
</blockquote>
<h3 id="文章目录"><a class="markdownIt-Anchor" href="#文章目录"></a> 文章目录</h3>
<ul>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_9">项目环境搭建</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_11">1.项目分析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_29">2.项目基本环境</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_43">3.项目创建</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_71">4.项目测试</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#41_73">4.1测试能否成功连接数据库</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#42_99">4.2测试静态资源能否正常加载</a></li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_111">用户注册功能</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_113">1.创建数据表</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_168">2.创建用户的实体类</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_220">3.注册-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31SQL_224">3.1规划需要执行的SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32_240">3.2设计接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_271">3.3编写映射</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#34_357">3.4单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_401">4.注册-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#41_416">4.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#42_483">4.2设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#43_571">4.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#5_613">5.注册-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#51_615">5.1创建响应</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#52_655">5.2设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#53_666">5.3处理请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#54_701">5.4控制层优化设计</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#6_746">6.注册-前端页面</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#61ajax_748">6.1熟悉ajax</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#62js_790">6.2前端js编写</a></li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_841">用户登录功能</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_845">1.登录-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#SQL_847">规划需要执行的SQL语句</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_861">2.登录-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#21_863">2.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#22_885">2.2设计接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#23_946">2.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_961">3.登录-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31_963">3.1处理异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32_979">3.2设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_986">3.3处理请求</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_1010">4.登录-前端页面</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#5session_1044">5.用session存储和获取用户数据</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#6_1096">6.拦截器</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_1184">修改密码</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_1188">1.修改密码-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#11SQL_1190">1.1规划需要执行的SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#12_1206">1.2设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#13_1232">1.3编写映射</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#14_1250">1.4单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_1268">2.修改密码-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#21_1270">2.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#22_1283">2.2设计接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#23_1336">2.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_1345">3.修改密码-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31_1347">3.1处理异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32_1360">3.2设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_1367">3.3处理请求</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_1383">4.修改密码-前端页面</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_1411">个人资料</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_1415">1.个人资料-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#11SQL_1417">1.1规划SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#12_1433">1.2设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#13_1446">1.3编写映射</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#14_1465">1.4单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_1479">2.个人资料-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#21_1487">2.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#22_1492">2.2设计接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#23_1552">2.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_1574">3.个人资料-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31_1576">3.1处理异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32_1580">3.2设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_1596">3.3处理请求</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_1625">4.个人资料-前端页面</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_1696">上传头像</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_1704">1.上传头像-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#11SQL_1706">1.1SQL语句的规划</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#12_1714">1.2设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#13_1739">1.3编写映射</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#14_1755">1.4单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_1768">2.上传头像-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#21_1770">2.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#22_1777">2.2设计接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#23_1813">2.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_1822">3.上传头像-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31_1828">3.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32_1846">3.2处理异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_1868">3.3设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#34_1875">3.4处理请求</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_1962">4.上传头像-前端页面</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#5bug_1972">5.前端页面优化——修复bug</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#51_1974">5.1更改默认的大小限制</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#52_2008">5.2上传后显示头像</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#53_2061">5.3登录后显示头像</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#54_2108">5.4显示最新头像</a></li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_2120">新增收货地址</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_2122">1.创建数据表</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_2159">2.创建收货地址的实体类</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_2189">3.新增收货地址-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31_2191">3.1各功能的开发顺序</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32SQL_2200">3.2规划需要执行的SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_2214">3.3设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#34_2237">3.4编写映射</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#35_2296">3.5单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_2325">4.新增收货地址-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#41_2327">4.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#42_2346">4.2设计接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#43_2440">4.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#5_2461">5.新增收货地址-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#51_2463">5.1处理异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#52_2474">5.2设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#53_2481">5.3处理请求</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#6_2504">6.新增收货地址-前端页面</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_2529">获取省市区列表</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_2535">1.创建数据表</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_2564">2.创建省市区的实体类</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_2583">3.获取省市区列表-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31SQL_2585">3.1规划需执行的SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32_2591">3.2设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_2609">3.3编写映射</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#34_2626">3.4单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_2649">4.获取省市区列表-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#41_2651">4.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#42_2655">4.2设计接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#43_2696">4.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#5_2718">5.获取省市区列表-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#51_2720">5.1设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#52_2727">5.2处理请求</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#6_2758">6.获取省市区列表-前端页面</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_2773">获取省市区名称</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_2777">1.获取省市区名称-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31SQL_2779">3.1规划需要执行的SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32_2787">3.2设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_2795">3.3编写映射</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#34_2805">3.4单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_2817">2.获取省市区名称-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#21_2819">2.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#22_2823">2.2设计接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#23_2840">2.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_2844">3.获取省市区名称-控制层</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_2848">4.获取省市区名称-业务层优化</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#5_2874">5.获取省市区名称-前端页面</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_3007">收货地址列表展示</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_3009">1.收货地址列表展示-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#11SQL_3011">1.1规划需要执行的SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#12_3021">1.2设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#13_3034">1.3编写映射</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#14_3045">1.4单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_3055">2.收货地址列表展示-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#21_3057">2.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#22_3061">2.2设计接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#23_3101">2.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_3105">3.收货地址列表展示-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31_3107">3.1处理异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32_3111">3.2设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_3118">3.3处理请求</a></li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_3191">设置默认收货地址</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_3193">1.设置默认收货地址-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#11SQL_3195">1.1规划需要执行的SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#12_3219">1.2设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#13_3245">1.3编写映射</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#14_3269">1.4单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_3288">2.设置默认收货地址-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#21_3290">2.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#22_3312">2.2设计接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#23_3367">2.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_3378">3.设置默认收货地址-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31_3380">3.1处理异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32_3394">3.2设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_3401">3.3处理请求</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_3422">4.设置默认收货地址-前端页面</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_3468">删除收货地址</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_3470">1.删除收货地址-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#11SQL_3472">1.1规划需要执行的SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#12_3494">1.2设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#13_3514">1.3编写映射</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#14_3530">1.4单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_3545">2.删除收货地址-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#21_3547">2.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#22_3561">2.2设计接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#23_3631">2.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_3640">3.删除收货地址-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31_3642">3.1处理异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32_3653">3.2设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_3660">3.3处理请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#34_3673">3.4单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_3679">4.删除收货地址-前端页面</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_3717">商品热销排行</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_3719">1.创建数据表</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_3751">2.创建商品的实体类</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_3776">3.商品热销排行-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31_SQL_3778">3.1 规划需要执行的SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32__3786">3.2 设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33__3800">3.3 编写映射</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_3827">4.商品热销排行-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#41__3829">4.1 规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#42__3833">4.2 设计接口和抽象方法及实现</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#5_3879">5.商品热销排行-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#51__3881">5.1 处理异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#52__3885">5.2 设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#53__3892">5.3 处理请求</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#6_3920">6.商品-热销排行-前端页面</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_3976">显示商品详情</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_3978">1.显示商品详情-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#11SQL_3980">1.1规划需要执行的SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#12_3988">1.2设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#13_4001">1.3编写映射</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_4011">2.显示商品详情-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#21_4013">2.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#22_4024">2.2设计接口和抽象方法及实现</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_4058">3.显示商品详情-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31_4060">3.1处理异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32__4071">3.2 设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_4080">3.3处理请求</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_4092">4.显示商品详情-前端页面</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_4138">加入购物车</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_4140">1.创建数据表</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_4165">2.创建购物车的实体类</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_4185">3.加入购物车-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31SQL_4187">3.1规划需要执行的SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32_4207">3.2设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_4247">3.3编写映射</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#34_4287">3.4单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_4321">4.加入购物车-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#41_4323">4.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#42_4327">4.2设计接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#43_4414">4.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#5_4432">5.加入购物车-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#51_4434">5.1处理异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#52_4438">5.2设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#53_4445">5.3处理请求</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#6_4470">6.加入购物车-前端页面</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_4527">显示购物车列表</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_4529">1.显示购物车列表-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#11SQL_4531">1.1规划需要执行的SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#12_4565">1.2设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#13_4603">1.3编写映射</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#14_4628">1.4单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_4640">2.显示购物车列表-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#21__4642">2.1 规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#22_4646">2.2设计接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#23_4668">2.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_4672">3.显示购物车列表-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31__4674">3.1 处理异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32__4678">3.2 设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33__4685">3.3 处理请求</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_4699">4.显示购物车列表-前端页面</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_4786">增加商品数量</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_4792">1.增加购物车商品数量-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#11SQL_4794">1.1规划需要执行的SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#12_4804">1.2设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#13_4812">1.3编写映射</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#14_4822">1.4单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_4835">2.增加购物车商品数量-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#21_4837">2.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#22_4850">2.2设计接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#23_4901">2.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_4905">3.增加购物车商品数量-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31_4907">3.1处理异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32_4918">3.2设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_4925">3.3处理请求</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_4942">4.增加购物车商品数量-前端页面</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_4984">确认订单</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_4986">1.确认订单-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#11SQL_4988">1.1规划需要执行的SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#12_5014">1.2设计接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#13_5022">1.3配置映射</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#14_5056">1.4单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_5071">2.确认订单-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#21_5073">2.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#22_5077">2.2设计接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#23_5112">2.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_5116">3.确认订单-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31_5118">3.1处理异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32_5122">3.2设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_5129">3.3处理请求</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_5143">4.确认订单-前端页面</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#41_5145">4.1显示勾选的购物车数据</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#42_5224">4.2显示选择收货地址</a></li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#_5277">创建订单</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1_5279">1.创建数据表</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_5328">2.创建用户的实体类</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3_5375">3.创建订单-持久层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#31SQL_5377">3.1规划需要执行的SQL语句</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#32_5393">3.2实现接口和抽象方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#33_5415">3.3编写映射</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#34_5452">3.4单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#4_5483">4.创建订单-业务层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#41_5485">4.1规划异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#42_5489">4.2实现接口和抽象方法及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#43_5643">4.3单元测试</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#5_5666">5.创建订单-控制层</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#51_5668">5.1处理异常</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#52_5672">5.2设计请求</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#53_5679">5.3处理请求</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#6_5702">6.创建订单-前端页面</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#AOP_5731">AOP</a></li>
<li>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#1Spring_AOP_5737">1.Spring AOP</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#2_5748">2.切面方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiangyu_/article/details/124720912#3__5758">3 统计业务方法执行时长</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="项目环境搭建"><a class="markdownIt-Anchor" href="#项目环境搭建"></a> 项目环境搭建</h2>
<h3 id="1项目分析"><a class="markdownIt-Anchor" href="#1项目分析"></a> 1.项目分析</h3>
<ol>
<li>
<p>项目功能:登录,注册,热销商品,用户管理(密码,个人信息,头像,收货地址),购物车(展示,增加,删除),订单模块</p>
</li>
<li>
<p>开发顺序:注册,登录,用户管理,购物车,商品,订单模块</p>
</li>
<li>
<p>某一个模块的开发顺序:</p>
<ul>
<li>
<p>持久层开发:依据前端页面的设置规划相关的SQL语句,以及进行配置</p>
</li>
<li>
<p>业务层开发:核心功能控制,业务操作以及异常的处理</p>
</li>
<li>
<p>控制层开发:接收请求,处理响应</p>
</li>
<li>
<p>前端开发:JS,Query,AJAX这些技术来连接后台</p>
</li>
</ul>
</li>
</ol>
<h3 id="2项目基本环境"><a class="markdownIt-Anchor" href="#2项目基本环境"></a> 2.项目基本环境</h3>
<ol>
<li>JDK:1.8版本及以上</li>
<li>maven:需要配置到idea,3.6.1版本及以上</li>
<li>数据库:MariaDB,MySQL,要求是5.1版本及以上</li>
<li>开发的平台:idea开发</li>
</ol>
<hr />
<ol>
<li>项目名称:store,表示商城</li>
<li>结构:com.cy.store</li>
</ol>
<pre class="highlight"><code class="java"><span class="hljs-comment">//三个基础jar包</span>
java web
mybatis
mysql driver
</code></pre>
<p><img src="https://s2.loli.net/2022/08/05/QVpPT57IurtnAJh.png" alt="" /><br />
勾选上述</p>
<ol start="3">
<li>资源文件:resources文件夹下(static,templates)</li>
<li>单元测试:test.com.cy.store</li>
</ol>
<h3 id="3项目创建"><a class="markdownIt-Anchor" href="#3项目创建"></a> 3.项目创建</h3>
<ol>
<li>
<p>Create New Project-&gt;</p>
</li>
<li>
<p>选择Spring Initializr,点击next</p>
</li>
<li>
<p>跳转到Project Metadata页面,该页面的Group填写域com和自己起的域名cy(<a target="_blank" rel="noopener" href="http://xn--com-4l3e.cy">即com.cy</a>)==;Artifact填写项目名store;==Java Version版本选择自己安装的版本,点击next</p>
</li>
<li>
<p>选择需要导入的jar包:</p>
<ul>
<li>前后端的连接jar包:Web目录下的Spring web</li>
<li>mybatis的jar包:SQL目录下的Mybatis Framework</li>
<li>mysql数据库的驱动:SQL目录下的MySQL Driver</li>
</ul>
</li>
<li>
<p>创建一个数据库</p>
<pre class="highlight"><code class="sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">store</span> <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8;
</code></pre>
</li>
<li>
<p>在application.properties文件中配置数据库的连接源信息</p>
</li>
</ol>
<pre class="highlight"><code class="properties">    <span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/store?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/shanghai</span>
    <span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span>
    <span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span>
</code></pre>
<h3 id="4项目测试"><a class="markdownIt-Anchor" href="#4项目测试"></a> 4.项目测试</h3>
<h4 id="41测试能否成功连接数据库"><a class="markdownIt-Anchor" href="#41测试能否成功连接数据库"></a> 4.1测试能否成功连接数据库</h4>
<ul>
<li>
<p>启动Springboot主类,看idea中是否有对应的spring图形输出</p>
</li>
<li>
<p>若idea有对应的spring图形输出开始第二步测试:<br />
在单元测试中测试数据库的连接是否可以加载:</p>
<pre class="highlight"><code class="java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoreApplicationTests</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">//自动装配</span>
    <span class="hljs-keyword">private</span> DataSource dataSource;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;
    &#125;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;
        System.out.println(dataSource.getConnection());
    &#125;
&#125;
</code></pre>
<p>运行getConnection方法,若成功返回HikariProxyConnection@189194499 wrapping com.mysql.cj.jdbc.ConnectionImpl@2b0e9f30则说明成功连接数据库,其中Hikari是一个连接池,用来管理数据库的连接对象,是springboot默认内部整合的连接池,该连接池号称世界上最快的连接池,底层仍然采用c3p0来管理数据库的连接对象</p>
</li>
</ul>
<h4 id="42测试静态资源能否正常加载"><a class="markdownIt-Anchor" href="#42测试静态资源能否正常加载"></a> 4.2测试静态资源能否正常加载</h4>
<p>将静态资源(SpringBoot电脑商城项目-V1.0\tools\pages_src\pages*)<br />
复制到static目录下重启项目<br />
并尝试访问<mark>localhost:8080/web/login.html</mark><br />
<mark>(因为static是默认根目录,所以不是localhost:8080/static/web/login.html)</mark></p>
<p>如果这个过程访问失败,原因是idea对于JS代码的兼容性较差,编写了js代码但是有的时候不能正常去加载,解决办法有以下四种</p>
<ul>
<li>
<p>clear-install:依次点击MavenProject-&gt;store-&gt;Lifecycle-&gt;clean,等待清哩项目完毕后点击同目录下的install重新部署</p>
</li>
<li>
<p>idea缓存清理:点击File下的Invalidate Caches/Restart…然后在弹出的窗口中选择Invalidate and Restart,此时就会自动清除缓存并重新启动idea</p>
</li>
<li>
<p>rebuild重新构建:点击工具栏的Build下的Rebuild Project</p>
</li>
<li>
<p>重启电脑</p>
</li>
</ul>
<h2 id="用户注册功能"><a class="markdownIt-Anchor" href="#用户注册功能"></a> 用户注册功能</h2>
<h3 id="1创建数据表"><a class="markdownIt-Anchor" href="#1创建数据表"></a> 1.创建数据表</h3>
<p>1.选中数据表:</p>
<pre class="highlight"><code class="sql"><span class="hljs-keyword">use</span> <span class="hljs-keyword">store</span>
</code></pre>
<p>2.创建t_user表</p>
<pre class="highlight"><code class="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_user (
uid <span class="hljs-built_in">INT</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'用户id'</span>,
username <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'用户名'</span>,
<span class="hljs-string">`password`</span> <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'密码'</span>,
<span class="hljs-keyword">salt</span> <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">36</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'盐值'</span>,
phone <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'电话号码'</span>,
email <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'电子邮箱'</span>,
gender <span class="hljs-built_in">INT</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'性别:0-女，1-男'</span>,
avatar <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'头像'</span>,
is_delete <span class="hljs-built_in">INT</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'是否删除：0-未删除，1-已删除'</span>,
created_user <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'日志-创建人'</span>,
created_time DATETIME <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'日志-创建时间'</span>,
modified_user <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'日志-最后修改执行人'</span>,
modified_time DATETIME <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'日志-最后修改时间'</span>,
PRIMARY <span class="hljs-keyword">KEY</span> (uid)
) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;
</code></pre>
<p><strong>tips:</strong></p>
<ul>
<li>
<p>注册页面的确认密码功能多数开发中交给前端做,如果两次密码输入不同就不能将数据传给后台</p>
</li>
<li>
<p>创建t-user表时`password` CHAR(32) NOT NULL COMMENT ‘密码’,因为password是关键字,所以需要用``号(不是单引号,是esc下面的那个键)并且后面用到该字段时(比如往表中插入数据)也需要用``</p>
</li>
<li>
<p>创建t_user表时salt CHAR(36) COMMENT ‘盐值’,是为了在用户注册时对用户的密码进行加密操作(后续再讲)</p>
</li>
<li>
<p>数据库中的性别0代表女,1代表男,数据库中用数字而不是文字是因为前端的性别选项是单选框,提交给后台的是数字</p>
</li>
<li>
<p>创建t_user表时is_delete INT COMMENT ‘是否删除：0-未删除，1-已删除’,的作用:网站中都有注销账号的功能,大部分的网站并不是真的将用户注销了,而是在下次用户登录时进行验证,如果是0就放行,如果是1就禁止登录</p>
</li>
<li>
<p>创建t-user表时username VARCHAR(20) NOT NULL UNIQUE COMMENT ‘用户名’,的UNIQUE 作为约束条件使用户名唯一</p>
</li>
<li>
<p>将来任何一张表都有以下四个字段:</p>
<p>created_user VARCHAR(20) COMMENT ‘创建人’,</p>
<p>created_time DATETIME COMMENT ‘创建时间’,</p>
<p>modified_user VARCHAR(20) COMMENT ‘修改人’,</p>
<p>modified_time DATETIME COMMENT ‘修改时间’,</p>
<p>所以为了开发方便可以把这四个字段作为整个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AE%9E%E4%BD%93%E7%B1%BB&amp;spm=1001.2101.3001.7020">实体类</a></p>
</li>
</ul>
<h3 id="2创建用户的实体类"><a class="markdownIt-Anchor" href="#2创建用户的实体类"></a> 2.创建用户的实体类</h3>
<p>1.通过表的结构提取出表的公共字段,放在一个实体类的基类中,起名BaseEntity基类中</p>
<pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEntity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;
    <span class="hljs-keyword">private</span> String createdUser;
    <span class="hljs-keyword">private</span> Date createdTime;
    <span class="hljs-keyword">private</span> String modifiedUser;
    <span class="hljs-keyword">private</span> Date emodifiedTime;
<span class="hljs-comment">/**
 * get,set
 * equals和hashCode
 * toString
 */</span>
&#125;
</code></pre>
<p>2.创建用户的实体类,并使其继承BaseEntity基类</p>
<pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseEntity</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer uid;
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-keyword">private</span> String PASSWORD;
    <span class="hljs-keyword">private</span> String salt;
    <span class="hljs-keyword">private</span> String phone;
    <span class="hljs-keyword">private</span> String email;
    <span class="hljs-keyword">private</span> Integer gender;
    <span class="hljs-keyword">private</span> String avatar;
    <span class="hljs-keyword">private</span> Integer isDelete;
<span class="hljs-comment">/**
 * get,set
 * equals和hashCode
 * toString
 */</span>
&#125;
</code></pre>
<p><strong>tips:</strong></p>
<ul>
<li>
<p>实体类User因为要在网络中以流的形式传输,所以需要serialize序列化<br />
(但因为其继承的父类BaseEntity已经实现序列化,所以就不需要再写implements Serializable)</p>
</li>
<li>
<p>实体类BaseEntity中自动导入Getter and Setter方法,euqals()方法,hashCode()方法,toString方法,其中euqals()方法,hashCode()方法自动导入步骤:</p>
<ol>
<li>enter+insert</li>
<li>点击euqals() and hashCode()</li>
<li>勾选Accept…和Use这两段话,并且选择Template为IntelliJ Default</li>
<li>一路next到底</li>
</ol>
</li>
<li>
<p>ssm框架开发项目的时候<br />
需要在实体类上面加@Component然后spring才能自动进行对象的创建维护,而springboot不再需要,因为springboot遵循的原则是约定大于配置,如果字段名称相同那就可以自动完成字段的初始化</p>
</li>
</ul>
<h3 id="3注册-持久层"><a class="markdownIt-Anchor" href="#3注册-持久层"></a> 3.注册-持久层</h3>
<p><em>通过Mybatis来操作数据库,也就是在做mybatis开发的流程</em></p>
<h4 id="31规划需要执行的sql语句"><a class="markdownIt-Anchor" href="#31规划需要执行的sql语句"></a> 3.1规划需要执行的SQL语句</h4>
<p>`1.用户的注册功能,从后端持久层来看相当于在做数据的插入操作</p>
<pre class="highlight"><code class="sql">inser into t_user (username, password) <span class="hljs-keyword">values</span>(值列表)
</code></pre>
<p>`2.在用户的注册时首先要去查询当前的用户名是否存在,如果存在则不能进行注册,相当于是一条查询语句</p>
<pre class="highlight"><code class="sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> username=?
</code></pre>
<h4 id="32设计接口和抽象方法及实现"><a class="markdownIt-Anchor" href="#32设计接口和抽象方法及实现"></a> 3.2设计接口和抽象方法及实现</h4>
<ol>
<li>定义Mapper接口.在项目的目录结构下首先创建一个mapper包,在这个包下再根据不同的功能模块来创建mapper接口.注册功能需要在mapper包下创建UserMapper接口然后定义上述两个SQL语句的抽象方法</li>
</ol>
<pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;

    <span class="hljs-comment">/**
     * 插入用户的数据
     * <span class="hljs-doctag">@param</span> user 用户的数据
     * <span class="hljs-doctag">@return</span> 受影响的行数(增删改都将受影响的行数作为返回值,可以根据返回值来判断是否执行成功)
     */</span>
    <span class="hljs-function">Integer <span class="hljs-title">insert</span><span class="hljs-params">(User user)</span></span>;

    <span class="hljs-comment">/**
     * 根据用户名来查询用户的数据
     * <span class="hljs-doctag">@param</span> username 用户名
     * <span class="hljs-doctag">@return</span> 如果找到对应的用户则返回这个用户的数据,如果没有找到则返回null
     */</span>
    <span class="hljs-function">User <span class="hljs-title">findByUsername</span><span class="hljs-params">(String username)</span></span>;
&#125;
</code></pre>
<ol start="2">
<li>ssm框架开发项目的时候需要在mapper接口上加@Mapper用于自动生成相应的接口实现类,在springboot也可以这样,但是后续会有很多mapper接口,每个接口分别加@Mapper太麻烦了,所以在启动类类里面指定当前项目的mapper接口在哪,然后项目启动的时候会自动加载所有的接口</li>
</ol>
<pre class="highlight"><code class="java"><span class="hljs-meta">@MapperScan</span>(<span class="hljs-string">"com.cy.mapper"</span>)
</code></pre>
<h4 id="33编写映射"><a class="markdownIt-Anchor" href="#33编写映射"></a> 3.3编写映射</h4>
<ol>
<li>
<p>定义xml映射文件,与对应的接口进行关联.所有的映射文件都属于资源文件,需要放在resources目录下,为了管理方便我们在resources目录下创建一个mapper文件夹,然后在这个文件夹里存放mapper的映射文件</p>
</li>
<li>
<p>创建接口的映射文件,需要和接口的名称保持一致.如UserMapper.xml</p>
</li>
</ol>
<p>UserMapper.xml的配置在Mybatis官网</p>
<pre class="highlight"><code class="xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span>
        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>
        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span>
<span class="hljs-comment">&lt;!--namespace用于指定当前的映射文件和哪个接口进行映射,需要指定接口的文件路径,路径需要是包的完整路径结构--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.cy.store.mapper.UserMapper"</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span>
</code></pre>
<ol start="3">
<li>将配置接口的方法对应到SQL语句上</li>
</ol>
<ul>
<li>insert into () values (),因为values后面插入的值是动态值,mybatis规定需要用占位符来占位,并给占位符起一个变量的名字,且变量的名字需要在占位符#{}内部</li>
<li>创建t_user表时uid INT AUTO_INCREMENT COMMENT ‘用户id’,中的AUTO_INCREMENT表示主键uid自增,所以需要useGeneratedKeys和keyProperty</li>
</ul>
<pre class="highlight"><code class="xml"><span class="hljs-comment">&lt;!--在sql语句的最上面借助ResultMap标签来自定义映射规则
    id属性:表示给这个映射规则分配一个唯一的id值,对应的就是resultMap="id属性值"
    type属性:取值是一个类,表示数据库中的查询结果与java中哪个实体类进行结果集的映射
 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"UserEntityMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.cy.store.entity.User"</span>&gt;</span>
    <span class="hljs-comment">&lt;!--将表的字段和类的属性名不一致的进行匹配指定,名称一致的也可以指定,但没必要
        但是,在定义映射规则时无论主键名称是否一致都不能省
        column属性:表示表中的字段名称
        property属性:表示类中的属性名称
        --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"uid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"uid"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"is_delete"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"isDelete"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"created_user"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"createdUser"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"created_time"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"createdTime"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"modified_user"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"modifiedUser"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"modified_time"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"modifiedTime"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>

<span class="hljs-comment">&lt;!--id属性:表示映射的接口中方法的名称,直接标签的内容部来编写SQL语句--&gt;</span>
<span class="hljs-comment">&lt;!--useGeneratedKeys="true"表示开启某个字段的值递增(大部分都是主键递增)
    keyProperty="uid"表示将表中哪个字段进行递增
    --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insert"</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">"uid"</span>&gt;</span>
    insert into t_user(
        username,`password`,salt,phone,email,gender,avatar,is_delete,
        created_user,created_time,modified_user,modified_time
    ) values (
    #&#123;username&#125;,#&#123;password&#125;,#&#123;salt&#125;,#&#123;phone&#125;,#&#123;email&#125;,#&#123;gender&#125;,#&#123;avatar&#125;,#&#123;isDelete&#125;,#&#123;createdUser&#125;,#&#123;createdTime&#125;,#&#123;modifiedUser&#125;,#&#123;modifiedTime&#125;
    )
<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>


<span class="hljs-comment">&lt;!--select语句在执行的时候查询的结果无非两种:一个对象或多个对象
    resultType:表示查询的结果集类型,用来指定对应映射类的类型,且包含完整的包结构,但此处不能是resultType="com.cy.store.entity.User",因为这种写法要求表的字段的名字和类的属性名一模一样
    resultMap:表示当表的字段和类的对象属性名不一致时,来自定义查询结果集的映射规则
--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findByUsername"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"UserEntityMap"</span>&gt;</span>
    select * from t_user where username=#&#123;username&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
</code></pre>
<p>sql语句匹配规则:如果在insert标签里面写了insert语句,首先将insert语句和某一个方法进行绑定，用到了id=“”，但是和哪里的方法进行绑定呢，就要用到namespace=“”，这两步映射就把唯一的SQL语句和唯一的方法进行了关联，实际上就是jdbc里面dao接口的的：</p>
<pre class="highlight"><code class="java">Integer insert（User user） &#123;
    String SQL = <span class="hljs-string">"insert into () values ()"</span>;
&#125;
</code></pre>
<p>用到映射的好处:使SQL语句和java代码分离,解耦了,方便后期代码的维护</p>
<p>4.将mapper文件的位置注册到properties对应的配置文件中.</p>
<p>在application.properties文件中增添:</p>
<pre class="highlight"><code class="xml">mybatis.mapper-locations=classpath:mapper/*.xml
</code></pre>
<h4 id="34单元测试"><a class="markdownIt-Anchor" href="#34单元测试"></a> 3.4单元测试</h4>
<ol>
<li>
<p>每个独立的层编写完毕后需要编写单元测试方法来测试当前的功能:在test包结构下创建一个mapper包,在这个包下再创建持久层的功能测试,单元测试方法是独立运行,不用启动整个项目,提高了代码的测试效率</p>
</li>
<li>
<p>因为测试方法要用到mapper层的接口来访问刚刚写的两个方法,所以要在类里面声明UserMapper对象:即private UserMapper userMapper;且需要加上@Autowired完成值的初始化,但此时会发现提示&quot;Could not <a target="_blank" rel="noopener" href="http://autowire.No">autowire.No</a> beans of’UserMapper’type found&quot;,报错原因是idea有自动检测的功能,在java中接口是不能够直接创建bean的,所以idea认为这个语法不合理,但本质上在项目启动时mybatis自动创建了接口的动态代理实现类,所以从项目的运行角度讲这不能算是错.解决办法:</p>
</li>
</ol>
<ul>
<li>在Settings里面搜索inspections,依次找到Spring-&gt;Spring Core-&gt;Code-&gt;Autowiring for Bean Class然后将Severity的Error改为Warning</li>
</ul>
<pre class="highlight"><code class="java"><span class="hljs-comment">//@SpringBootTest表示当前的类是一个测试类,不会随同项目一块打包</span>
<span class="hljs-meta">@SpringBootTest</span>

<span class="hljs-comment">/**
 * 1.<span class="hljs-doctag">@RunWith</span>表示启动这个单元测试类,否则这个单元测试类是不能运行的,需要传递
 * 一个参数,该参数必须是SpringRunner.class即SpringRunner的实例类型
 * 2.敲完<span class="hljs-doctag">@RunWith</span>(SpringRunner.class)后鼠标分别放在SpringRunner和<span class="hljs-doctag">@RunWith</span>上按alt+enter分别导入包
 * 3.单元测试类中出现的方法必须是单元测试方法
 * 4.单元测试方法的特点:必须被<span class="hljs-doctag">@Test</span>注解修饰;返回值类型必须是void;方法的参数列表不指定任何类型;方法的访问修饰符必须是public
 */</span>
<span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">UserMapperTests</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserMapper userMapper;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span> </span>&#123;
        User user = <span class="hljs-keyword">new</span> User();
        user.setUsername(<span class="hljs-string">"张三"</span>);
        user.setPassword(<span class="hljs-string">"123456"</span>);
        Integer rows = userMapper.insert(user);
        System.out.println(rows);
    &#125;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findByUsername</span><span class="hljs-params">()</span> </span>&#123;
        User user = userMapper.findByUsername(<span class="hljs-string">"张三"</span>);
        System.out.println(user);
    &#125;
&#125;
</code></pre>
<h3 id="4注册-业务层"><a class="markdownIt-Anchor" href="#4注册-业务层"></a> 4.注册-业务层</h3>
<p>业务层的核心功能:</p>
<ul>
<li>接受前端从控制器流转过来的数据</li>
<li>结合真实的注册业务来完成功能业务逻辑的调转和流程</li>
</ul>
<p>所以这里要考虑到真实的业务场景,如果只考虑业务场景的话不完整,因为在整个业务执行的过程中会产生很多问题,从java角度来讲这些都是属于异常,所以在业务开发的时候就要规划相关的异常,以便把项目的错误控制在一定范围内</p>
<p>service下的目录结构(建议这样):</p>
<ul>
<li>service包下创建ex包用来写异常类</li>
<li>service包下创建impl包用来写接口的实现类</li>
<li>接口直接写在service包下,不再需要接口包</li>
</ul>
<h4 id="41规划异常"><a class="markdownIt-Anchor" href="#41规划异常"></a> 4.1规划异常</h4>
<p>1.为什么会有异常:</p>
<p>比如,用户在进行注册时可能会产生用户名被占用的错误,这时需要抛出一个异常</p>
<p>2.怎么处理异常:</p>
<ul>
<li>异常不能用RuntimeException,太笼统了,开发者没办法第一时间定位到具体的错误类型上,我们可以定义具体的异常类型来继承这个异常.</li>
<li>正常的开发中异常又要分等级,可能是在业务层产生异常,可能是在控制层产生异常,所以可以创建一个业务层异常的基类,起名ServiceException异常,并使其继承RuntimeException异常</li>
<li>后期开发业务层时具体的异常可以再继承业务层的异常ServiceException</li>
</ul>
<p>3.处理异常的具体步骤:</p>
<p>步骤一:在ex包下创建ServiceException类作为业务层异常的基类:</p>
<pre class="highlight"><code class="java"><span class="hljs-comment">/**
 * 因为整个业务的异常只有一种情况下才会产生:只有运行时才会产生,不运行不会产生
 * 所以要求业务层的异常都要继承运行时异常RuntimeException并且重写父类的所有构造方法以便后期能抛出自已定义的异常
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span></span>&#123;
    <span class="hljs-comment">//什么也不返回</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServiceException</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">super</span>();
    &#125;

    <span class="hljs-comment">//返回异常信息(常用)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServiceException</span><span class="hljs-params">(String message)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(message);
    &#125;

    <span class="hljs-comment">//返回异常信息和异常对象(常用)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServiceException</span><span class="hljs-params">(String message, Throwable cause)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(message, cause);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServiceException</span><span class="hljs-params">(Throwable cause)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(cause);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">ServiceException</span><span class="hljs-params">(String message, Throwable cause, <span class="hljs-keyword">boolean</span> enableSuppression, <span class="hljs-keyword">boolean</span> writableStackTrace)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(message, cause, enableSuppression, writableStackTrace);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>根据业务层不同功能来定义具体异常类型，统一继承ServiceException异常类</p>
</blockquote>
<p>步骤二:后期再根据业务层不同的功能来详细定义具体的异常类型,并统一的继承ServiceException异常基类:</p>
<ul>
<li>用户在进行注册时可能会产生用户名被占用的错误,这时需要抛出一个<code>UsernameDuplicatedException</code>异常</li>
</ul>
<pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsernameDuplicatedException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceException</span></span>&#123;
    <span class="hljs-comment">/**重写ServiceException的所有构造方法*/</span>
&#125;

</code></pre>
<ul>
<li>正在执行数据插入操作的时候,服务器宕机或数据库宕机.这种情况是处于正在执行插入的过程中所产生的异常,起名<code>InsertException</code>异常</li>
</ul>
<pre class="highlight"><code class="java"><span class="hljs-comment">//数据插入过程中产生异常</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InsertException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceException</span></span>&#123;
    <span class="hljs-comment">/**重写ServiceException的所有构造方法*/</span>
&#125;
</code></pre>
<h4 id="42设计接口和抽象方法"><a class="markdownIt-Anchor" href="#42设计接口和抽象方法"></a> 4.2设计接口和抽象方法</h4>
<p>1.在service包下创建IUserService接口(接口命名的默认规则:I+业务名字+层的名字)</p>
<pre class="highlight"><code class="java"><span class="hljs-comment">/**用户模块业务层接口*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserService</span> </span>&#123;
    <span class="hljs-comment">/**
     * 用户注册方法
     * <span class="hljs-doctag">@param</span> user 用户的数据对象
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reg</span><span class="hljs-params">(User user)</span></span>;
&#125;
</code></pre>
<p>2.创建一个实现UserServiceImpl类,需要实现IUserService接口,并且实现抽象的方法</p>
<p>因为要将这个实现类交给spring管理,所以需要在类上加@Service</p>
<pre class="highlight"><code class="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserService</span> </span>&#123;

    <span class="hljs-comment">//reg方法核心就是调用mapper层的方法,所以要声明UserMapper对象并加@Autowired注解</span>
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserMapper userMapper;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reg</span><span class="hljs-params">(User user)</span> </span>&#123;
        <span class="hljs-comment">//通过user参数来获取传递过来的username</span>
        String username = user.getUsername();
        <span class="hljs-comment">//调用mapper的findByUsername(username)判断用户是否被注册过了</span>
        User result = userMapper.findByUsername(username);
        <span class="hljs-comment">//判断结果集是否为null,不为null的话则需抛出用户名被占用的异常</span>
        <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">//抛出异常</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameDuplicatedException(<span class="hljs-string">"用户名被占用"</span>);
        &#125;

        <span class="hljs-comment">/**
         * 密码加密处理作用:
         * 1.后端不再能直接看到用户的密码2.忽略了密码原来的强度,提升了数据安全性
         * 密码加密处理的实现:
         * 串+password+串-&gt;交给md5算法连续加密三次
         * 串就是数据库字段中的盐值,是一个随机字符串
         */</span>
        String oldpassword = user.getPassword();
        <span class="hljs-comment">//1.随机生成一个盐值(大写的随机字符串)</span>
        String salt = UUID.randomUUID().toString().toUpperCase();
        <span class="hljs-comment">//2.将密码和盐值作为一个整体进行加密处理</span>
        String md5Password = getMD5Password(oldpassword, salt);
        <span class="hljs-comment">//3.将盐值保存到数据库</span>
        user.setSalt(salt);
        <span class="hljs-comment">//4.将加密之后的密码重新补全设置到user对象当中</span>
        user.setPassword(md5Password);

        <span class="hljs-comment">//补全数据:is_delete设置为0</span>
        user.setIsDelete(<span class="hljs-number">0</span>);
        <span class="hljs-comment">//补全数据:四个日志字段信息</span>
        user.setCreatedUser(user.getUsername());
        user.setModifiedUser(user.getUsername());
        Date date = <span class="hljs-keyword">new</span> Date();<span class="hljs-comment">//java.util.Date</span>
        user.setCreatedTime(date);
        user.setModifiedTime(date);


        <span class="hljs-comment">//执行注册业务功能的实现</span>
        Integer rows = userMapper.insert(user);
        <span class="hljs-keyword">if</span> (rows != <span class="hljs-number">1</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InsertException(<span class="hljs-string">"在用户注册过程中产生了未知的异常"</span>);
        &#125;
    &#125;
&#125;
</code></pre>
<p>md5加密算法以后可能还要多次用到,为了方便在UserServiceImpl类里面单独写一个getMD5Password方法</p>
<pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getMD5Password</span><span class="hljs-params">(String password,String salt)</span> </span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;
        password = DigestUtils.md5DigestAsHex((salt + password + salt).getBytes()).toUpperCase();
    &#125;
    <span class="hljs-keyword">return</span> password;
&#125;
</code></pre>
<h4 id="43单元测试"><a class="markdownIt-Anchor" href="#43单元测试"></a> 4.3单元测试</h4>
<p>在单元测试包下创建一个UserServiceTests类,在这个类中添加单元测试的功能(技巧:可以先在test.com.cy.store下创建service包,然后点击UserMapperTests并ctrl+c,然后点击service包ctrl+v会弹出修改类名,将UserMapperTests改为UserServiceTests即可,然后修改部分代码至如下这样)</p>
<pre class="highlight"><code class="java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">UserServiceTests</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> IUserService userService;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reg</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">/**
         * 进行插入时可能会出错抛出异常,这时需要捕获异常:
         * 1.选中    User user = new User();
         *           user.setUsername("张7");
         *           user.setPassword("123456");
         *           userService.reg(user);
         *           System.out.println("OK");
         * 2.点击导航栏的Code,然后依次点击SurroundWith-&gt;try/catch就可以捕获异常了
         * 3.Exception e没有问题,但这里我们知道是Service层的异常,所以可以改为ServiceException e
         * 4.System.out.println(e.getClass().getSimpleName());获取异常对象再获取类的名称然后输出
         * 5.System.out.println(e.getMessage());输出异常信息(是自己在ServiceException的子类类具体设置的信息)
         */</span>
        <span class="hljs-keyword">try</span> &#123;
            User user = <span class="hljs-keyword">new</span> User();
            user.setUsername(<span class="hljs-string">"张7"</span>);
            user.setPassword(<span class="hljs-string">"123456"</span>);
            userService.reg(user);
            System.out.println(<span class="hljs-string">"OK"</span>);
        &#125; <span class="hljs-keyword">catch</span> (ServiceException e) &#123;
            System.out.println(e.getClass().getSimpleName());
            System.out.println(e.getMessage());
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="5注册-控制层"><a class="markdownIt-Anchor" href="#5注册-控制层"></a> 5.注册-控制层</h3>
<h4 id="51创建响应"><a class="markdownIt-Anchor" href="#51创建响应"></a> 5.1创建响应</h4>
<p>状态码,状态描述信息,数据是所有控制层对应的方法都涉及到的操作,所以把这部分功能封装到一个类JsonResult中,将这个类作为方法的返回值返回给前端浏览器:</p>
<pre class="highlight"><code class="java"><span class="hljs-comment">//因为所有的响应的结果都采用Json格式的数据进行响应,所以需要实现Serializable接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsonResult</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;
    <span class="hljs-comment">//状态码</span>
    <span class="hljs-keyword">private</span> Integer state;
    <span class="hljs-comment">//描述信息</span>
    <span class="hljs-keyword">private</span> String message;
    <span class="hljs-comment">//数据类型不确定,用E表示任何的数据类型,一个类里如果声明的有泛型的数据类型,类也要声明为泛型</span>
    <span class="hljs-keyword">private</span> E data;

    <span class="hljs-comment">//无参构造</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JsonResult</span><span class="hljs-params">()</span> </span>&#123;
    &#125;

    <span class="hljs-comment">//将状态码传给构造方法初始化对象</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JsonResult</span><span class="hljs-params">(Integer state)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.state = state;
    &#125;


    <span class="hljs-comment">//将状态码和数据传给构造方法初始化对象</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JsonResult</span><span class="hljs-params">(Integer state, E data)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.state = state;
        <span class="hljs-keyword">this</span>.data = data;
    &#125;

    <span class="hljs-comment">//如果有异常,直接将异常传递给构造方法初始化对象</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JsonResult</span><span class="hljs-params">(Throwable e)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.message=e.getMessage();
    &#125;
    <span class="hljs-comment">/**以及属性的get和set方法*/</span>
&#125;
</code></pre>
<h4 id="52设计请求"><a class="markdownIt-Anchor" href="#52设计请求"></a> 5.2设计请求</h4>
<p>接下来该向后端服务器发送请求以把用户数据插入到数据库,设计发送请求模块的第一步就是设计相关的请求</p>
<p>依据当前的业务功能模块进行请求的设计:</p>
<ul>
<li>请求路径:/users/reg</li>
<li>请求参数:User user</li>
<li>请求类型:POST</li>
<li>响应结果:`JsonResult<Void></li>
</ul>
<h4 id="53处理请求"><a class="markdownIt-Anchor" href="#53处理请求"></a> 5.3处理请求</h4>
<p>创建一个控制层对应的UserController类,依赖于业务层的接口.编写完成后启动主服务验证一下</p>
<pre class="highlight"><code class="java"><span class="hljs-meta">@RestController</span> <span class="hljs-comment">//其作用等同于@Controller+@ResponseBody</span>
<span class="hljs-comment">//@Controller</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> IUserService userService;

    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"reg"</span>)
    <span class="hljs-comment">//@ResponseBody //表示此方法的响应结果以json格式进行数据的响应给到前端</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> JsonResult&lt;Void&gt; <span class="hljs-title">reg</span><span class="hljs-params">(User user)</span> </span>&#123;
        <span class="hljs-comment">//创建响应结果对象即JsonResult对象</span>
        JsonResult&lt;Void&gt; result = <span class="hljs-keyword">new</span> JsonResult&lt;&gt;();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//调用userService的reg方法时可能出现异常,所以需要捕获异常</span>
            userService.reg(user);
            result.setState(<span class="hljs-number">200</span>);
            result.setMessage(<span class="hljs-string">"用户注册成功"</span>);
        &#125; <span class="hljs-keyword">catch</span> (UsernameDuplicatedException e) &#123;
            result.setState(<span class="hljs-number">4000</span>);
            result.setMessage(<span class="hljs-string">"用户名被占用"</span>);
        &#125; <span class="hljs-keyword">catch</span> (InsertException e) &#123;
            result.setState(<span class="hljs-number">5000</span>);
            result.setMessage(<span class="hljs-string">"注册时产生未知的异常"</span>);
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;
</code></pre>
<h4 id="54控制层优化设计"><a class="markdownIt-Anchor" href="#54控制层优化设计"></a> 5.4控制层优化设计</h4>
<p>凡是业务层抛出的异常我们都在控制层进行了捕获,如果其他的业务模块也抛用户名被占用或者插入时异常,那么抛出异常的代码就要重复编写</p>
<p>优化方法:在控制层抽离出一个BaseController父类,在这个父类中统一处理关于异常的相关操作,优化如下:</p>
<p>1.在controller包下创建UserController类作为控制层下类的基类,用来做统一的异常捕获:</p>
<pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseController</span> </span>&#123;

    <span class="hljs-comment">//操作成功的状态码</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OK = <span class="hljs-number">200</span>;

    <span class="hljs-comment">/**
     * 1.<span class="hljs-doctag">@ExceptionHandler</span>表示该方法用于处理捕获抛出的异常
     * 2.什么样的异常才会被这个方法处理呢?所以需要ServiceException.class,这样的话只要是抛出ServiceException异常就会被拦截到handleException方法,此时handleException方法就是请求处理方法,返回值就是需要传递给前端的数据
     * 3.被ExceptionHandler修饰后如果项目发生异常,那么异常对象就会被自动传递给此方法的参数列表上,所以形参就需要写Throwable e用来接收异常对象
     */</span>
    <span class="hljs-meta">@ExceptionHandler</span>(ServiceException<span class="hljs-class">.<span class="hljs-keyword">class</span>)
    <span class="hljs-title">public</span> <span class="hljs-title">JsonResult</span>&lt;<span class="hljs-title">Void</span>&gt; <span class="hljs-title">handleException</span>(<span class="hljs-title">Throwable</span> <span class="hljs-title">e</span>) </span>&#123;
        JsonResult&lt;Void&gt; result = <span class="hljs-keyword">new</span> JsonResult&lt;&gt;(e);
        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> UsernameDuplicatedException) &#123;
            result.setState(<span class="hljs-number">4000</span>);
            result.setMessage(<span class="hljs-string">"用户名已经被占用"</span>);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> InsertException) &#123;
            result.setState(<span class="hljs-number">5000</span>);
            result.setMessage(<span class="hljs-string">"插入数据时产生未知的异常"</span>);
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;

</code></pre>
<p>2.让UserController继承BaseController并重构UserController下的reg方法使该方法只需要关注请求处理而不再需要关注异常捕获:</p>
<pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> JsonResult&lt;Void&gt; <span class="hljs-title">reg</span><span class="hljs-params">(User user)</span> </span>&#123;
    userService.reg(user);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JsonResult&lt;&gt;(OK);
&#125;
</code></pre>
<h3 id="6注册-前端页面"><a class="markdownIt-Anchor" href="#6注册-前端页面"></a> 6.注册-前端页面</h3>
<h4 id="61熟悉ajax"><a class="markdownIt-Anchor" href="#61熟悉ajax"></a> 6.1熟悉ajax</h4>
<p>1.什么是ajax函数?</p>
<p>这是jQuery封装的一个函数,称为$.ajax()函数,<br />
通过对象调用ajax()函数用来异步加载相关的请求.依靠的是JavaScript提供的一个对象:XHR(全称XmlHttpResponse)</p>
<p>2.ajax()函数的语法结构:</p>
<ul>
<li>使用ajax()时需要传递一个方法体作为方法的参数来使用(一对大括号就是一个方法体)</li>
<li>ajax接受多个参数时,参数与参数之间使用&quot;,&quot;分割</li>
<li>每一组参数之间使用&quot;:&quot;进行分割</li>
<li>参数的组成部分一个是参数的名称(不能随便定义),另一个是参数的值(必须用字符串来表示)</li>
<li>参数的声明顺序没有要求</li>
</ul>
<p>演示一下语法结构:</p>
<pre class="highlight"><code class="js">$.ajax(&#123;
    <span class="hljs-attr">url</span>: <span class="hljs-string">""</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">""</span>,
    <span class="hljs-attr">data</span>: <span class="hljs-string">""</span>,
    <span class="hljs-attr">dataType</span>: <span class="hljs-string">""</span>,
    <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        
    &#125;,
    <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        
    &#125;
&#125;);
</code></pre>
<ol start="3">
<li>ajax()函数参数的含义:</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>url</code></td>
<td><code>表示请求的地址(url地址),例如:url:“localhost:8080/users/reg”(1.不能包含参数列表部分的内容2.如果提交的请求是项目内部的一个url,那么端口号前面的都可以省略掉,即url:“/users/reg”)</code></td>
</tr>
<tr>
<td><code>type</code></td>
<td><code>请求类型(GET和POST请求的类型).例如:type:“POST”(get和post不区分大小写)</code></td>
</tr>
<tr>
<td><code>data</code></td>
<td><code>向指定的请求url地址提交的数据.例如:data:“username=tom&amp;pwd=123”</code></td>
</tr>
<tr>
<td><code>dataType</code></td>
<td><code>提交的数据的类型.数据的类型一般指定为json类型.例如:dataType:“json”(json不区分大小写)</code></td>
</tr>
<tr>
<td><code>success</code></td>
<td><code>当服务器正常响应客户端时,会自动调用success参数的方法,并且将服务器返回的数据以参数的形式传递给这个方法的参数上</code></td>
</tr>
<tr>
<td><code>error</code></td>
<td><code>当服务器未正常响应客户端时,会自动调用error参数的方法,并且将服务器返回的数据以参数的形式传递给这个方法的参数上</code></td>
</tr>
</tbody>
</table>
<h4 id="62前端js编写"><a class="markdownIt-Anchor" href="#62前端js编写"></a> 6.2前端js编写</h4>
<p>js代码可以独立声明在一个js文件里或者声明在一个script标签中.现在我们在register.html中编写js代码,js代码可以放在head标签中,也可以放在body标签中,可以放在任意一个位置,只要被script标签包裹就行了,这里我们放在整个body结束之前:</p>
<pre class="highlight"><code class="html">        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
            <span class="hljs-comment">//1.监听注册按钮是否被点击,如果被点击可以执行一个方法(这里不能像ajax函数那样删去function()只留下&#123;&#125;,这是官方规定的!)</span>
            $(<span class="hljs-string">"#btn-reg"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;

                <span class="hljs-comment">//let username = $("#username").val();</span>
                <span class="hljs-comment">//let pwd = $("#password").val();</span>
                <span class="hljs-comment">//上面这两行是动态获取表单中控件的数据,但是如果这样获取的话ajax函数中</span>
                <span class="hljs-comment">//就是data: "username="+username + "&amp;password="+pwd,但太麻烦了,如</span>
                <span class="hljs-comment">// 果这个表单提交的是用户的兴趣爱好,那数据就很多了,一个表单20个数据都很正</span>
                <span class="hljs-comment">// 常,如果此时还用这种方式就太麻烦了,所以不建议用这种方式</span>

                <span class="hljs-comment">//2.发送ajax()的异步请求来完成用户的注册功能</span>
                $.ajax(&#123;
                    <span class="hljs-attr">url</span>: <span class="hljs-string">"/users/reg"</span>,
                    <span class="hljs-attr">type</span>: <span class="hljs-string">"POST"</span>,

                    <span class="hljs-comment">//serialize这个API会自动检测该表单有什么控件,每个控件检测后还会获取每个控</span>
                    <span class="hljs-comment">// 件的值,拿到这个值后并自动拼接成形如username=Tom&amp;password=123的结构</span>
                    <span class="hljs-attr">data</span>: $(<span class="hljs-string">"#form-reg"</span>).serialize(),

                    <span class="hljs-attr">dataType</span>: <span class="hljs-string">"JSON"</span>,
                    <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">json</span>) </span>&#123; <span class="hljs-comment">//1.js是弱数据类型,这个地方不用声明json的数据类型</span>
                        <span class="hljs-comment">//2.如果服务器成功响应就会将返回的数据传给形参,比如&#123;state: 4000,message: "用户名</span>
                        <span class="hljs-comment">// 已经被占用",data: null&#125;</span>
                        <span class="hljs-keyword">if</span> (json.state == <span class="hljs-number">200</span>) &#123;
                            alert(<span class="hljs-string">"注册成功"</span>)
                        &#125; <span class="hljs-keyword">else</span> &#123;
                            alert(<span class="hljs-string">"注册失败"</span>)
                        &#125;
                    &#125;,
                    <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) </span>&#123; <span class="hljs-comment">//如果问题不在可控范围内,服务器就不会返回自己定</span>
                        <span class="hljs-comment">//义的json字符串:&#123;state: 4000,message: "用户名已经被占用",data: null&#125;</span>
                        <span class="hljs-comment">//而是返回一个XHR类型的对象,该对象也有一个状态码名字是status</span>
                        alert(<span class="hljs-string">"注册时产生未知的错误!"</span>+xhr.status);
                    &#125;
                &#125;);
            &#125;);
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>此时可能会出现点击注册提交表单时没有任何响应,原因是idea对于JS代码的兼容性较差,编写了js代码但是有的时候不能正常去加载,解决办法有四种,同前面的:项目环境搭建-&gt;项目测试-&gt;测试静态资源能否正常加载</p>
<p>包括以后如果修改了前端页面,测试时没有报错也没有按照预想的响应,就考虑是编写的js代码还没有被加载,尝试用这四种方法解决</p>
<h2 id="用户登录功能"><a class="markdownIt-Anchor" href="#用户登录功能"></a> 用户登录功能</h2>
<p>先分析一下思路:当用户输入用户名和密码将数据提交给后台数据库进行查询,如果存在对应的用户名和密码则表示登录成功,登录成功之后跳转到系统的主页就是index.html页面,跳转在前端使用jQuery来完成</p>
<h3 id="1登录-持久层"><a class="markdownIt-Anchor" href="#1登录-持久层"></a> 1.登录-持久层</h3>
<h4 id="规划需要执行的sql语句"><a class="markdownIt-Anchor" href="#规划需要执行的sql语句"></a> 规划需要执行的SQL语句</h4>
<p>依据用户提交的用户名来做select查询</p>
<p><code>select \* from t\_user where username=? and password=?</code>这种不太好,这种相当于在查询用户名时直接判断了用户和密码是否一致了,如果持久层把判断做了那业务层就没事干了,所以这里我们只查询用户名,判断用户名和密码是否一致交给业务层做</p>
<pre class="highlight"><code class="sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> username=?
</code></pre>
<blockquote>
<p>分析完以后发现这个功能模块已经被开发完成(UserMapper接口的findByUsername方法),所以就可以省略当前的开发步骤,但是这个分析过程不能省略</p>
</blockquote>
<blockquote>
<p>后续的设计接口和抽象方法,编写映射,单元测试都不再需要进行,</p>
</blockquote>
<h3 id="2登录-业务层"><a class="markdownIt-Anchor" href="#2登录-业务层"></a> 2.登录-业务层</h3>
<h4 id="21规划异常"><a class="markdownIt-Anchor" href="#21规划异常"></a> 2.1规划异常</h4>
<ul>
<li>用户名对应的密码错误,即密码匹配的异常,起名PasswordNotMatchException,这个是运行时异常</li>
</ul>
<pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PasswordNotMatchException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceException</span></span>&#123;
    <span class="hljs-comment">/**重写ServiceException的所有构造方法*/</span>
&#125;
</code></pre>
<ul>
<li>用户名没有被找到的异常,起名UsernameNotFoundException,这个也是运行时异常</li>
</ul>
<pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsernameNotFoundException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceException</span> </span>&#123;
    <span class="hljs-comment">/**重写ServiceException的所有构造方法*/</span>
&#125;
</code></pre>
<h4 id="22设计接口和抽象方法及实现"><a class="markdownIt-Anchor" href="#22设计接口和抽象方法及实现"></a> 2.2设计接口和抽象方法及实现</h4>
<p>1.在IUserService接口中编写抽象方法login(String username,String password)login(User user)也是可以的</p>
<blockquote>
<p>细说一个事:登录成功某一个网站后,右上角会展示头像,昵称甚至电话号码等等,这些信息依赖于登陆成功后的信息,也就意味着一旦登录成功后在页面中切换到任意一个子页面写右上角都会展示这些信息.本质上就是查询出来这些信息,然后展示在右上角,但是这里实现查询不太现实:js中虽然打开一个html页面就自动发送一个请求,但这样就需要把这个查询的代码写在每一个html页面,显然不现实</p>
</blockquote>
<p>这种情况下我们可以将当前登录成功的用户数据以当前用户对象的形式进行返回,然后进行状态管理:将数据保存在cookie或者session中,可以避免重复度很高的数据多次频繁操作数据库进行获取(这里我们用session存放用户名和用户id,用cookie存放用户头像,其中用户id是为因为有的页面展示依赖于id,用户头像也可以放在session中,而这里放在cookie是为了回顾一下cookie)</p>
<pre class="highlight"><code class="java">    <span class="hljs-comment">/**
     * 用户登录功能
     * <span class="hljs-doctag">@param</span> username 用户名
     * <span class="hljs-doctag">@param</span> password 用户密码
     * <span class="hljs-doctag">@return</span> 当前匹配的用户数据,如果没有则返回null
     */</span>
    <span class="hljs-function">User <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>;
</code></pre>
<p>2.在抽象类UserServiceImpl中实现该抽象方法</p>
<pre class="highlight"><code class="java">    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">login</span><span class="hljs-params">(String username, String password)</span> </span>&#123;
        <span class="hljs-comment">//根据用户名称来查询用户的数据是否存在,不存在则抛出异常</span>
        User result = userMapper.findByUsername(username);
        <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"用户数据不存在"</span>);
        &#125;

        <span class="hljs-comment">/**
         * 检测用户的密码是否匹配:
         * 1.先获取数据库中加密之后的密码
         * 2.和用户传递过来的密码进行比较
         *  2.1先获取盐值
         *  2.2将获取的用户密码按照相同的md5算法加密
         */</span>
        String oldPassword = result.getPassword();
        String salt = result.getSalt();
        String newMd5Password = getMD5Password(password, salt);
        <span class="hljs-keyword">if</span> (!newMd5Password.equals(oldPassword)) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PasswordNotMatchException(<span class="hljs-string">"用户密码错误"</span>);
        &#125;

        <span class="hljs-comment">//判断is_delete字段的值是否为1,为1表示被标记为删除</span>
        <span class="hljs-keyword">if</span> (result.getIsDelete() == <span class="hljs-number">1</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"用户数据不存在"</span>);
        &#125;

        <span class="hljs-comment">//方法login返回的用户数据是为了辅助其他页面做数据展示使用(只会用到uid,username,avatar)</span>
        <span class="hljs-comment">//所以可以new一个新的user只赋这三个变量的值,这样使层与层之间传输时数据体量变小,后台层与</span>
        <span class="hljs-comment">// 层之间传输时数据量越小性能越高,前端也是的,数据量小了前端响应速度就变快了</span>
        User user = <span class="hljs-keyword">new</span> User();
        user.setUid(result.getUid());
        user.setUsername(result.getUsername());
        user.setAvatar(result.getAvatar());
        <span class="hljs-keyword">return</span> user;
    &#125;
</code></pre>
<h4 id="23单元测试"><a class="markdownIt-Anchor" href="#23单元测试"></a> 2.3单元测试</h4>
<p>在业务层的测试类UserServiceTests中添加测试方法:</p>
<pre class="highlight"><code class="java">    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//因为login方法可能抛出异常,所以应该捕获异常,但是测试时没必要写那么严谨</span>
        User user = userService.login(<span class="hljs-string">"test02"</span>, <span class="hljs-string">"12"</span>);
        System.out.println(user);
    &#125;
</code></pre>
<h3 id="3登录-控制层"><a class="markdownIt-Anchor" href="#3登录-控制层"></a> 3.登录-控制层</h3>
<h4 id="31处理异常"><a class="markdownIt-Anchor" href="#31处理异常"></a> 3.1处理异常</h4>
<p>业务层抛出的异常需要在统一异常处理类中进行统一的捕获和处理,如果该异常类型已经在统一异常类中曾经处理过则不需要重复添加</p>
<pre class="highlight"><code class="java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> UsernameNotFoundException) &#123;
    result.setState(<span class="hljs-number">4001</span>);
    result.setMessage(<span class="hljs-string">"用户数据不存在的异常"</span>);
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> PasswordNotMatchException) &#123;
    result.setState(<span class="hljs-number">4002</span>);
    result.setMessage(<span class="hljs-string">"用户名密码错误的异常"</span>);
&#125;
</code></pre>
<h4 id="32设计请求"><a class="markdownIt-Anchor" href="#32设计请求"></a> 3.2设计请求</h4>
<ul>
<li>请求路径:/users/login</li>
<li>请求参数:String username,String password</li>
<li>请求类型:POST</li>
<li>响应结果:`JsonResult<User></li>
</ul>
<h4 id="33处理请求"><a class="markdownIt-Anchor" href="#33处理请求"></a> 3.3处理请求</h4>
<p>在UserController类中编写处理请求的方法.编写完成后启动主服务验证一下</p>
<pre class="highlight"><code class="java">    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"login"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> JsonResult&lt;User&gt; <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span> </span>&#123;
        User data = userService.login(username, password);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JsonResult&lt;User&gt;(OK,data);
    &#125;
</code></pre>
<blockquote>
<p>注意,控制层方法的参数是用来接收前端数据的,接收数据方式有两种:</p>
</blockquote>
<ul>
<li>
<p>请求处理方法的参数列表设置为非pojo类型:</p>
<p>SpringBoot会直接将请求的参数名和方法的参数名直接进行比较,如果名称相同则自动完成值的依赖注入</p>
</li>
<li>
<p>请求处理方法的参数列表设置为pojo类型:</p>
<p>SpringBoot会将前端的url地址中的参数名和pojo类的属性名进行比较,如果这两个名称相同,则将值注入到pojo类中对应的属性上</p>
</li>
</ul>
<p>这两种方法都没有使用注解等等花里胡哨的,却能正常使用,原因是springboot是约定大于配置的,省略了大量配置以及注解的编写</p>
<h3 id="4登录-前端页面"><a class="markdownIt-Anchor" href="#4登录-前端页面"></a> 4.登录-前端页面</h3>
<p>在login.html加入script标签:</p>
<pre class="highlight"><code class="html">        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
            $(<span class="hljs-string">"#btn-login"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
                $.ajax(&#123;
                    <span class="hljs-attr">url</span>: <span class="hljs-string">"/users/login"</span>,
                    <span class="hljs-attr">type</span>: <span class="hljs-string">"POST"</span>,
                    <span class="hljs-attr">data</span>: $(<span class="hljs-string">"#form-login"</span>).serialize(),
                    <span class="hljs-attr">dataType</span>: <span class="hljs-string">"JSON"</span>,
                    <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">json</span>) </span>&#123;
                        <span class="hljs-keyword">if</span> (json.state == <span class="hljs-number">200</span>) &#123;
                            alert(<span class="hljs-string">"登录成功"</span>)
                            <span class="hljs-comment">//跳转到系统主页index.html</span>
                            <span class="hljs-comment">//index和login在同一个目录结构下,所以可以用相对路</span>
                            <span class="hljs-comment">// 径index.html来确定跳转的页面,index.html和./ind</span>
                            <span class="hljs-comment">// ex.html完全一样,因为./就是表示当前目录</span>
                            <span class="hljs-comment">// 结构,也可以用../web/index.html</span>
                            location.href = <span class="hljs-string">"index.html"</span>;
                        &#125; <span class="hljs-keyword">else</span> &#123;
                            alert(<span class="hljs-string">"登录失败"</span>)
                        &#125;
                    &#125;,
                    <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) </span>&#123;
                        <span class="hljs-comment">//xhr.message可以获取未知异常的信息</span>
                        alert(<span class="hljs-string">"登录时产生未知的异常!"</span>+xhr.message);
                    &#125;
                &#125;);
            &#125;);
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 id="5用session存储和获取用户数据"><a class="markdownIt-Anchor" href="#5用session存储和获取用户数据"></a> 5.用session存储和获取用户数据</h3>
<ul>
<li>在用户登录成功后要保存下来用户的id,username,avatar,并且需要在任何类中都可以访问存储下来的数据,也就是说存储在一个全局对象中,会话session可以实现</li>
<li>把首次登录所获取的用户数据转移到session对象即可</li>
<li>获取session对象的属性值用session.getAttribute(“key”),因为session对象的属性值在很多页面都要被访问,这时用session对象调用方法获取数据就显得太麻烦了,解决办法是将获取session中数据的这种行为进行封装</li>
<li>考虑一下封装在哪里呢?放在一个干净的工具类里肯定可以,但就这个项目目录结构而言,只有可能在控制层使用session,而控制层里的类又继承BaseController,所以可以封装到BaseController里面</li>
</ul>
<p>综上所述,该功能的实现需要两步:</p>
<p>1.在父类中封装两个方法:获取uid和获取username对应的两个方法(用户头像暂不考虑,将来封装到cookie中来使用)</p>
<pre class="highlight"><code class="java">    <span class="hljs-comment">/**
     * 获取session对象中的uid
     * <span class="hljs-doctag">@param</span> session session对象
     * <span class="hljs-doctag">@return</span> 当前登录的用户uid的值
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Integer <span class="hljs-title">getUidFromSession</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;
        <span class="hljs-comment">//getAttribute返回的是Object对象,需要转换为字符串再转换为包装类</span>
        <span class="hljs-keyword">return</span> Integer.valueOf(session.getAttribute(<span class="hljs-string">"uid"</span>).toString());
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">getUsernameFromSession</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;
        <span class="hljs-keyword">return</span> session.getAttribute(<span class="hljs-string">"username"</span>).toString();
    &#125;
</code></pre>
<p>2.把首次登录所获取的用户数据转移到session对象:</p>
<p>服务器本身自动创建有session对象,已经是一个全局的session对象,所以我们需要想办法获取session对象:如果直接将HttpSession类型的对象作为请求处理方法的参数,这时springboot会自动将全局的session对象注入到请求处理方法的session形参上:</p>
<ul>
<li>
<p>将登录模块的设计请求中的请求参数:String username,String password加上HttpSession session</p>
</li>
<li>
<p>将登录模块的处理请求中login方法加上参数HttpSession session并修改代码如下:</p>
<pre class="highlight"><code class="java">    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"login"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> JsonResult&lt;User&gt; <span class="hljs-title">login</span><span class="hljs-params">(String username, String password, HttpSession session)</span> </span>&#123;
        User data = userService.login(username, password);

        <span class="hljs-comment">//向session对象中完成数据的绑定(这个session是全局的,项目的任何位置都可以访问)</span>
        session.setAttribute(<span class="hljs-string">"uid"</span>,data.getUid());
        session.setAttribute(<span class="hljs-string">"username"</span>,data.getUsername());

        <span class="hljs-comment">//测试能否正常获取session中存储的数据</span>
        System.out.println(getUidFromSession(session));
        System.out.println(getUsernameFromSession(session));

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JsonResult&lt;User&gt;(OK,data);
    &#125;
</code></pre>
</li>
</ul>
<h3 id="6拦截器"><a class="markdownIt-Anchor" href="#6拦截器"></a> 6.拦截器</h3>
<ul>
<li>拦截器的作用是将所有的请求统一拦截到拦截器中,可以在拦截器中定义过滤的规则,如果不满足系统设置的过滤规则,该项目统一的处理是重新去打开login.html页面(重定向和转发都可以,推荐使用重定向)</li>
<li>拦截器在springboot中本质是依靠springMVC完成的.springMVC提供了一个HandlerInterceptor接口用于表示定义一个拦截器</li>
</ul>
<p>1.所以想要使用拦截器就要定义一个类并使其实现HandlerInterceptor接口,在store下建包interceptor,包下建类LoginInterceptor并编写代码:</p>
<pre class="highlight"><code class="java"><span class="hljs-comment">/**定义一个拦截器*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;
    <span class="hljs-comment">/**
     *检测全局session对象中是否有uid数据,如果有则放行,如果没有重定向到登录页面
     * <span class="hljs-doctag">@param</span> request 请求对象
     * <span class="hljs-doctag">@param</span> response 响应对象
     * <span class="hljs-doctag">@param</span> handler 处理器(把url和Controller映射到一块)
     * <span class="hljs-doctag">@return</span> 返回值为true放行当前请求,反之拦截当前请求
     * <span class="hljs-doctag">@throws</span> Exception
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-comment">//在DispatcherServlet调用所有处理请求的方法前被自动调用执行的方法</span>
    <span class="hljs-comment">//springboot会自动把请求对象给到request,响应对象给到response,适配器给到handler</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, 
                             HttpServletResponse response, 
                             Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//通过HttpServletRequest对象来获取session对象</span>
        Object obj = request.getSession().getAttribute(<span class="hljs-string">"uid"</span>);
        <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//说明用户没有登录过系统,则重定向到login.html页面</span>
            <span class="hljs-comment">//不能用相对路径,因为这里是要告诉前端访问的新页面是在哪个目录下的新</span>
            <span class="hljs-comment">//页面,但前面的localhost:8080可以省略,因为在同一个项目下</span>
            response.sendRedirect(<span class="hljs-string">"/web/login.html"</span>);
            <span class="hljs-comment">//结束后续的调用</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;
        <span class="hljs-comment">//放行这个请求</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-comment">//在ModelAndView对象返回给DispatcherServlet之后被自动调用的方法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
   &#125;
    <span class="hljs-comment">//在整个请求所有关联的资源被执行完毕后所执行的方法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
   &#125;
&#125;
</code></pre>
<p>2.注册过滤器:</p>
<p>注册过滤器的技术:借助WebMvcConfigure接口将用户定义的拦截器进行注册.所以想要注册过滤器需要定义一个类使其实现WebMvcConfigure接口并在其内部<br />
添加黑名单(在用户登录的状态下才可以访问的页面资源)和<br />
白名单(哪些资源可以在不登录的情况下访问:①register.html②login.html③index.html④/users/reg⑤/users/login⑥静态资源):</p>
<blockquote>
<p>WebMvcConfigure是配置信息,建议在store包下建config包,再定义类LoginInterceptorConfigure</p>
</blockquote>
<pre class="highlight"><code class="java"><span class="hljs-comment">/**拦截器的注册*/</span>
<span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//自动加载当前的类并进行拦截器的注册,如果没有@Configuration就相当于没有写类LoginInterceptorConfigure</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginInterceptorConfigure</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-comment">//配置拦截器</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;
        <span class="hljs-comment">//1.创建自定义的拦截器对象</span>
        HandlerInterceptor interceptor =  <span class="hljs-keyword">new</span> LoginInterceptor();
        <span class="hljs-comment">//2.配置白名单并存放在一个List集合</span>
        List&lt;String&gt; patterns = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        patterns.add(<span class="hljs-string">"/bootstrap3/**"</span>);
        patterns.add(<span class="hljs-string">"/css/**"</span>);
        patterns.add(<span class="hljs-string">"/images/**"</span>);
        patterns.add(<span class="hljs-string">"/js/**"</span>);
        patterns.add(<span class="hljs-string">"/web/register.html"</span>);
        patterns.add(<span class="hljs-string">"/web/login.html"</span>);
        patterns.add(<span class="hljs-string">"/web/index.html"</span>);
        patterns.add(<span class="hljs-string">"/web/product.html"</span>);
        patterns.add(<span class="hljs-string">"/users/reg"</span>);
        patterns.add(<span class="hljs-string">"/users/login"</span>);

        <span class="hljs-comment">//registry.addInterceptor(interceptor);完成拦截</span>
        <span class="hljs-comment">// 器的注册,后面的addPathPatterns表示拦截哪些url</span>
        <span class="hljs-comment">//这里的参数/**表示所有请求,再后面的excludePathPatterns表</span>
        <span class="hljs-comment">// 示有哪些是白名单,且参数是列表</span>
        registry.addInterceptor(interceptor)
                .addPathPatterns(<span class="hljs-string">"/**"</span>)
                .excludePathPatterns(patterns);
    &#125;
&#125;
</code></pre>
<h2 id="修改密码"><a class="markdownIt-Anchor" href="#修改密码"></a> 修改密码</h2>
<p>初步分析：需要用户提交原始密码和新密码，再根据当前登录的用户进行信息的修改操作</p>
<h3 id="1修改密码-持久层"><a class="markdownIt-Anchor" href="#1修改密码-持久层"></a> 1.修改密码-持久层</h3>
<h4 id="11规划需要执行的sql语句"><a class="markdownIt-Anchor" href="#11规划需要执行的sql语句"></a> 1.1规划需要执行的SQL语句</h4>
<ul>
<li>
<p>根据用户的uid修改用户password值</p>
<pre class="highlight"><code class="sql"><span class="hljs-keyword">update</span> t_user <span class="hljs-keyword">set</span> <span class="hljs-keyword">password</span>=?,modified_user=?, modified_time=? <span class="hljs-keyword">WHERE</span> uid=?
</code></pre>
<p>modified_user=?, modified_time=?是为了跟踪用户数据的变动,如果这条数据被错误修改了可以找到第一责任人</p>
</li>
<li>
<p>在执行修改密码之前，还应检查用户数据是否存在或者用户数据是否被标记为&quot;已删除&quot;(比如登录账号后的几分钟在和朋友聊天,没有看页面,管理员错误删除了你的账号或者错误设置is_delete为1)、并检查原密码是否正确，这些检查都可以通过查询用户数据来辅助完成：</p>
<pre class="highlight"><code class="sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> uid=?
</code></pre>
</li>
</ul>
<h4 id="12设计接口和抽象方法"><a class="markdownIt-Anchor" href="#12设计接口和抽象方法"></a> 1.2设计接口和抽象方法</h4>
<blockquote>
<p>UserMapper接口,将以上的两个方法的抽象定义出来,将来映射到sql语句上</p>
</blockquote>
<pre class="highlight"><code class="java">    <span class="hljs-comment">/**
     * 根据用户的uid来修改用户密码
     * <span class="hljs-doctag">@param</span> uid 用户的id
     * <span class="hljs-doctag">@param</span> password 用户输入的新密码
     * <span class="hljs-doctag">@param</span> modifiedUser 表示修改的执行者
     * <span class="hljs-doctag">@param</span> modifiedTime 表示修改数据的时间
     * <span class="hljs-doctag">@return</span> 返回值为受影响的行数
     */</span>
    <span class="hljs-function">Integer <span class="hljs-title">updatePasswordByUid</span><span class="hljs-params">(Integer uid,
                                String password,
                                String modifiedUser,
                                Date modifiedTime)</span></span>;

    <span class="hljs-comment">/**
     * 根据用户的id查询用户的数据
     * <span class="hljs-doctag">@param</span> uid 用户的id
     * <span class="hljs-doctag">@return</span> 如果找到则返回对象,反之返回null值
     */</span>
    <span class="hljs-function">User <span class="hljs-title">findByUid</span><span class="hljs-params">(Integer uid)</span></span>;
</code></pre>
<h4 id="13编写映射"><a class="markdownIt-Anchor" href="#13编写映射"></a> 1.3编写映射</h4>
<blockquote>
<p>配置到映射文件UserMapper.xml中</p>
</blockquote>
<pre class="highlight"><code class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updatePasswordByUid"</span>&gt;</span>
        update t_user set
          `password`=#&#123;password&#125;,
          modified_user=#&#123;modifiedUser&#125;,
          modified_time=#&#123;modifiedTime&#125;,
        where uid=#&#123;uid&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findByUid"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"UserEntityMap"</span>&gt;</span>
        select * from t_user where uid=#&#123;uid&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
</code></pre>
<h4 id="14单元测试"><a class="markdownIt-Anchor" href="#14单元测试"></a> 1.4单元测试</h4>
<pre class="highlight"><code class="java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updatePasswordByUid</span><span class="hljs-params">()</span></span>&#123;
    userMapper.updatePasswordByUid(
        <span class="hljs-number">10</span>,
        <span class="hljs-string">"321"</span>,
        <span class="hljs-string">"管理员"</span>,
        <span class="hljs-keyword">new</span> Date());
&#125;

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findByUid</span><span class="hljs-params">()</span></span>&#123;
    System.out.println(userMapper.findByUid(<span class="hljs-number">10</span>));
&#125;
</code></pre>
<h3 id="2修改密码-业务层"><a class="markdownIt-Anchor" href="#2修改密码-业务层"></a> 2.修改密码-业务层</h3>
<h4 id="21规划异常-2"><a class="markdownIt-Anchor" href="#21规划异常-2"></a> 2.1规划异常</h4>
<ul>
<li>用户的原密码错误,抛PasswordNotMatchException异常(前面已创建)</li>
<li>检测到is_delete字段为1和uid找不到都是抛出用户没有找到的异常,UsernameNotFoundException(前面已创建)</li>
<li>update在更新的时候,有可能产生未知的异常,抛UpdateException异常</li>
</ul>
<pre class="highlight"><code class="java"><span class="hljs-comment">/**用户在更新数据时产生的未知异常*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdateException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceException</span></span>&#123;
    <span class="hljs-comment">/**重写ServiceException的所有构造方法*/</span>
&#125;
</code></pre>
<h4 id="22设计接口和抽象方法及实现-2"><a class="markdownIt-Anchor" href="#22设计接口和抽象方法及实现-2"></a> 2.2设计接口和抽象方法及实现</h4>
<p>1.执行用户修改密码的核心方法:</p>
<pre class="highlight"><code class="java">    <span class="hljs-comment">/**
     * changePassword方法需要什么参数:
     * 要先看底层持久层需要什么参数:uid,password,modifiedUser,modifiedTime
     * 1.修改人其实就是username,已经保存到session当中,通过控制层传递过来就行了
     * 2.在更新数据之前需要先根据uid查这个数据存不存在,uid也可以通过控制层传递
     * 3.新密码需要有
     * 4.修改时间不需要在参数列表,直接在方法内部new Date()就可以了
     * 5.旧密码
     * */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">changePassword</span><span class="hljs-params">(Integer uid,
                       String username,
                       String oldPassword,
                       String newPassword)</span></span>;
</code></pre>
<p>2.在实现类中实现当前的抽象方法</p>
<pre class="highlight"><code class="java">    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changePassword</span><span class="hljs-params">(Integer uid,
                              String username,
                              String oldPassword,
                              String newPassword)</span> </span>&#123;
        User result = userMapper.findByUid(uid);
        <span class="hljs-comment">/**
         * 用户没找到:比如登录账号后的几分钟在和朋友聊天,没
         * 有看页面,管理员错误删除了你的账号或者错误设置is_delete为1)
         */</span>
        <span class="hljs-keyword">if</span> (result ==<span class="hljs-keyword">null</span> || result.getIsDelete() == <span class="hljs-number">1</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"用户数据不存在"</span>);
        &#125;

        <span class="hljs-comment">//原始密码和数据库中密码进行比较</span>
        String oldMd5Password = getMD5Password(oldPassword,result.getSalt());
        <span class="hljs-keyword">if</span> (!result.getPassword().equals(oldMd5Password)) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PasswordNotMatchException(<span class="hljs-string">"密码错误"</span>);
        &#125;

        <span class="hljs-comment">//将新的密码加密后设置到数据库中(只要曾经注册过就用以前的盐值)</span>
        String newMd5Password = getMD5Password(newPassword, result.getSalt());
        Integer rows = userMapper.updatePasswordByUid(uid, newMd5Password, username, <span class="hljs-keyword">new</span> Date());

        <span class="hljs-keyword">if</span> (rows != <span class="hljs-number">1</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UpdateException(<span class="hljs-string">"更新数据产生未知的异常"</span>);
        &#125;
    &#125;
</code></pre>
<h4 id="23单元测试-2"><a class="markdownIt-Anchor" href="#23单元测试-2"></a> 2.3单元测试</h4>
<pre class="highlight"><code class="java">    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changePassword</span><span class="hljs-params">()</span> </span>&#123;
        userService.changePassword(<span class="hljs-number">11</span>,<span class="hljs-string">"管理员"</span>,<span class="hljs-string">"123"</span>,<span class="hljs-string">"321"</span>);
    &#125;
</code></pre>
<h3 id="3修改密码-控制层"><a class="markdownIt-Anchor" href="#3修改密码-控制层"></a> 3.修改密码-控制层</h3>
<h4 id="31处理异常-2"><a class="markdownIt-Anchor" href="#31处理异常-2"></a> 3.1处理异常</h4>
<p>UsernameNotFoundException异常和PasswordNotMatchException异常在前面的章节中已经处理过,现在只需要把UpdateException异常配置到统一的异常处理方法中</p>
<pre class="highlight"><code class="java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> UpdateException) &#123;
            result.setState(<span class="hljs-number">5001</span>);
            result.setMessage(<span class="hljs-string">"更新数据时产生未知的异常"</span>);
        &#125;
</code></pre>
<h4 id="32设计请求-2"><a class="markdownIt-Anchor" href="#32设计请求-2"></a> 3.2设计请求</h4>
<ul>
<li>/users/change_password</li>
<li>post</li>
<li>String oldPassword,String newPassword,HttpSession session(uid和username可以通过session获取到,在处理方法的内部获取就可以了)//如果参数名用的是非pojo类型,就需要和表单中的name属性值保持一致</li>
<li><code>JsonResult&lt;void&gt;</code></li>
</ul>
<h4 id="33处理请求-2"><a class="markdownIt-Anchor" href="#33处理请求-2"></a> 3.3处理请求</h4>
<pre class="highlight"><code class="java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"change_password"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> JsonResult&lt;Void&gt; <span class="hljs-title">changePassword</span><span class="hljs-params">(String oldPassword,
                                       String newPassword,
                                       HttpSession session)</span> </span>&#123;
    Integer uid = getUidFromSession(session);
    String username = getUsernameFromSession(session);
    userService.changePassword(uid,username,oldPassword,newPassword);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JsonResult&lt;&gt;(OK);
&#125;
</code></pre>
<p>启动服务,先登录账号然后在地址栏输入http://localhost:8080/users/change_password?oldPassword=321&amp;newPassword=123看看是否成功</p>
<h3 id="4修改密码-前端页面"><a class="markdownIt-Anchor" href="#4修改密码-前端页面"></a> 4.修改密码-前端页面</h3>
<p>在password.html中添加ajax请求的处理</p>
<pre class="highlight"><code class="js">        &lt;script&gt;
            $(<span class="hljs-string">"#btn-change-password"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
                $.ajax(&#123;
                    <span class="hljs-attr">url</span>: <span class="hljs-string">"/users/change_password"</span>,
                    <span class="hljs-attr">type</span>: <span class="hljs-string">"POST"</span>,
                    <span class="hljs-attr">data</span>: $(<span class="hljs-string">"#form-change-password"</span>).serialize(),
                    <span class="hljs-attr">dataType</span>: <span class="hljs-string">"JSON"</span>,
                    <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">json</span>) </span>&#123;
                        <span class="hljs-keyword">if</span> (json.state == <span class="hljs-number">200</span>) &#123;
                            alert(<span class="hljs-string">"密码修改成功"</span>)
                        &#125; <span class="hljs-keyword">else</span> &#123;
                            alert(<span class="hljs-string">"密码修改失败"</span>)
                        &#125;
                    &#125;,
                    <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) </span>&#123;
                        <span class="hljs-comment">//xhr.message可以获取未知异常的信息</span>
                        alert(<span class="hljs-string">"修改密码时产生未知的异常!"</span>+xhr.message);
                    &#125;
                &#125;);
            &#125;);
        &lt;<span class="hljs-regexp">/script&gt;
</span></code></pre>
<h2 id="个人资料"><a class="markdownIt-Anchor" href="#个人资料"></a> 个人资料</h2>
<p>其中用户名是不可修改的并且是在进个人资料页面时就从session获取值并将值加入到控件中</p>
<h3 id="1个人资料-持久层"><a class="markdownIt-Anchor" href="#1个人资料-持久层"></a> 1.个人资料-持久层</h3>
<h4 id="11规划sql语句"><a class="markdownIt-Anchor" href="#11规划sql语句"></a> 1.1规划SQL语句</h4>
<ul>
<li>
<p>获取用户信息的SQL语句</p>
<pre class="highlight"><code class="sql"><span class="hljs-keyword">update</span> t_user <span class="hljs-keyword">set</span> 
email=?,gender=?,modified_user=?,modified_time=?、
<span class="hljs-keyword">where</span> uid=?
</code></pre>
</li>
<li>
<p>根据uid查询用户数据</p>
<pre class="highlight"><code class="sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> uid=?
</code></pre>
<blockquote>
<p>根据uid查询用户数据不需要再重复开发</p>
</blockquote>
</li>
</ul>
<h4 id="12设计接口和抽象方法-2"><a class="markdownIt-Anchor" href="#12设计接口和抽象方法-2"></a> 1.2设计接口和抽象方法</h4>
<p>更新用户的信息方法的定义</p>
<pre class="highlight"><code class="java">    <span class="hljs-comment">/**
     * 参数为user的方法
     * <span class="hljs-doctag">@param</span> user 用户的数据
     * <span class="hljs-doctag">@return</span> 返回值为受影响的行数
     */</span>
    <span class="hljs-function">Integer <span class="hljs-title">updateInfoByUid</span><span class="hljs-params">(User user)</span></span>;<span class="hljs-comment">//也可以用三个String的形参接收电话,邮箱,性别,但不如直接写个user省事</span>
</code></pre>
<h4 id="13编写映射-2"><a class="markdownIt-Anchor" href="#13编写映射-2"></a> 1.3编写映射</h4>
<p>在UserMapper.xml文件中进行映射编写</p>
<pre class="highlight"><code class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateInfoByUid"</span>&gt;</span>
        update t_user
        set
            <span class="hljs-comment">&lt;!--if是条件判断标签,属性test接受的是一个返回值为boolean类型的条件,
            如果test条件的结果为true则执行if标签内部的语句,注意逗号也要在标签内--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"phone!=null"</span>&gt;</span>phone = #&#123;phone&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"email!=null"</span>&gt;</span>email = #&#123;email&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"gender!=null"</span>&gt;</span>gender = #&#123;gender&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
            modified_user = #&#123;modifiedUser&#125;,
            modified_time = #&#123;modifiedTime&#125;
        where uid=#&#123;uid&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>
</code></pre>
<h4 id="14单元测试-2"><a class="markdownIt-Anchor" href="#14单元测试-2"></a> 1.4单元测试</h4>
<pre class="highlight"><code class="">@Test
public void updateInfoByUid() &#123;
    User user = new User();
    user.setUid(11);
    user.setPhone(&quot;13333688&quot;);
    user.setEmail(&quot;1454@qq.com&quot;);
    user.setGender(1);
    userMapper.updateInfoByUid(user);
&#125;
</code></pre>
<h3 id="2个人资料-业务层"><a class="markdownIt-Anchor" href="#2个人资料-业务层"></a> 2.个人资料-业务层</h3>
<p>设计两个功能:</p>
<p>1.当打开页面时显示当前登录的用户的信息</p>
<p>2.点击修改按钮时更新用户的信息</p>
<h4 id="21规划异常-3"><a class="markdownIt-Anchor" href="#21规划异常-3"></a> 2.1规划异常</h4>
<ul>
<li>点击个人资料页面时可能找不到用户的数据</li>
<li>点击修改按钮时可能找不到用户数据,也可能修改时出现未知错误</li>
</ul>
<h4 id="22设计接口和抽象方法及实现-3"><a class="markdownIt-Anchor" href="#22设计接口和抽象方法及实现-3"></a> 2.2设计接口和抽象方法及实现</h4>
<p>1.业务层有两个功能模块,对应的是两个抽象方法的设计,并且这两个功能都涉及到用户是否存在的查询操作,所以需要在业务层设计根据用户uid查询数据的方法(持久层已经设计过该方法,但是没有在业务层实现该方法的调用)</p>
<pre class="highlight"><code class="java">    <span class="hljs-comment">/**
     * 根据用户的uid查询用户数据
     * <span class="hljs-doctag">@param</span> uid 用户uid
     * <span class="hljs-doctag">@return</span> 用户数据
     */</span>
    <span class="hljs-function">User <span class="hljs-title">getByUid</span><span class="hljs-params">(Integer uid)</span></span>;

    <span class="hljs-comment">/**
     * uid通过控制层在session中获取然后传递给业务层,并在业务层封装到User对象中
     * */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">changeInfo</span><span class="hljs-params">(Integer uid,User user)</span></span>;
</code></pre>
<p>2.在实现类中实现当前的抽象方法</p>
<pre class="highlight"><code class="java">    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getByUid</span><span class="hljs-params">(Integer uid)</span> </span>&#123;
        <span class="hljs-comment">//查询用户是否存在</span>
        User result = userMapper.findByUid(uid);
        <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span> || result.getIsDelete() == <span class="hljs-number">1</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"用户数据不存在"</span>);
        &#125;

        <span class="hljs-comment">//可以直接返回result给控制层,但是太臃肿了</span>
        User user = <span class="hljs-keyword">new</span> User();
        user.setUsername(result.getUsername());
        user.setPhone(result.getPhone());
        user.setEmail(result.getEmail());
        user.setGender(result.getGender());

        <span class="hljs-keyword">return</span> user;
    &#125;

    <span class="hljs-comment">/**
     *User对象中的数据只有phone,email,gender,username,因为springboot进行依赖
     * 注入的时候只注入表单中数据的值,所以需要手动将uid封装到user中
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeInfo</span><span class="hljs-params">(Integer uid, User user)</span> </span>&#123;
        User result = userMapper.findByUid(uid);
        <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span> || result.getIsDelete() == <span class="hljs-number">1</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"用户数据不存在"</span>);
        &#125;
        user.setUid(uid);
        user.setModifiedUser(user.getUsername());
        user.setModifiedTime(<span class="hljs-keyword">new</span> Date());

        Integer rows = userMapper.updateInfoByUid(user);
        <span class="hljs-keyword">if</span> (rows!=<span class="hljs-number">1</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UpdateException(<span class="hljs-string">"更新数据时产生异常"</span>);
        &#125;
    &#125;
</code></pre>
<h4 id="23单元测试-3"><a class="markdownIt-Anchor" href="#23单元测试-3"></a> 2.3单元测试</h4>
<pre class="highlight"><code class="java">    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getByUid</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//err是为了让输出信息为红色</span>
        System.err.println(userService.getByUid(<span class="hljs-number">11</span>).getUsername());
    &#125;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeInfo</span><span class="hljs-params">()</span> </span>&#123;
        User user = <span class="hljs-keyword">new</span> User();
        <span class="hljs-comment">//这四个属性值在真实开发中都是在控制层就已经自动封装在User对象中了</span>
        <span class="hljs-comment">//而uid需要由控制层传给业务层并在业务层封装到user中</span>
        user.setPhone(<span class="hljs-string">"123456789"</span>);
        user.setEmail(<span class="hljs-string">"123@qq.com"</span>);
        user.setUsername(<span class="hljs-string">"mxy"</span>);
        user.setGender(<span class="hljs-number">0</span>);
        userService.changeInfo(<span class="hljs-number">11</span>,user);
    &#125;
</code></pre>
<h3 id="3个人资料-控制层"><a class="markdownIt-Anchor" href="#3个人资料-控制层"></a> 3.个人资料-控制层</h3>
<h4 id="31处理异常-3"><a class="markdownIt-Anchor" href="#31处理异常-3"></a> 3.1处理异常</h4>
<p>没有新的异常,所以这里不需要有操作</p>
<h4 id="32设计请求-3"><a class="markdownIt-Anchor" href="#32设计请求-3"></a> 3.2设计请求</h4>
<p>1.设计一打开页面就发送当前用户数据的查询</p>
<ul>
<li>/users/get_by_uid</li>
<li>GET</li>
<li>HttpSession session(用于获取uid)</li>
<li>`JsonResult<User></li>
</ul>
<p>2.点击修改按钮发送用户的数据修改操作</p>
<ul>
<li>users/change_info</li>
<li>POST</li>
<li>User user,HttpSession session(用于获取uid)</li>
<li>`JsonResult<Void></li>
</ul>
<h4 id="33处理请求-3"><a class="markdownIt-Anchor" href="#33处理请求-3"></a> 3.3处理请求</h4>
<p>1.一打开页面就发送当前用户数据</p>
<pre class="highlight"><code class="java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"get_by_uid"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> JsonResult&lt;User&gt; <span class="hljs-title">getByUid</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;
    User data = userService.getByUid(getUidFromSession(session));
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JsonResult&lt;User&gt;(OK,data);
&#125;
</code></pre>
<p>启动服务,先登录账号然后在地址栏输入<br />
<a target="_blank" rel="noopener" href="http://localhost:8080/users/get_by_uid">http://localhost:8080/users/get_by_uid</a><br />
看看状态码是否为200并且看data值是否不为null</p>
<p>2.点击修改按钮更改用户数据</p>
<pre class="highlight"><code class="java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"change_info"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> JsonResult&lt;Void&gt; <span class="hljs-title">changeInfo</span><span class="hljs-params">(User user,HttpSession session)</span> </span>&#123;
    <span class="hljs-comment">//user对象中有四部分的数据:username,phone,email,gender</span>
    <span class="hljs-comment">//控制层给业务层传递uid,并在业务层通过user.setUid(uid);将uid封装到user中</span>
    Integer uid = getUidFromSession(session);
    userService.changeInfo(uid,user);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JsonResult&lt;&gt;(OK);
&#125;
</code></pre>
<p>启动服务,先登录账号然后在地址栏输入http://localhost:8080/users/change_info?phone=175726&amp;email=6695@qq.com&amp;username=张9&amp;gender=1观察状态码是否为200</p>
<h3 id="4个人资料-前端页面"><a class="markdownIt-Anchor" href="#4个人资料-前端页面"></a> 4.个人资料-前端页面</h3>
<p>1.在打开userdata.html(个人资料)页面自动发送ajax请求(get_by_uid),查询到的数据填充到这个页面</p>
<pre class="highlight"><code class="java">        &lt;script&gt;
            <span class="hljs-comment">/**
             * 一旦检测到当前的页面被加载就会触发ready方法
             * $(document).ready(function()&#123;
             *     //编写业务代码
             * &#125;);
             */</span>
            <span class="hljs-comment">//点击"个人资料"四个字加载userdata.html页面时$(document).ready(function()&#123;&#125;);就会起作用发送ajax请求</span>
            $(document).ready(function() &#123;
                $.ajax(&#123;
                    url: <span class="hljs-string">"/users/get_by_uid"</span>,
                    type: <span class="hljs-string">"GET"</span>,
                    <span class="hljs-comment">//data为null也可以,因为这里get是从数据库拉取数据,不需要data</span>
                    data: $(<span class="hljs-string">"#form-change-info"</span>).serialize(),
                    dataType: <span class="hljs-string">"JSON"</span>,
                    success: function (json) &#123;
                        <span class="hljs-keyword">if</span> (json.state == <span class="hljs-number">200</span>) &#123;
                            <span class="hljs-comment">//将查询到的数据设置到控件中</span>
                            $(<span class="hljs-string">"#username"</span>).val(json.data.username);
                            $(<span class="hljs-string">"#phone"</span>).val(json.data.phone);
                            $(<span class="hljs-string">"#email"</span>).val(json.data.email);
                            <span class="hljs-keyword">var</span> radio = json.data.gender == <span class="hljs-number">0</span> ?
                                $(<span class="hljs-string">"#gender-female"</span>) : $(<span class="hljs-string">"#gender-male"</span>);
                            <span class="hljs-comment">//prop()表示给某个元素添加属性及属性的值</span>
                            radio.prop(<span class="hljs-string">"checked"</span>,<span class="hljs-string">"checked"</span>);
                        &#125; <span class="hljs-keyword">else</span> &#123;
                            alert(<span class="hljs-string">"用户的数据不存在"</span>)
                        &#125;
                    &#125;,
                    error: function (xhr) &#123;
                        <span class="hljs-comment">//xhr.message可以获取未知异常的信息</span>
                        alert(<span class="hljs-string">"查询用户信息时产生未知的异常!"</span>+xhr.message);
                    &#125;
                &#125;);
            &#125;);
        &lt;/script&gt;
</code></pre>
<p>2.在检测到用户点击了修改按钮后发送一个ajax请求(change_info)</p>
<p>该ajax函数需要和上一个ajax同级</p>
<pre class="highlight"><code class="js">            $(<span class="hljs-string">"#btn-change-info"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
                $.ajax(&#123;
                    <span class="hljs-attr">url</span>: <span class="hljs-string">"/users/change_info"</span>,
                    <span class="hljs-attr">type</span>: <span class="hljs-string">"POST"</span>,
                    <span class="hljs-attr">data</span>: $(<span class="hljs-string">"#form-change-info"</span>).serialize(),
                    <span class="hljs-attr">dataType</span>: <span class="hljs-string">"JSON"</span>,
                    <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">json</span>) </span>&#123;
                        <span class="hljs-keyword">if</span> (json.state == <span class="hljs-number">200</span>) &#123;
                            alert(<span class="hljs-string">"用户信息修改成功"</span>)
                            <span class="hljs-comment">//修改成功后重新加载当前的页面</span>
                            location.href = <span class="hljs-string">"userdata.html"</span>;
                        &#125; <span class="hljs-keyword">else</span> &#123;
                            alert(<span class="hljs-string">"用户信息修改失败"</span>)
                        &#125;
                    &#125;,
                    <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) </span>&#123;
                        <span class="hljs-comment">//xhr.message可以获取未知异常的信息</span>
                        alert(<span class="hljs-string">"用户信息修改时产生未知的异常!"</span>+xhr.message);
                    &#125;
                &#125;);
            &#125;);
</code></pre>
<h2 id="上传头像"><a class="markdownIt-Anchor" href="#上传头像"></a> 上传头像</h2>
<p>错误方法:把文件存到数据库中,需要图片时访问数据库,数据库将文件解析为字节流返回,最后写到本地的某一个文件.这种方法太耗费资源和时间了</p>
<p>正确方法:将对应的文件保存在操作系统上,然后再把这个文件路径记录下来,因为在记录路径的时候是非常便捷和方便的,将来如果要打开这个文件可以依据这个路径找到这个文件,所以说在数据库中保存该文件的路径即可.</p>
<p>稍微大一点的公司都会将所有的静态资源(图片,文件,其他资源文件)放到某台电脑上,再把这台电脑作为一台单独的服务器使用</p>
<h3 id="1上传头像-持久层"><a class="markdownIt-Anchor" href="#1上传头像-持久层"></a> 1.上传头像-持久层</h3>
<h4 id="11sql语句的规划"><a class="markdownIt-Anchor" href="#11sql语句的规划"></a> 1.1SQL语句的规划</h4>
<p>更新用户avatar字段的sql语句</p>
<pre class="highlight"><code class="sql"><span class="hljs-keyword">update</span> t_user 
<span class="hljs-keyword">set</span> avatar=?,modified_user=?,modified_time=? 
<span class="hljs-keyword">where</span> uid=?
</code></pre>
<h4 id="12设计接口和抽象方法-3"><a class="markdownIt-Anchor" href="#12设计接口和抽象方法-3"></a> 1.2设计接口和抽象方法</h4>
<p>在UserMapper接口中定义一个抽象方法用于修改用户的头像</p>
<pre class="highlight"><code class="java">    <span class="hljs-comment">/**
     * 根据用户uid修改用户的头像
     * <span class="hljs-doctag">@param</span> iddddd
     * <span class="hljs-doctag">@param</span> avatar
     * <span class="hljs-doctag">@param</span> modifiedUser
     * <span class="hljs-doctag">@param</span> modifiedTime
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-comment">/**
     * 注解<span class="hljs-doctag">@Param</span>("SQL映射文件中#&#123;&#125;占位符的变量名"),解决的问题:
     * 当SQL语句的占位符和映射的接口方法参数名不一致时,需要将某个参数强行注入到某个
     * 占位符变量上时,可以使用<span class="hljs-doctag">@Param</span>这个注解来标注映射的关系
     * */</span>
    <span class="hljs-function">Integer <span class="hljs-title">updateAvatarByUid</span><span class="hljs-params">(@Param(<span class="hljs-string">"uid"</span>)</span>Integer iddddd,<span class="hljs-comment">//@Param("参数名")注解中的参数名需要和sql语句中</span>
                              <span class="hljs-comment">//的#&#123;参数名&#125;的参数名保持一致.该处表示iddddd中的变量值要注入到sql语句的uid中</span>
                String avatar,
                String modifiedUser,
                Date modifiedTime)</span>; 


</code></pre>
<p>@Parm()相同可以省略，不同可以匹配<br />
比如==@Parm(“uid”) String uid<mark>可以省略<br />
但是如果</mark>@Parm(“uid”) String userId==那么可以将userId参数注入到#{uid}中</p>
<p>当sql语句的占位符和映射接口方法中的参数名不一致的时候，需要将某个参数强行注入到某个占位符，那么可以使用@Parm()注解来指定接口参数和占位符参数名的映射关系</p>
<p>@Parm(“SQl映射文件中#{}占位符中的变量名”)</p>
<h4 id="13编写映射-3"><a class="markdownIt-Anchor" href="#13编写映射-3"></a> 1.3编写映射</h4>
<p>UserMapper.xml文件中编写映射的SQL语句</p>
<pre class="highlight"><code class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateAvatarByUid"</span>&gt;</span>
        update t_user
        set
            avatar = #&#123;avatar&#125;,
            modified_user = #&#123;modifiedUser&#125;,
            modified_time = #&#123;modifiedTime&#125;//要和对象属性名一致
        where
            uid = #&#123;uid&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>
</code></pre>
<h4 id="14单元测试-3"><a class="markdownIt-Anchor" href="#14单元测试-3"></a> 1.4单元测试</h4>
<pre class="highlight"><code class="java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAvatarByUid</span><span class="hljs-params">()</span> </span>&#123;
    userMapper.updateAvatarByUid(
        <span class="hljs-number">11</span>,
        <span class="hljs-string">"abc"</span>,
        <span class="hljs-string">"mxy"</span>,
        <span class="hljs-keyword">new</span> Date());
&#125;
</code></pre>
<h3 id="2上传头像-业务层"><a class="markdownIt-Anchor" href="#2上传头像-业务层"></a> 2.上传头像-业务层</h3>
<h4 id="21规划异常-4"><a class="markdownIt-Anchor" href="#21规划异常-4"></a> 2.1规划异常</h4>
<ul>
<li>用户数据不存在,找不到对应的用户数据</li>
<li>更新的时候,出现未知异常</li>
</ul>
<blockquote>
<p>无需重复开发</p>
</blockquote>
<h4 id="22设计接口和抽象方法及实现-4"><a class="markdownIt-Anchor" href="#22设计接口和抽象方法及实现-4"></a> 2.2设计接口和抽象方法及实现</h4>
<p>1.先分析一下业务层接口需要哪些参数:那就需要看持久层接口要的有什么参数:</p>
<p>uid,avatar,modifiedUser,modifiedTime,其中modifiedTime是在方法中创建的,uid和modifiedUser从session中获取,但是session对象是在控制层的并不会出现在业务层,所以业务层要保留这两个参数,以便控制层可以传递过来</p>
<pre class="highlight"><code class="java">    <span class="hljs-comment">/**
     * 修改用户的头像
     * <span class="hljs-doctag">@param</span> uid 用户uid
     * <span class="hljs-doctag">@param</span> avatar 用户头像的路径
     * <span class="hljs-doctag">@param</span> username 用户名称
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">changeAvatar</span><span class="hljs-params">(Integer uid,
                      String avatar,
                      String username)</span></span>;<span class="hljs-comment">//业务层一般叫username而不叫modifiedUser,因为业务层并没有直接和数据库关联</span>
                                    
</code></pre>
<p>2.编写业务层的更新用户头像的方法</p>
<pre class="highlight"><code class="java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeAvatar</span><span class="hljs-params">(Integer uid, String avatar, String username)</span> </span>&#123;
    <span class="hljs-comment">//查询当前的用户数据是否存在</span>
    User result = userMapper.findByUid(uid);
    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span> || result.getIsDelete() == <span class="hljs-number">1</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"用户数据不存在"</span>);
    &#125;
    Integer rows = userMapper.updateAvatarByUid(uid, avatar, username, <span class="hljs-keyword">new</span> Date());
    <span class="hljs-keyword">if</span> (rows!=<span class="hljs-number">1</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UpdateException(<span class="hljs-string">"更新用户头像时产生未知异常"</span>);
    &#125;
&#125;
</code></pre>
<h4 id="23单元测试-4"><a class="markdownIt-Anchor" href="#23单元测试-4"></a> 2.3单元测试</h4>
<pre class="highlight"><code class="java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeAvatar</span><span class="hljs-params">()</span> </span>&#123;
    userService.changeAvatar(<span class="hljs-number">11</span>,<span class="hljs-string">"222"</span>,<span class="hljs-string">"mmm"</span>);
&#125;
</code></pre>
<h3 id="3上传头像-控制层"><a class="markdownIt-Anchor" href="#3上传头像-控制层"></a> 3.上传头像-控制层</h3>
<p><em>文件上传过程中产生的异常太多了,再比如文件类型不匹配或文件被损坏</em></p>
<h4 id="31规划异常"><a class="markdownIt-Anchor" href="#31规划异常"></a> 3.1规划异常</h4>
<blockquote>
<p>客户端传递文件给服务器,服务器的控制端controller接收文件,接收时可能抛出异常,因为用户传过来的文件有可能超出了我们的大小限制</p>
<p>该异常能放在业务层抛出吗?没必要的,因为此时数据是从控制层往下传的,所以控制层产生的异常直接在这一层(控制层)抛就可以了</p>
</blockquote>
<p>上传文件时的异常都是文件异常,所以可以先创建一个文件异常类的基类<code>FileUploadException</code>并使其继承<code>RuntimeException</code></p>
<p>文件异常基类的子类有:</p>
<ul>
<li>FileEmptyException:文件为空的异常(没有选择上传的文件就提交了表单,或选择的文件是0字节的空文件)</li>
<li>FileSizeException:文件大小超出限制</li>
<li>FileTypeException:文件类型异常(上传的文件类型超出了限制)</li>
<li>FileUploadIOException:文件读写异常</li>
<li>FileStateException:文件状态异常(上传文件时该文件正在打开状态)</li>
</ul>
<p>在controller包下创子包ex,在ex包里面创建文件异常类的基类和上述五个文件异常类,创建的六个类都重写其父类的五个构造方法</p>
<h4 id="32处理异常"><a class="markdownIt-Anchor" href="#32处理异常"></a> 3.2处理异常</h4>
<p>在基类BaseController中进行编写和统一处理</p>
<pre class="highlight"><code class="java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> FileEmptyException) &#123;
    result.setState(<span class="hljs-number">6000</span>);
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> FileSizeException) &#123;
    result.setState(<span class="hljs-number">6001</span>);
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> FileTypeException) &#123;
    result.setState(<span class="hljs-number">6002</span>);
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> FileStateException) &#123;
    result.setState(<span class="hljs-number">6003</span>);
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> FileUploadIOException) &#123;
    result.setState(<span class="hljs-number">6004</span>);
&#125;
</code></pre>
<p>异常统一处理方法的修饰符<br />
@ExceptionHandler(ServiceException.class)表明我们现在创建的FileUploadException异常类不会被拦截到该方法中,<br />
点进@ExceptionHandler注解可以发现传参可以传数组类型,<br />
所以可以将异常统一处理方法上的注解改为:</p>
<p><mark>@ExceptionHandler({ServiceException.class,FileUploadException.class})</mark></p>
<h4 id="33设计请求"><a class="markdownIt-Anchor" href="#33设计请求"></a> 3.3设计请求</h4>
<ul>
<li>/users/change_avatar</li>
<li>POST(GET请求提交数据只有2KB左右)</li>
<li>HttpSession session(获取uid和username),MultipartFile file</li>
<li><code>JsonResult&lt;String&gt;</code><br />
(不能是<code>JsonResult&lt;Void&gt;</code>:如果上传头像后浏览别的页面,然后再回到上传头像的页面就展示不出来了,所以图片一旦上传成功,就要保存该图片在服务器的哪个位置,这样的话一旦检测到进入上传头像的页面就可以通过保存的路径拿到图片,最后展示在页面上)</li>
</ul>
<h4 id="34处理请求"><a class="markdownIt-Anchor" href="#34处理请求"></a> 3.4处理请求</h4>
<pre class="highlight"><code class="java">
<span class="hljs-comment">/**  
* 设置上传文件最大值 10M  
*/</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> AVATAR_MAX_SIZE = <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;  

<span class="hljs-comment">/**  
* 设置上传文件类型  
*/</span>  
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; AVATAR_TYPE = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  
<span class="hljs-keyword">static</span>&#123;  
AVATAR_TYPE.add(<span class="hljs-string">"images/jpeg"</span>);  
AVATAR_TYPE.add(<span class="hljs-string">"images/png"</span>);  
AVATAR_TYPE.add(<span class="hljs-string">"images/bmp"</span>);  
AVATAR_TYPE.add(<span class="hljs-string">"images/gif"</span>);  
&#125;

<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"change_avatar"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> JsonResult&lt;String&gt; <span class="hljs-title">changeAvatar</span><span class="hljs-params">(HttpSession session,
									   MultipartFile file)</span> </span>&#123;
	<span class="hljs-comment">/**
	 * 1.参数名为什么必须用file:在upload.html页面的147行&lt;input type=
	 * "file" name="file"&gt;中的name="file",所以必须有一个方法的参数名
	 * 为file用于接收前端传递的该文件.如果想要参数名和前端的name不一
	 * 样:<span class="hljs-doctag">@RequestParam</span>("file")MultipartFile ffff:把表单中name=
	 * "file"的控件值传递到变量ffff上
	 * 2.参数类型为什么必须是MultipartFile:这是springmvc中封装的一个
	 * 包装接口,如果类型是MultipartFile并且参数名和前端上传文件的name
	 * 相同,则会自动把整体的数据包传递给file
	 */</span>
	<span class="hljs-comment">//判断文件是否为null</span>
	<span class="hljs-keyword">if</span> (file.isEmpty()) &#123;
		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileEmptyException(<span class="hljs-string">"文件为空"</span>);
	&#125;
	<span class="hljs-keyword">if</span> (file.getSize()&gt;AVATAR_MAX_SIZE) &#123;
		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileSizeException(<span class="hljs-string">"文件超出限制"</span>);
	&#125;
	<span class="hljs-comment">//判断文件的类型是否是我们规定的后缀类型</span>
	String contentType = file.getContentType();
	<span class="hljs-comment">//如果集合包含某个元素则返回值为true</span>
	<span class="hljs-keyword">if</span> (!AVATAR_TYPE.contains(contentType)) &#123;
		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileTypeException(<span class="hljs-string">"文件类型不支持"</span>);
	&#125;

	<span class="hljs-comment">//上传的文件路径:.../upload/文件名.png</span>
	<span class="hljs-comment">/**
	 * session.getServletContext()获取当前Web应用程序的上下文
	 * 对象(每次启动tomcat都会创建一个新的上下文对象)
	 * getRealPath("/upload")的/代表当前web应用程序的根目录,通过该相
	 * 对路径获取绝对路径,返回一个路径字符串,如果不能进行映射返回null,单
	 * 斜杠可要可不要
	 */</span>
	String parent =
			session.getServletContext().getRealPath(<span class="hljs-string">"/upload"</span>);
	System.out.println(parent);<span class="hljs-comment">//调试用</span>

	<span class="hljs-comment">//File对象指向这个路径,通过判断File是否存在得到该路径是否存在</span>
	File dir = <span class="hljs-keyword">new</span> File(parent);
	<span class="hljs-keyword">if</span> (!dir.exists()) &#123;<span class="hljs-comment">//检测目录是否存在</span>
		dir.mkdirs();<span class="hljs-comment">//创建当前目录</span>
	&#125;

	<span class="hljs-comment">//获取这个文件名称(文件名+后缀,如avatar01.png,不包含父目录结构)用UUID</span>
	<span class="hljs-comment">// 工具生成一个新的字符串作为文件名(好处:避免了因文件名重复发生的覆盖)</span>
	String originalFilename = file.getOriginalFilename();
	System.out.println(<span class="hljs-string">"OriginalFilename="</span>+originalFilename);
	<span class="hljs-keyword">int</span> index = originalFilename.lastIndexOf(<span class="hljs-string">"."</span>);
	String suffix = originalFilename.substring(index);
	<span class="hljs-comment">//filename形如SAFS1-56JHIOHI-HIUGHUI-5565TYRF.png</span>
	String filename =
			UUID.randomUUID().toString().toUpperCase()+suffix;

	<span class="hljs-comment">//在dir目录下创建filename文件(此时是空文件)</span>
	File dest = <span class="hljs-keyword">new</span> File(dir, filename);

	<span class="hljs-comment">//java可以把一个文件的数据直接写到同类型的文件中,这里将参数file中的数据写入到空文件dest中</span>
	<span class="hljs-keyword">try</span> &#123;
		file.transferTo(dest);<span class="hljs-comment">//transferTo是一个封装的方法,用来将file文件中的数据写入到dest文件</span>

		<span class="hljs-comment">/**
		 * 先捕获FileStateException再捕获IOException是
		 * 因为后者包含前者,如果先捕获IOException那么
		 * FileStateException就永远不可能会被捕获
		 */</span>
	&#125; <span class="hljs-keyword">catch</span> (FileStateException e) &#123;
		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileStateException(<span class="hljs-string">"文件状态异常"</span>);
	&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
		<span class="hljs-comment">//这里不用打印e,而是用自己写的FileUploadIOException类并</span>
		<span class="hljs-comment">// 抛出文件读写异常</span>
		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileUploadIOException(<span class="hljs-string">"文件读写异常"</span>);
	&#125;

	Integer uid = getUidFromSession(session);
	String username = getUsernameFromSession(session);
	String avatar = <span class="hljs-string">"/upload/"</span>+filename;
	userService.changeAvatar(uid,avatar,username);
	<span class="hljs-comment">//返回用户头像的路径给前端页面,将来用于头像展示使用</span>
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JsonResult&lt;&gt;(OK,avatar);
&#125;
</code></pre>
<h3 id="4上传头像-前端页面"><a class="markdownIt-Anchor" href="#4上传头像-前端页面"></a> 4.上传头像-前端页面</h3>
<p>1.在upload.html的上传头像的表单加上三个属性:</p>
<ul>
<li>action=“/users/change_avatar”</li>
<li>method=“post”(get请求提交数据只有2KB左右)</li>
<li>enctype=“multipart/form-data”(如果直接使用表单进行文件的上传,需要给表单加该属性,这样不会将目标文件的数据结构做修改后再上传,这不同于字符串,字符串随意切割修改也能拼在一起,但文件不行)</li>
</ul>
<p>2.确认 <code>&lt;input type=“file” name=“file”&gt;</code><br />
的type和name以及<br />
<code>&lt;input type=“submit” class=“btn btn-primary” value=“上传” /&gt;</code>中的type</p>
<h3 id="5前端页面优化修复bug"><a class="markdownIt-Anchor" href="#5前端页面优化修复bug"></a> 5.前端页面优化——修复bug</h3>
<h4 id="51更改默认的大小限制"><a class="markdownIt-Anchor" href="#51更改默认的大小限制"></a> 5.1更改默认的大小限制</h4>
<p>springmvc默认为1MB文件可以进行上传,如果刚好是<br />
1024 * 1024=1048576 bytes则会报代码错误,<br />
自己在控制层设置的public static final int AVATAR_MAX_SIZE = 10 * 1024 * 1024; 需要在不超过原有大小的情况下才会起作用,所以要手动修改springmvc默认上传文件的大小</p>
<p>方式1:直接在配置文件application.properties中进行配置:</p>
<ul>
<li>spring.servlet.multipart.max-file-size=10MB(表示上传的文件最大是多大)</li>
<li>spring.servlet.multipart.max-request-size=15MB(整个文件是放在了request中发送给服务器的,请求当中还会有消息头等其他携带的信息,这里设置请求最大为15MB)</li>
</ul>
<p>方式2:采用java代码的形式来设置文件的上传大小的限制:</p>
<p>1.该代码必须在主类中进行配置,因为主类是最早加载的,而配置文件必须是最早加载的</p>
<p>2.在主类中定义一个方法,方法名无所谓,但方法需要用@bean修饰,表示该方法返回值是一个bean对象,并且该bean对象被bean修饰,也就是这个方法返回了一个对象,然后把该对象交给bean管理,类似spring中的bean标签,含义是一样的,只是这里改为了注解</p>
<p>3.用@Configuration修饰主类使@bean注解生效,但其实@SpringBootApplication是@SpringBootConfiguration,@EnableAutoConfiguration,@ComponentScan三个注解的合并,所以可以不需要@Configuration</p>
<p>4.方法返回值是MultipartConfigElement类型,表示所要配置的目标的元素</p>
<pre class="highlight"><code class="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> MultipartConfigElement <span class="hljs-title">getMultipartConfigElement</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">//1.创建一个配置的工厂类对象</span>
    MultipartConfigFactory factory = <span class="hljs-keyword">new</span> MultipartConfigFactory();

    <span class="hljs-comment">//2.设置需要创建的对象的相关信息</span>
    factory.setMaxFileSize(DataSize.of(<span class="hljs-number">10</span>, DataUnit.MEGABYTES));
    factory.setMaxRequestSize(DataSize.of(<span class="hljs-number">15</span>,DataUnit.MEGABYTES));

    <span class="hljs-comment">//3.通过工厂类创建MultipartConfigElement对象</span>
    <span class="hljs-keyword">return</span> factory.createMultipartConfig();
&#125;
</code></pre>
<h4 id="52上传后显示头像"><a class="markdownIt-Anchor" href="#52上传后显示头像"></a> 5.2上传后显示头像</h4>
<p>上传头像成功后不能显示头像.</p>
<p>在页面中通过ajax请求来提交文件,提交完成后返回了json串,解析出json串中的data数据设置到img标签的src属性上</p>
<p>1.删掉在upload.html的上传头像的表单中加的三个属性:<br />
action=“/users/change_avatar”,<br />
method=“post”,<br />
enctype=“multipart/form-data”.<br />
加上id属性:id=“form-change-avatar”</p>
<p>2.把153行的input标签里面的type=&quot;submit&quot;改为type=“button”(因为submit按钮不能添加事件,所以要改为普通的按钮)并加上属性id=“btn-change-avatar”</p>
<blockquote>
<p>1.serialize():可以将表单数据自动拼接成key=value的结构提交给服务器,一般提交的是普通的控件类型中的数据(type=text/password/radio/checkbox等等)</p>
</blockquote>
<blockquote>
<p>2.FormData类:将表单中数据保持原有的结构进行数据提交.文件类型的数据可以使用FormData对象进行存储</p>
<p>使用方法:new FormData($(“form”)[0]);</p>
<p>这行代码的含义是将id=&quot;form&quot;的表单的第一个元素的整体值作为创建FormData对象的数据</p>
</blockquote>
<blockquote>
<p>3.虽然我们把文件的数据保护下来了,但是ajax默认处理数据时按照字符串的形式进行处理,以及默认会采用字符串的形式进行数据提交.手动关闭这两个功能:</p>
<ul>
<li>processData: false,//处理数据的形式,关闭处理数据</li>
<li>contentType: false,//提交数据的形式,关闭默认提交数据的形式</li>
</ul>
</blockquote>
<p>下面给提交表单加上事件:</p>
<pre class="highlight"><code class="js">        &lt;script&gt;
            $(<span class="hljs-string">"#btn-change-avatar"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
                $.ajax(&#123;
                    <span class="hljs-attr">url</span>: <span class="hljs-string">"/users/change_avatar"</span>,
                    <span class="hljs-attr">type</span>: <span class="hljs-string">"POST"</span>,
                    <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> FormData($(<span class="hljs-string">"#form-change-avatar"</span>)[<span class="hljs-number">0</span>]),
                    <span class="hljs-attr">processData</span>: <span class="hljs-literal">false</span>,<span class="hljs-comment">//处理数据的形式,关闭处理数据</span>
                    <span class="hljs-attr">contentType</span>: <span class="hljs-literal">false</span>,<span class="hljs-comment">//提交数据的形式,关闭默认提交数据的形式</span>
                    <span class="hljs-attr">dataType</span>: <span class="hljs-string">"JSON"</span>,
                    <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">json</span>) </span>&#123;
                        <span class="hljs-keyword">if</span> (json.state == <span class="hljs-number">200</span>) &#123;
                            alert(<span class="hljs-string">"头像修改成功"</span>)
                            <span class="hljs-comment">//将服务器端返回的头像地址设置到img标签的src属性上</span>
                            <span class="hljs-comment">//attr(属性,属性值)用来给某个属性设值</span>
                            $(<span class="hljs-string">"#img-avatar"</span>).attr(<span class="hljs-string">"src"</span>,json.data);
                        &#125; <span class="hljs-keyword">else</span> &#123;
                            alert(<span class="hljs-string">"头像修改失败"</span>)
                        &#125;
                    &#125;,
                    <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) </span>&#123;
                        alert(<span class="hljs-string">"修改头像时产生未知的异常!"</span>+xhr.message);
                    &#125;
                &#125;);
            &#125;);
        &lt;<span class="hljs-regexp">/script&gt;
</span></code></pre>
<h4 id="53登录后显示头像"><a class="markdownIt-Anchor" href="#53登录后显示头像"></a> 5.3登录后显示头像</h4>
<p>将头像上传后会显示头像,但是关闭浏览器后再进入个人头像页面就不会显示头像了,因为只有点击&quot;上传&quot;才能发送ajax请求并显示头像.</p>
<p>可以在每次用户登录成功后将avatar保存在cookie中,登录的业务层返回给控制层user对象,该对象包含uid,username,avatar.所以要在登录页面login.html中将服务器返回的头像路径设置到cookie中,然后每次检测到用户打开上传头像页面,在这个页面中通过ready()方法来自动读取cookie中头像路径并设到src属性上</p>
<p>1.需要在login.html页面头部导入cookie.js文件</p>
<pre class="highlight"><code class="js">&lt;script src=<span class="hljs-string">"../bootstrap3/js/jquery.cookie.js"</span> type=<span class="hljs-string">"text/javascript"</span> charset=<span class="hljs-string">"utf-8"</span>&gt;&lt;<span class="hljs-regexp">/script&gt;
</span></code></pre>
<p>2.调用cookie方法保存路径</p>
<pre class="highlight"><code class="js">$.cookie(key,value,time);<span class="hljs-comment">//time单位:天</span>
</code></pre>
<p>在ajax请求原有的代码上加$.cookie(“avatar”,json.data.avatar,{expires: 7});</p>
<pre class="highlight"><code class="js">success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">json</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (json.state == <span class="hljs-number">200</span>) &#123;
        location.href = <span class="hljs-string">"index.html"</span>;
        $.cookie(<span class="hljs-string">"avatar"</span>,json.data.avatar,&#123;<span class="hljs-attr">expires</span>: <span class="hljs-number">7</span>&#125;);
    &#125; <span class="hljs-keyword">else</span> &#123;
        alert(<span class="hljs-string">"登录失败"</span>)
    &#125;
&#125;,
</code></pre>
<p>3.需要在upload.html获取cookie中的值,所以要在页面头部导入cookie.js文件</p>
<pre class="highlight"><code class="js">&lt;script src=<span class="hljs-string">"../bootstrap3/js/jquery.cookie.js"</span> type=<span class="hljs-string">"text/javascript"</span> charset=<span class="hljs-string">"utf-8"</span>&gt;&lt;<span class="hljs-regexp">/script&gt;
</span></code></pre>
<p>4.在upload.html的script标签中加ready()自动读取cookie数据</p>
<pre class="highlight"><code class="js">$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> avatar = $.cookie(<span class="hljs-string">"avatar"</span>);
    <span class="hljs-built_in">console</span>.log(avatar);<span class="hljs-comment">//调试用</span>
    $(<span class="hljs-string">"#img-avatar"</span>).attr(<span class="hljs-string">"src"</span>,avatar);
&#125;)
</code></pre>
<h4 id="54显示最新头像"><a class="markdownIt-Anchor" href="#54显示最新头像"></a> 5.4显示最新头像</h4>
<p>上传头像后不重新登录而是浏览其他页面,然后再进入个人头像页面时展示的头像是上次上传的,因为此时cookie中的值是上次上传的头像的路径,所以需要上传头像后使用同名覆盖更改cookie中路径</p>
<p>在ajax函数的success属性值的if语句加:</p>
<pre class="highlight"><code class="js">$.cookie(<span class="hljs-string">"avatar"</span>,json.data,&#123;<span class="hljs-attr">expires</span>: <span class="hljs-number">7</span>&#125;);
</code></pre>
<p>完善后重启服务测试,结果若和预测的不一样,则参考项目环境搭建-&gt;项目测试-&gt;测试静态资源能否正常加载里面的四种解决方法</p>
<h2 id="新增收货地址"><a class="markdownIt-Anchor" href="#新增收货地址"></a> 新增收货地址</h2>
<h3 id="1创建数据表-2"><a class="markdownIt-Anchor" href="#1创建数据表-2"></a> 1.创建数据表</h3>
<p>1.选中数据表</p>
<pre class="highlight"><code class="">use store
</code></pre>
<p>2.在store数据库中创建t_address表</p>
<pre class="highlight"><code class="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_address (
aid <span class="hljs-built_in">INT</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'收货地址id'</span>,
uid <span class="hljs-built_in">INT</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'归属的用户id'</span>,
<span class="hljs-string">`name`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'收货人姓名'</span>,
province_name <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">15</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'省-名称'</span>,
province_code <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'省-行政代号'</span>,
city_name <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">15</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'市-名称'</span>,
city_code <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'市-行政代号'</span>,
area_name <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">15</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'区-名称'</span>,
area_code <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'区-行政代号'</span>,
zip <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'邮政编码'</span>,
address <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'详细地址'</span>,
phone <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'手机'</span>,
tel <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'固话'</span>,
tag <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'标签'</span>,
is_default <span class="hljs-built_in">INT</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'是否默认：0-不默认，1-默认'</span>,
created_user <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'创建人'</span>,
created_time DATETIME <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'创建时间'</span>,
modified_user <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'修改人'</span>,
modified_time DATETIME <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'修改时间'</span>,
PRIMARY <span class="hljs-keyword">KEY</span> (aid)
) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;
</code></pre>
<p>注意name是关键字,所以需要用``</p>
<h3 id="2创建收货地址的实体类"><a class="markdownIt-Anchor" href="#2创建收货地址的实体类"></a> 2.创建收货地址的实体类</h3>
<p>在entity包下创建实体类Address继承BaseEntity类</p>
<pre class="highlight"><code class="java"><span class="hljs-comment">/**收货地址额实体类*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseEntity</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer aid;
    <span class="hljs-keyword">private</span> Integer uid;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String provinceName;
    <span class="hljs-keyword">private</span> String provinceCode;
    <span class="hljs-keyword">private</span> String cityName;
    <span class="hljs-keyword">private</span> String cityCode;
    <span class="hljs-keyword">private</span> String areaName;
    <span class="hljs-keyword">private</span> String areaCode;
    <span class="hljs-keyword">private</span> String zip;
    <span class="hljs-keyword">private</span> String address;
    <span class="hljs-keyword">private</span> String phone;
    <span class="hljs-keyword">private</span> String tel;
    <span class="hljs-keyword">private</span> String tag;
    <span class="hljs-keyword">private</span> Integer isDefault;
 <span class="hljs-comment">/**
 * get,set
 * equals和hashCode
 * toString
 */</span>
&#125;
</code></pre>
<h3 id="3新增收货地址-持久层"><a class="markdownIt-Anchor" href="#3新增收货地址-持久层"></a> 3.新增收货地址-持久层</h3>
<h4 id="31各功能的开发顺序"><a class="markdownIt-Anchor" href="#31各功能的开发顺序"></a> 3.1各功能的开发顺序</h4>
<p>当前收货地址功能模块:</p>
<ul>
<li>第一个页面:列表的展示,修改,删除,设置默认</li>
<li>第二个页面:新增收货地址</li>
</ul>
<p>开发顺序:新增收货地址-&gt;列表的展示-&gt;设置默认收货地址-&gt;删除收货地址-&gt;修改收货地址</p>
<h4 id="32规划需要执行的sql语句"><a class="markdownIt-Anchor" href="#32规划需要执行的sql语句"></a> 3.2规划需要执行的SQL语句</h4>
<p>1.新增收货地址对应的是插入语句:</p>
<pre class="highlight"><code class="sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_address (aid以外的所有字段) <span class="hljs-keyword">values</span> (字段值)
</code></pre>
<p>2.大部分平台都会规定一个用户的收货地址数量,这里规定最多20个.那么在插入用户新的地址之前就要先做查询操作.如果查询到的是刚好20,这并不是一个java语法的异常,可以认为是业务控制的异常,这个异常随后在service抛,在controller捕获</p>
<pre class="highlight"><code class="sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">from</span> t_address <span class="hljs-keyword">where</span> uid=?
</code></pre>
<h4 id="33设计接口和抽象方法"><a class="markdownIt-Anchor" href="#33设计接口和抽象方法"></a> 3.3设计接口和抽象方法</h4>
<p>创建接口AddressMapper,在这个接口中定义上面两个SQL语句抽象方法定义</p>
<pre class="highlight"><code class="">/**收货地址持久层的接口*/
public interface AddressMapper &#123;
    /**
     * 插入用户的收货地址数据
     * @param address 收货地址数据
     * @return 受影响的行数
     */
    Integer insert (Address address);

    /**
     * 根据用户的uid统计收货地址数量
     * @param uid 用户的uid
     * @return 当前用户的收货地址总数
     */
    Integer countByUid(Integer uid);
&#125;
</code></pre>
<h4 id="34编写映射"><a class="markdownIt-Anchor" href="#34编写映射"></a> 3.4编写映射</h4>
<p>1.快速创建一个AddressMapper.xml映射文件:</p>
<ul>
<li>鼠标放在UserMapper.xml文件上并ctrl+c,再把鼠标放到mapper文件夹上ctrl+v,在弹出的窗口中把UserMapper改为AddressMapper.</li>
<li>进入AddressMapper.xml文件将mapper标签下的代码全部删除并修改mapper标签属性值为namespace=“com.cy.store.mapper.AddressMapper”</li>
</ul>
<p>结果如下所示:</p>
<pre class="highlight"><code class="xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span>
        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>
        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.cy.store.mapper.AddressMapper"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span>
</code></pre>
<p>2.在mapper标签中配置Address类属性与数据库中表的字段映射</p>
<pre class="highlight"><code class="">    &lt;resultMap id=&quot;AddressEntityMap&quot; type=&quot;com.cy.store.entity.Address&quot;&gt;
        &lt;id column=&quot;aid&quot; property=&quot;aid&quot;/&gt;
        &lt;result column=&quot;province_name&quot; property=&quot;provinceName&quot;/&gt;
        &lt;result column=&quot;province_code&quot; property=&quot;provinceCode&quot;/&gt;
        &lt;result column=&quot;city_name&quot; property=&quot;cityName&quot;/&gt;
        &lt;result column=&quot;city_code&quot; property=&quot;cityCode&quot;/&gt;
        &lt;result column=&quot;area_name&quot; property=&quot;areaName&quot;/&gt;
        &lt;result column=&quot;area_code&quot; property=&quot;areaCode&quot;/&gt;
        &lt;result column=&quot;is_default&quot; property=&quot;isDefault&quot;/&gt;
        &lt;result column=&quot;created_user&quot; property=&quot;createdUser&quot;/&gt;
        &lt;result column=&quot;created_time&quot; property=&quot;createdTime&quot;/&gt;
        &lt;result column=&quot;modified_user&quot; property=&quot;modifiedUser&quot;/&gt;
        &lt;result column=&quot;modified_time&quot; property=&quot;modifiedTime&quot;/&gt;
    &lt;/resultMap&gt;
</code></pre>
<p>判断该映射是否配置成功:按着ctrl并点击type=&quot;com.cy.store.entity.Address&quot;中的Address,如果能跳转到Address类说明映射成功</p>
<p>3.在AddressMapper.xml中配置以上两个抽象方法的映射</p>
<pre class="highlight"><code class="">    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;aid&quot;&gt;
        INSERT INTO t_address (
            uid, `name`, province_name, province_code, city_name, city_code, area_name, area_code, zip,
            address, phone, tel,tag, is_default, created_user, created_time, modified_user, modified_time
        ) VALUES (
            #&#123;uid&#125;, #&#123;name&#125;, #&#123;provinceName&#125;, #&#123;provinceCode&#125;, #&#123;cityName&#125;, #&#123;cityCode&#125;, #&#123;areaName&#125;,
            #&#123;areaCode&#125;, #&#123;zip&#125;, #&#123;address&#125;, #&#123;phone&#125;, #&#123;tel&#125;, #&#123;tag&#125;, #&#123;isDefault&#125;, #&#123;createdUser&#125;,
            #&#123;createdTime&#125;, #&#123;modifiedUser&#125;, #&#123;modifiedTime&#125;
        )
    &lt;/insert&gt;

    &lt;!--resultType=&quot;java.lang.Integer&quot;不写会报错,因为Integer不是基本数据类型--&gt;
    &lt;select id=&quot;countByUid&quot;  resultType=&quot;java.lang.Integer&quot;&gt;
        select count(*) from t_address where uid=#&#123;uid&#125;
    &lt;/select&gt;
</code></pre>
<h4 id="35单元测试"><a class="markdownIt-Anchor" href="#35单元测试"></a> 3.5单元测试</h4>
<p>在test下的mapper文件夹下创建AddressMapperTests测试类</p>
<pre class="highlight"><code class="">@SpringBootTest
@RunWith(SpringRunner.class)
public class AddressMapperTests &#123;

    @Autowired
    private AddressMapper addressMapper;

    @Test
    public void insert() &#123;
        Address address = new Address();
        address.setUid(11);
        address.setPhone(&quot;133336&quot;);
        address.setName(&quot;女朋友&quot;);
        addressMapper.insert(address);
    &#125;

    @Test
    public void countByUid() &#123;
        Integer count = addressMapper.countByUid(11);
        System.out.println(count);
    &#125;
&#125;
</code></pre>
<h3 id="4新增收货地址-业务层"><a class="markdownIt-Anchor" href="#4新增收货地址-业务层"></a> 4.新增收货地址-业务层</h3>
<h4 id="41规划异常-2"><a class="markdownIt-Anchor" href="#41规划异常-2"></a> 4.1规划异常</h4>
<ul>
<li>
<p>插入数据时用户不存在(被管理员误删等等),抛UsernameNotFoundException异常(已经有了,不需要重复创建)</p>
</li>
<li>
<p>当用户插入的地址是第一条时,需要将当前地址作为默认收货地址</p>
<p>实现办法:如果查询到统计总数为0则将当前地址的is_default值设置为1</p>
</li>
<li>
<p>如果查询的结果&gt;=20,这时需要抛出业务控制的异常AddressCountLimitException</p>
<pre class="highlight"><code class="">/**收货地址总数超出限制的异常(20条)*/
public class AddressCountLimitException extends ServiceException &#123;
    /**重写ServiceException的所有构造方法*/
&#125;
</code></pre>
</li>
<li>
<p>插入数据时产生未知的异常InsertException(已经有了,不需要重复创建)</p>
</li>
</ul>
<h4 id="42设计接口和抽象方法及实现"><a class="markdownIt-Anchor" href="#42设计接口和抽象方法及实现"></a> 4.2设计接口和抽象方法及实现</h4>
<p>1.创建一个IAddressService接口,在接口中定义业务的抽象方法</p>
<p>因为mapper层接口该功能模块定义了两个抽象方法,所以就要在service层接口该功能模块也定义两个抽象方法?不是这样的,要看mapper层的这两个方法是依赖关系还是独立关系,如果某一个抽象方法依赖于另一个抽象方法,那就需要在业务层将这两个方法整合到一个方法中.一句话来说就是:一个功能模块可能需要多条sql语句</p>
<pre class="highlight"><code class="">/**收货地址的业务层接口*/
@Service
public interface IAddressService &#123;
    /**
     *这三个参数的由来:
     * 1.首先肯定要有address
     * 2.业务层需要根据uid查询该用户收货地址总数及新建地址时给字段uid赋值
     * 但新建收货地址的表单中并没有哪个控件让输入用户uid,所以需要控制层将uid传给业务层
     * 3.业务层在创建/修改收货地址时需要同时修改数据库中创建人/修改人的字段
     * 但新建收货地址的表单中并没有哪个控件让输入用户username,所以需要控制层将username传给业务层
     * 注意:&gt; 可以用HttpSession session代替Integer uid, String username,但
     * 这样写的话就需要把BaseController类下获取uid,username的方法重新封装到一个
     * 类中并让IAddressServiceImp实现类继承该类,这样就需要微调一下代码逻辑,太麻
     * 烦,并且,最好每一层只处理该层需要做的事情,session对象是控制层传递的,所以就
     * 把session对象定义封装在控制层中,不需要在业务层中额外处理以降低耦合
     */
    void addNewAddress(Integer uid, String username, Address address);
&#125;
</code></pre>
<p>方法addNewAddress中三个参数的由来:</p>
<ul>
<li>
<p>首先肯定要有address</p>
</li>
<li>
<p>业务层需要根据uid查询该用户收货地址总数及新建地址时给字段uid赋值</p>
<p>但新建收货地址的表单中并没有哪个控件让输入用户uid,所以需要控制层将uid传给业务层并在业务层封装到address对象中</p>
</li>
<li>
<p>业务层在创建/修改收货地址时需要同时修改数据库中创建人/修改人的字段</p>
<p>但新建收货地址的表单中并没有哪个控件让输入用户username,所以需要控制层将username传给业务层并在业务层封装到address对象中</p>
</li>
</ul>
<blockquote>
<p>可以用HttpSession session代替Integer uid, String username,但这样写的话就需要把BaseController类下获取uid,username的方法重新封装到一个类中并让AddressServiceImpl实现类继承该类,这样就需要微调一下代码逻辑,太麻烦,并且,最好每一层只处理该层需要做的事情,session对象是控制层传递的,所以就把session对象定义封装在控制层中,不需要在业务层中额外处理,这样可以降低耦合</p>
</blockquote>
<p>2.创建一个AddressServiceImpl类实现接口中抽象方法</p>
<pre class="highlight"><code class="">/**新增收货地址的实现类*/
public class AddressServiceImpl implements IAddressService &#123;
    @Autowired
    private AddressMapper addressMapper;
    @Autowired
    private UserMapper userMapper;

    /**
     * 为了方便日后修改最大收货地址数量,可以在配置文件
     * application.properties中定义user.address.max-count=20
     */
    //spring读取配置文件中数据:@Value(&quot;$&#123;user.address.max-count&#125;&quot;)
    @Value(&quot;$&#123;user.address.max-count&#125;&quot;)
    private Integer maxCount;

    @Override
    public void addNewAddress(Integer uid, String username, Address address) &#123;
        User result = userMapper.findByUid(uid);
        if (result ==null || result.getIsDelete() == 1) &#123;
            throw new UsernameNotFoundException(&quot;用户数据不存在&quot;);
        &#125;

        //调用统计收货地址数量的方法
        Integer count = addressMapper.countByUid(uid);
        if (count &gt;= maxCount) &#123;
            throw new AddressCountLimitException(&quot;用户收货地址超出上限&quot;);
        &#125;

        //uid,isDefault
        address.setUid(uid);
        Integer isDefault = count == 0 ? 1 : 0;//1表示默认收货地址,0反之
        address.setIsDefault(isDefault);

        //补全四项日志
        address.setCreatedUser(username);
        address.setModifiedUser(username);
        address.setCreatedTime(new Date());
        address.setModifiedTime(new Date());

        //调用插入收货地址的方法
        Integer rows = addressMapper.insert(address);
        if (rows != 1) &#123;
            throw new InsertException(&quot;插入用户的收货地址时产生未知异常&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>别忘了在配置文件application.properties中定义user.address.max-count=20</p>
<h4 id="43单元测试-2"><a class="markdownIt-Anchor" href="#43单元测试-2"></a> 4.3单元测试</h4>
<p>在test下的service文件夹下创建AddressServiceTests测试类</p>
<pre class="highlight"><code class="">@SpringBootTest
@RunWith(SpringRunner.class)
public class AddressServiceTests &#123;
    @Autowired
    private IAddressService addressService;

    @Test
    public void addNewAddress() &#123;
        Address address = new Address();
        address.setPhone(&quot;175726&quot;);
        address.setName(&quot;男朋友&quot;);
        addressService.addNewAddress(11,&quot;mxy&quot;,address);
    &#125;
&#125;
</code></pre>
<h3 id="5新增收货地址-控制层"><a class="markdownIt-Anchor" href="#5新增收货地址-控制层"></a> 5.新增收货地址-控制层</h3>
<h4 id="51处理异常"><a class="markdownIt-Anchor" href="#51处理异常"></a> 5.1处理异常</h4>
<p>义务层抛出了收货地址总数超出上限的异常,在BaseController中进行捕获处理</p>
<pre class="highlight"><code class="">else if (e instanceof AddressCountLimitException) &#123;
    result.setState(4003);
    result.setMessage(&quot;用户的收货地址超出上限的异常&quot;);
&#125;
</code></pre>
<h4 id="52设计请求-2"><a class="markdownIt-Anchor" href="#52设计请求-2"></a> 5.2设计请求</h4>
<ul>
<li>/addresses/add_new_address</li>
<li>post</li>
<li>Address address,HttpSession session</li>
<li>JsonResult<Void></li>
</ul>
<h4 id="53处理请求-2"><a class="markdownIt-Anchor" href="#53处理请求-2"></a> 5.3处理请求</h4>
<p>在controller包下创建AddressController并继承BaseController,该类用来处理用户收货地址的请求和响应</p>
<pre class="highlight"><code class="">@RequestMapping(&quot;addresses&quot;)
@RestController
public class AddressController extends BaseController&#123;
    @Autowired
    private IAddressService addressService;

    @RequestMapping(&quot;add_new_address&quot;)
    public JsonResult&lt;Void&gt; addNewAddress(Address address, HttpSession session) &#123;
        Integer uid = getUidFromSession(session);
        String username = getUsernameFromSession(session);
        addressService.addNewAddress(uid,username,address);
        return new JsonResult&lt;&gt;(OK);
    &#125;
&#125;
</code></pre>
<p>启动服务器,登录账号后在地址栏输入http://localhost:8080/addresses/add_new_address?name=tom&amp;phone=98745612进行测试</p>
<h3 id="6新增收货地址-前端页面"><a class="markdownIt-Anchor" href="#6新增收货地址-前端页面"></a> 6.新增收货地址-前端页面</h3>
<pre class="highlight"><code class="">        &lt;script&gt;
            $(&quot;#btn-add-new-address&quot;).click(function () &#123;
                $.ajax(&#123;
                    url: &quot;/addresses/add_new_address&quot;,
                    type: &quot;POST&quot;,
                    data: $(&quot;#form-add-new-address&quot;).serialize(),
                    dataType: &quot;JSON&quot;,
                    success: function (json) &#123;
                        if (json.state == 200) &#123;
                            alert(&quot;新增收货地址成功&quot;)
                        &#125; else &#123;
                            alert(&quot;新增收货地址失败&quot;)
                        &#125;
                    &#125;,
                    error: function (xhr) &#123;
                        alert(&quot;新增收货地址时产生未知的异常!&quot;+xhr.message);
                    &#125;
                &#125;);
            &#125;);
        &lt;/script&gt;
</code></pre>
<h2 id="获取省市区列表"><a class="markdownIt-Anchor" href="#获取省市区列表"></a> 获取省市区列表</h2>
<p>新增收货地址页面的三个下拉列表的内容展示没有和数据库进行交互,而是通过前端实现的(将代码逻辑放在了distpicker.data.js文件中),实现方法是在加载新增收货地址页面时加载该js文件,这种做法不可取(我不知道为啥)</p>
<p>正确做法是:把这些数据保存到数据库中,用户点击下拉列表时相应的数据会被详细的展示出来,然后监听用户选择了哪一项以便后面的下拉列表进行二级关联</p>
<h3 id="1创建数据表-3"><a class="markdownIt-Anchor" href="#1创建数据表-3"></a> 1.创建数据表</h3>
<p>1.创建t_dict_district表</p>
<pre class="highlight"><code class="">CREATE TABLE t_dict_district (
  id INT(11) NOT NULL AUTO_INCREMENT,
  parent VARCHAR(6) DEFAULT NULL,
  `code` VARCHAR(6) DEFAULT NULL,
  `name` VARCHAR(16) DEFAULT NULL,
  PRIMARY KEY (id)
) ENGINE=INNODB DEFAULT CHARSET=utf8;
</code></pre>
<ul>
<li>code和name需要加``</li>
<li>parent代表父区域的代码号</li>
<li>code代表自身的代码号</li>
<li>省的父代码号是+86,代表中国</li>
</ul>
<p>2.向该表中插入省市区数据</p>
<pre class="highlight"><code class="">LOCK TABLES t_dict_district WRITE;
INSERT INTO t_dict_district VALUES (1,'110100','110101','东城区'),(2,'110100','110102','西城区')等等等等;
UNLOCK TABLES;
</code></pre>
<p>LOCK和UNLOVK干嘛用的?</p>
<h3 id="2创建省市区的实体类"><a class="markdownIt-Anchor" href="#2创建省市区的实体类"></a> 2.创建省市区的实体类</h3>
<p>在包entity下创建实体类District(不需要继承BaseEntity,但因为没有继承BaseEntity所以需要实现接口Serializable序列化)</p>
<pre class="highlight"><code class="">/**省市区的数据实体类*/
public class District implements Serializable &#123;
    private Integer id;
    private String parent;
    private String code;
    private String name;
 /**
 * get,set
 * equals和hashCode
 * toString
 */
&#125;
</code></pre>
<h3 id="3获取省市区列表-持久层"><a class="markdownIt-Anchor" href="#3获取省市区列表-持久层"></a> 3.获取省市区列表-持久层</h3>
<h4 id="31规划需执行的sql语句"><a class="markdownIt-Anchor" href="#31规划需执行的sql语句"></a> 3.1规划需执行的SQL语句</h4>
<pre class="highlight"><code class="">select * from t_dict_district where parent=? order by ASC
</code></pre>
<h4 id="32设计接口和抽象方法"><a class="markdownIt-Anchor" href="#32设计接口和抽象方法"></a> 3.2设计接口和抽象方法</h4>
<p>日后可能开发新的模块仍要用到省市区列表,那么为了降低耦合性,就要创建新的接口</p>
<p>在mapper层下创建接口DistrictMapper</p>
<pre class="highlight"><code class="">public interface DistrictMapper &#123;

    /**
     * 根据父代码号查询区域信息
     * @param parent 父代码号
     * @return 某个父区域下所有的区域列表
     */
    List&lt;District&gt; findByParent(String parent);//查询的结果可能是多个,所以放在集合中
&#125;
</code></pre>
<h4 id="33编写映射-2"><a class="markdownIt-Anchor" href="#33编写映射-2"></a> 3.3编写映射</h4>
<p>创建一个DistrictMapper.xml映射文件并配置上述抽象方法的映射</p>
<pre class="highlight"><code class="">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.cy.store.mapper.DistrictMapper&quot;&gt;
    &lt;select id=&quot;findByParent&quot; resultType=&quot;com.cy.store.entity.District&quot;&gt;
        select * from t_dict_district where parent=#&#123;parent&#125;
        order by code ASC
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h4 id="34单元测试-2"><a class="markdownIt-Anchor" href="#34单元测试-2"></a> 3.4单元测试</h4>
<p>创建DistrictMapperTests测试类编写代码进行测试</p>
<pre class="highlight"><code class="">@SpringBootTest
@RunWith(SpringRunner.class)
public class DistrictMapperTests &#123;

    @Autowired
    private DistrictMapper districtMapper;
    
    @Test
    public void findByParent() &#123;
        List&lt;District&gt; list = districtMapper.findByParent(&quot;210100&quot;);
        for (District district : list) &#123;
            System.out.println(district);
        &#125;
    &#125;

&#125;
</code></pre>
<h3 id="4获取省市区列表-业务层"><a class="markdownIt-Anchor" href="#4获取省市区列表-业务层"></a> 4.获取省市区列表-业务层</h3>
<h4 id="41规划异常-3"><a class="markdownIt-Anchor" href="#41规划异常-3"></a> 4.1规划异常</h4>
<p>没有异常需要处理</p>
<h4 id="42设计接口和抽象方法及实现-2"><a class="markdownIt-Anchor" href="#42设计接口和抽象方法及实现-2"></a> 4.2设计接口和抽象方法及实现</h4>
<p>1.创建一个接口IDistrictService,并定义抽象方法</p>
<pre class="highlight"><code class="">public interface IDistrictService &#123;

    /**
     * 根据父代码号来查询区域信息(省或市或区)
     * @param parent 父代码号
     * @return 多个区域的信息
     */
    List&lt;District&gt; getByParent(String parent);
&#125;
</code></pre>
<p>2.创建DistrictServiceImpl实现类来实现抽象方法</p>
<pre class="highlight"><code class="">@Service
public class DistrictServiceImpl implements IDistrictService &#123;

    @Autowired
    private DistrictMapper districtMapper;

    @Override
    public List&lt;District&gt; getByParent(String parent) &#123;
        List&lt;District&gt; list = districtMapper.findByParent(parent);
        /**
         * 在进行网络数据传输时,为了尽量避免无效数据的传递,可以将无效数据
         * 设置为null,这样既节省流量,又提升了效率
         */
        for (District district : list) &#123;
            district.setId(null);
            district.setParent(null);
        &#125;
        return list;
    &#125;
&#125;
</code></pre>
<h4 id="43单元测试-3"><a class="markdownIt-Anchor" href="#43单元测试-3"></a> 4.3单元测试</h4>
<p>在test下的service文件夹下创建DistrictServiceTests测试类</p>
<pre class="highlight"><code class="">@SpringBootTest
@RunWith(SpringRunner.class)
public class DistrictServiceTests &#123;
    @Autowired
    private IDistrictService districtService;

    @Test
    public void getByParent() &#123;
        //86代表中国,所有的省父代码号都是86
        List&lt;District&gt; list = districtService.getByParent(&quot;86&quot;);
        for (District district : list) &#123;
            System.err.println(district);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="5获取省市区列表-控制层"><a class="markdownIt-Anchor" href="#5获取省市区列表-控制层"></a> 5.获取省市区列表-控制层</h3>
<h4 id="51设计请求"><a class="markdownIt-Anchor" href="#51设计请求"></a> 5.1设计请求</h4>
<ul>
<li>/districts/</li>
<li>GET</li>
<li>String parent</li>
<li>JsonResult&lt;List<District>&gt;</li>
</ul>
<h4 id="52处理请求"><a class="markdownIt-Anchor" href="#52处理请求"></a> 5.2处理请求</h4>
<p>1.创建一个DistrictController类,在类中编写处理请求的方法</p>
<pre class="highlight"><code class="">@RequestMapping(&quot;districts&quot;)
@RestController
public class DistrictController extends BaseController&#123;
    @Autowired
    private IDistrictService districtService;

    /**
     * 请求路径和父路径相同时用@RequestMapping(&#123;&quot;/&quot;,&quot;&quot;&#125;),表
     * 示districts后面跟/或者什么也不跟都会进入这个方法
     * 点进RequestMapping发现参数类型是String[],且传入一
     * 个路径时默认有&#123;&#125;,传入一个以上路径时需要手动添加&#123;&#125;
     */
    @RequestMapping(&#123;&quot;/&quot;,&quot;&quot;&#125;)
    public JsonResult&lt;List&lt;District&gt;&gt; getByParent(String parent) &#123;
        List&lt;District&gt; data = districtService.getByParent(parent);
        return new JsonResult&lt;&gt;(OK,data);
    &#125;
&#125;
</code></pre>
<p>2.为了能不登录也可以访问该数据,需要将districts请求添加到白名单中:</p>
<p>在LoginInterceptorConfigure类的addInterceptors方法中添加代码:patterns.add(“/districts/**”);</p>
<p>3.启动服务器,不登录账号,直接在地址栏输入http://localhost:8080/districts?parent=86测试能否正常获取数据</p>
<h3 id="6获取省市区列表-前端页面"><a class="markdownIt-Anchor" href="#6获取省市区列表-前端页面"></a> 6.获取省市区列表-前端页面</h3>
<p>1.原始的下拉列表展示是将数据放在js,再动态获取js中的数据,而目前为止我们已经将数据放在了数据库,所以不能让它再使用这种办法了,所以需要注释掉addAddress.html页面的这两行js代码:</p>
<pre class="highlight"><code class="">&lt;script type=&quot;text/javascript&quot; src=&quot;../js/distpicker.data.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/distpicker.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>关于这两行js代码:前者是为了获取数据,后者是为了将获取到的数据展示到下拉列表中</p>
<p>2.检查前端页面在提交省市区数据时是否有相关name属性和id属性(name用于提交数据,id用于监听用户的点击)</p>
<p>3.启动服务器,在前端验证一下是否还可以正常保存数据(除了省市区)</p>
<h2 id="获取省市区名称"><a class="markdownIt-Anchor" href="#获取省市区名称"></a> 获取省市区名称</h2>
<p>上一个模块获取省市区列表是通过父代码号获取子代码号完成联动,该模块获取省市区名称是通过自身的code获取自身的name</p>
<h3 id="1获取省市区名称-持久层"><a class="markdownIt-Anchor" href="#1获取省市区名称-持久层"></a> 1.获取省市区名称-持久层</h3>
<h4 id="31规划需要执行的sql语句-2"><a class="markdownIt-Anchor" href="#31规划需要执行的sql语句-2"></a> 3.1规划需要执行的SQL语句</h4>
<p>根据当前code来获取当前省市区的名称,对应就是一条查询语句</p>
<pre class="highlight"><code class="">select * from t_dict_district where code=?
</code></pre>
<h4 id="32设计接口和抽象方法-2"><a class="markdownIt-Anchor" href="#32设计接口和抽象方法-2"></a> 3.2设计接口和抽象方法</h4>
<p>在DistrictMapper接口定义findNameByCode方法</p>
<pre class="highlight"><code class="">String findNameByCode(String code);
</code></pre>
<h4 id="33编写映射-3"><a class="markdownIt-Anchor" href="#33编写映射-3"></a> 3.3编写映射</h4>
<p>在DistrictMapper.xml文件中添加findNameByCode方法的映射</p>
<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findNameByCode"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"java.lang.String"</span>&gt;</span>
    select name from t_dict_district where code=#&#123;code&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
</code></pre>
<h4 id="34单元测试-3"><a class="markdownIt-Anchor" href="#34单元测试-3"></a> 3.4单元测试</h4>
<p>在DistrictMapperTests编写测试代码</p>
<pre class="highlight"><code class="">@Test
public void findNameByCode() &#123;
    String name = districtMapper.findNameByCode(&quot;610000&quot;);
    System.out.println(name);
&#125;
</code></pre>
<h3 id="2获取省市区名称-业务层"><a class="markdownIt-Anchor" href="#2获取省市区名称-业务层"></a> 2.获取省市区名称-业务层</h3>
<h4 id="21规划异常-5"><a class="markdownIt-Anchor" href="#21规划异常-5"></a> 2.1规划异常</h4>
<p>没有异常需要处理</p>
<h4 id="22设计接口和抽象方法及实现-5"><a class="markdownIt-Anchor" href="#22设计接口和抽象方法及实现-5"></a> 2.2设计接口和抽象方法及实现</h4>
<p>1.在IDistrictService接口定义对应的业务层接口中的抽象方法</p>
<pre class="highlight"><code class="">String getNameByCode(String code);
</code></pre>
<p>2.在DistrictServiceImpl实现此方法</p>
<pre class="highlight"><code class="">@Override
public String getNameByCode(String code) &#123;
    return districtMapper.findNameByCode(code);
&#125;
</code></pre>
<h4 id="23单元测试-5"><a class="markdownIt-Anchor" href="#23单元测试-5"></a> 2.3单元测试</h4>
<p>业务层只是调用持久层对应的方法然后返回,没有什么额外的实现,可以不用测试(一般超过8行的代码都要进行测试)</p>
<h3 id="3获取省市区名称-控制层"><a class="markdownIt-Anchor" href="#3获取省市区名称-控制层"></a> 3.获取省市区名称-控制层</h3>
<p>实际开发中在获取省市区名称时并不需要前端传控制层,然后传业务层,再传持久层,而是在新增收货地址的业务层需要获取省市区名称,也就是说获取省市区名称的模块不需要控制层,只是需要被新增收货地址的业务层所依赖</p>
<h3 id="4获取省市区名称-业务层优化"><a class="markdownIt-Anchor" href="#4获取省市区名称-业务层优化"></a> 4.获取省市区名称-业务层优化</h3>
<p>1.<strong>在新增收货地址的业务层需要对address进行封装,使其存有所有数据,然后将address传给持久层(记住,持久层只会根据传过来的参数调用某个方法与数据库交互,永远不会有额外的实现),而此时新增收货地址的业务层并没有省市区的数据,所以需要依赖于获取省市区列表的业务层对应的接口中的getNameByCode方法</strong></p>
<p>所以需要在业务层实现类AddressServiceImpl中加</p>
<pre class="highlight"><code class="java"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> IDistrictService districtService;
</code></pre>
<p>2.在AddressServiceImpl的方法中将DistrictService接口中获取到的省市区数据封装到address对象,此时address就包含了所有用户收货地址的数据</p>
<pre class="highlight"><code class="java"><span class="hljs-comment">/**
* 对address对象中的数据进行补全:省市区的名字看前端代码发现前端传递过来的省市区的name分别为:
* provinceCode,cityCode,areaCode,所以这里可以用address对象的get方法获取这三个的数据
 */</span>
String provinceName = districtService.getNameByCode(address.getProvinceCode());
String cityName = districtService.getNameByCode(address.getCityCode());
String areaName = districtService.getNameByCode(address.getAreaCode());
address.setProvinceName(provinceName);
address.setCityName(cityName);
address.setAreaName(areaName);
</code></pre>
<h3 id="5获取省市区名称-前端页面"><a class="markdownIt-Anchor" href="#5获取省市区名称-前端页面"></a> 5.获取省市区名称-前端页面</h3>
<p><strong>在addAddress.html页面中来编写对应的省市区展示及根据用户的不同选择来限制对应的标签中的内容</strong></p>
<p>分析:</p>
<ul>
<li>在加载该页面时三个下拉列表的内容都显示为&quot;-----请选择-----&quot;</li>
<li>没有选择市时如果点击区的下拉列表则列表中只有一个&quot;-----请选择-----&quot;</li>
<li>加载该页面时需要自动发送一个请求把parent=86发送出去,然后将返回的省/直辖市填充到select标签中</li>
<li>点击四川省后发送请求获取其下的市,并且将获取到的市罗列在市区域下拉列表中</li>
<li>省点击&quot;-----请选择-----“则需要把市,县内容填充为”-----请选择-----&quot;终止请求而不是程序继续跑下去</li>
<li>切换省份时,市,县内容更换为&quot;-----请选择-----&quot;</li>
</ul>
<p>在addAddress.html中编写js代码</p>
<pre class="highlight"><code class="JAVA">            <span class="hljs-comment">/**因为清空后下拉列表的select标签没有option标签,所以需要设置一个默认的option标
             * 签并给市,县加上该标签.option标签并不会把内容发送到后端,而是将value值发
             * 送给后端,所以用value表示当前这个区域的code值
             * */</span>
            <span class="hljs-keyword">var</span> defaultOption=<span class="hljs-string">"&lt;option value='0'&gt;-----请选择-----&lt;/option&gt;"</span>;
            $(document).ready(function () &#123;
                <span class="hljs-comment">//加载省的数据罗列时代码量较多,建议定义在外部方法中,然后在这里调用定义的方法</span>
                showProvinceList();

                <span class="hljs-comment">//将省,市,县的下拉列表内容设为"-----请选择-----"</span>
                <span class="hljs-comment">/**
                 * select标签默认获取第一个option的内容填充到下拉列表中,所以即使加载
                 * 页面时省区域的下拉列表中已经有了所有省但仍然会显示-----请选择-----
                 * */</span>
                $(<span class="hljs-string">"#province-list"</span>).append(defaultOption);

                $(<span class="hljs-string">"#city-list"</span>).append(defaultOption);
                $(<span class="hljs-string">"#area-list"</span>).append(defaultOption);
            &#125;);

            <span class="hljs-comment">//省的下拉列表数据展示</span>
            <span class="hljs-function">function <span class="hljs-title">showProvinceList</span><span class="hljs-params">()</span> </span>&#123;
                $.ajax(&#123;
                    url: <span class="hljs-string">"/districts"</span>,<span class="hljs-comment">//发送请求用于获取所有省对象</span>
                    type: <span class="hljs-string">"POST"</span>,
                    data: <span class="hljs-string">"parent=86"</span>,
                    dataType: <span class="hljs-string">"JSON"</span>,
                    success: function (json) &#123;
                        <span class="hljs-keyword">if</span> (json.state == <span class="hljs-number">200</span>) &#123;
                            <span class="hljs-keyword">var</span> list = json.data;<span class="hljs-comment">//获取所有省对象的List集合</span>
                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) &#123;
                                <span class="hljs-keyword">var</span> opt =
                                    <span class="hljs-string">"&lt;option value='"</span>+list[i].code+<span class="hljs-string">"'&gt;"</span>+list[i].name+<span class="hljs-string">"&lt;/option&gt;"</span>;
                                $(<span class="hljs-string">"#province-list"</span>).append(opt);
                            &#125;
                        &#125; <span class="hljs-keyword">else</span> &#123;
                            &lt;!--这个其实永远不会执行,因为没有编写
                            异常,控制层返回的状态码永远是OK--&gt;
                            alert(<span class="hljs-string">"省/直辖区的信息加载失败"</span>)
                        &#125;
                    &#125;
                    <span class="hljs-comment">//这里没有写属性error,不知道为啥不用写,感觉写了更好</span>
                &#125;);
            &#125;

            <span class="hljs-comment">/**
             * change()函数用于监听某个控件是否发生改变,一旦发生改变就
             * 会触发参数形式的函数,所以参数需要是function()&#123;&#125;
             * */</span>
            $(<span class="hljs-string">"#province-list"</span>).change(function () &#123;
                <span class="hljs-comment">//先获取到省区域父代码号</span>
                <span class="hljs-keyword">var</span> parent = $(<span class="hljs-string">"#province-list"</span>).val();

                <span class="hljs-comment">/**
                 * 如果我选择了河南省洛阳市涧西区,然后又选择了河北省,此时需要
                 * 将市,县下拉列表的所有option清除并显示内容-----请选择-----
                 * empty()表示某标签的所有子标签(针对此页面来说select的子标
                 * 签只有option)
                 * */</span>
                $(<span class="hljs-string">"#city-list"</span>).empty();
                $(<span class="hljs-string">"#area-list"</span>).empty();
                <span class="hljs-comment">//填充默认值:-----请选择-----</span>
                $(<span class="hljs-string">"#city-list"</span>).append(defaultOption);
                $(<span class="hljs-string">"#area-list"</span>).append(defaultOption);

                <span class="hljs-keyword">if</span> (parent == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果继续程序,后面的ajax接收的json数据中的data是</span>
                    <span class="hljs-keyword">return</span>;<span class="hljs-comment">//空集合[],进不了for循环,没有任何意义,所以直接在这里终止程序</span>
                &#125;
                $.ajax(&#123;
                    url: <span class="hljs-string">"/districts"</span>,
                    type: <span class="hljs-string">"POST"</span>,
                    data: <span class="hljs-string">"parent="</span>+parent,
                    dataType: <span class="hljs-string">"JSON"</span>,
                    success: function (json) &#123;
                        <span class="hljs-keyword">if</span> (json.state == <span class="hljs-number">200</span>) &#123;
                            <span class="hljs-keyword">var</span> list = json.data;
                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) &#123;
                                <span class="hljs-keyword">var</span> opt =
                                    <span class="hljs-string">"&lt;option value='"</span>+list[i].code+<span class="hljs-string">"'&gt;"</span>+list[i].name+<span class="hljs-string">"&lt;/option&gt;"</span>;
                                $(<span class="hljs-string">"#city-list"</span>).append(opt);
                            &#125;
                        &#125; <span class="hljs-keyword">else</span> &#123;
                            alert(<span class="hljs-string">"市的信息加载失败"</span>)
                        &#125;
                    &#125;
                &#125;);
            &#125;);

            $(<span class="hljs-string">"#city-list"</span>).change(function () &#123;
                <span class="hljs-keyword">var</span> parent = $(<span class="hljs-string">"#city-list"</span>).val();
                $(<span class="hljs-string">"#area-list"</span>).empty();
                $(<span class="hljs-string">"#area-list"</span>).append(defaultOption);

                <span class="hljs-keyword">if</span> (parent == <span class="hljs-number">0</span>) &#123;
                    <span class="hljs-keyword">return</span>;
                &#125;
                $.ajax(&#123;
                    url: <span class="hljs-string">"/districts"</span>,
                    type: <span class="hljs-string">"POST"</span>,
                    data: <span class="hljs-string">"parent="</span>+parent,
                    dataType: <span class="hljs-string">"JSON"</span>,
                    success: function (json) &#123;
                        <span class="hljs-keyword">if</span> (json.state == <span class="hljs-number">200</span>) &#123;
                            <span class="hljs-keyword">var</span> list = json.data;
                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) &#123;
                                <span class="hljs-keyword">var</span> opt =
                                    <span class="hljs-string">"&lt;option value='"</span>+list[i].code+<span class="hljs-string">"'&gt;"</span>+list[i].name+<span class="hljs-string">"&lt;/option&gt;"</span>;
                                $(<span class="hljs-string">"#area-list"</span>).append(opt);
                            &#125;
                        &#125; <span class="hljs-keyword">else</span> &#123;
                            alert(<span class="hljs-string">"县的信息加载失败"</span>)
                        &#125;
                    &#125;
                &#125;);
            &#125;);
</code></pre>
<h2 id="收货地址列表展示"><a class="markdownIt-Anchor" href="#收货地址列表展示"></a> 收货地址列表展示</h2>
<h3 id="1收货地址列表展示-持久层"><a class="markdownIt-Anchor" href="#1收货地址列表展示-持久层"></a> 1.收货地址列表展示-持久层</h3>
<h4 id="11规划需要执行的sql语句-2"><a class="markdownIt-Anchor" href="#11规划需要执行的sql语句-2"></a> 1.1规划需要执行的SQL语句</h4>
<p>数据库数据的查询操作</p>
<pre class="highlight"><code class="sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_address <span class="hljs-keyword">where</span> uid ? <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> is_default <span class="hljs-keyword">DESC</span>,created_time <span class="hljs-keyword">DESC</span>
</code></pre>
<p>其中order by is_default DESC是为了让默认收货地址展示在最上面,order by可以有多个字句,中间用逗号隔开,后面加的create_time DESC是为了让非默认收货地址创建的越晚越展示在上面</p>
<h4 id="12设计接口和抽象方法-4"><a class="markdownIt-Anchor" href="#12设计接口和抽象方法-4"></a> 1.2设计接口和抽象方法</h4>
<p>在AddressMapper接口追加抽象方法findByUid</p>
<pre class="highlight"><code class="java"><span class="hljs-comment">/**
* 根据用户的uid查询用户的收货地址数据
* <span class="hljs-doctag">@param</span> uid 用户uid
* <span class="hljs-doctag">@return</span> 收货地址数据
*/</span>
<span class="hljs-function">List&lt;Address&gt; <span class="hljs-title">findByUid</span><span class="hljs-params">(Integer uid)</span></span>;
</code></pre>
<h4 id="13编写映射-4"><a class="markdownIt-Anchor" href="#13编写映射-4"></a> 1.3编写映射</h4>
<p>在xml文件添加相应的sql语句映射</p>
<pre class="highlight"><code class="">    &lt;select id=&quot;findByUid&quot; resultMap=&quot;AddressEntityMap&quot;&gt;
        select * from t_address where uid=#&#123;uid&#125;
        order by is_default DESC,created_time DESC
    &lt;/select&gt;
</code></pre>
<h4 id="14单元测试-4"><a class="markdownIt-Anchor" href="#14单元测试-4"></a> 1.4单元测试</h4>
<pre class="highlight"><code class="">@Test
public void findByUid () &#123;
    List&lt;Address&gt; list = addressMapper.findByUid(11);
    System.out.println(list);
&#125;
</code></pre>
<h3 id="2收货地址列表展示-业务层"><a class="markdownIt-Anchor" href="#2收货地址列表展示-业务层"></a> 2.收货地址列表展示-业务层</h3>
<h4 id="21规划异常-6"><a class="markdownIt-Anchor" href="#21规划异常-6"></a> 2.1规划异常</h4>
<p>该模块只是为了展示列表,不涉及到增删改,即便没有拿到任何数据,那无非就是不展示呗,所以不涉及到异常,不需要在业务层抛出异常</p>
<h4 id="22设计接口和抽象方法及实现-6"><a class="markdownIt-Anchor" href="#22设计接口和抽象方法及实现-6"></a> 2.2设计接口和抽象方法及实现</h4>
<p>1.定义抽象方法</p>
<pre class="highlight"><code class="">List&lt;Address&gt; getByUid(Integer uid);
</code></pre>
<p>2.实现该方法</p>
<pre class="highlight"><code class="">@Override
public List&lt;Address&gt; getByUid(Integer uid) &#123;
    List&lt;Address&gt; list = addressMapper.findByUid(uid);
    /**
    * 收货地址列表在前端只展示了四个数据,这里让其他值为空降低数据量
    * ProvinceName,CityName,AreaName,aid,tel(确认订单页展示展示用户地
    * 址时用到tel)在展示地址列表用不到,但是后面提交订单时的地址会用到,所以这里不设为null
    * */
    for (Address address : list) &#123;
        //address.setAid(null);
        address.setUid(null);
        //address.setProvinceName(null);
        address.setProvinceCode(null);
        //address.setCityName(null);
        address.setCityCode(null);
        //address.setAreaName(null);
        address.setAreaCode(null);
        address.setZip(null);
        //address.setTel(null);
        address.setIsDefault(null);
        address.setCreatedTime(null);
        address.setCreatedUser(null);
        address.setModifiedTime(null);
        address.setModifiedUser(null);
    &#125;
    return list;
&#125;
</code></pre>
<h4 id="23单元测试-6"><a class="markdownIt-Anchor" href="#23单元测试-6"></a> 2.3单元测试</h4>
<p>这里不再进行单元测试</p>
<h3 id="3收货地址列表展示-控制层"><a class="markdownIt-Anchor" href="#3收货地址列表展示-控制层"></a> 3.收货地址列表展示-控制层</h3>
<h4 id="31处理异常-4"><a class="markdownIt-Anchor" href="#31处理异常-4"></a> 3.1处理异常</h4>
<p>因为业务层没有抛出异常,所以这里不需要处理异常</p>
<h4 id="32设计请求-4"><a class="markdownIt-Anchor" href="#32设计请求-4"></a> 3.2设计请求</h4>
<ul>
<li>/addresses</li>
<li>HttpSession session</li>
<li>get(该功能模块只需要uid,不需要别的数据,而且uid也是在后端封装的,所以前端没有提交什么数据,体量很小可以用get)</li>
<li>JsonResult&lt;List<Address>&gt;</li>
</ul>
<h4 id="33处理请求-4"><a class="markdownIt-Anchor" href="#33处理请求-4"></a> 3.3处理请求</h4>
<p>实现请求方法的编写</p>
<pre class="highlight"><code class="">@RequestMapping(&#123;&quot;&quot;,&quot;/&quot;&#125;)
public JsonResult&lt;List&lt;Address&gt;&gt; getByUid(HttpSession session) &#123;
    Integer uid = getUidFromSession(session);
    List&lt;Address&gt; data = addressService.getByUid(uid);
    return new JsonResult&lt;&gt;(OK,data);
&#125;
</code></pre>
<p>启动服务,登录账号后在地址栏输入http://localhost:8080/addresses测试能否拿到数据</p>
<p>###4.收货地址列表展示-前端页面</p>
<p>在address.html中编写js代码</p>
<pre class="highlight"><code class="">&lt;script&gt;
    $(document).ready(function () &#123;
    showAddressList();
&#125;);

/**展示用户收货地址数据列表*/
function showAddressList() &#123;
    $(&quot;#address-list&quot;).empty();
    $.ajax(&#123;
        url: &quot;/addresses&quot;,
        type: &quot;get&quot;,
        //data: &quot;parent=86&quot;,//不需要提交数据,所以data可以删去
        dataType: &quot;JSON&quot;,
        success: function (json) &#123;
            if (json.state == 200) &#123;
                var list = json.data;
                console.log(list);//调试用
                for (var i = 0; i &lt; list.length; i++) &#123;
                    //先写一个var tr = ''; 然后去上面的地址展示中找一个tr标签复制粘贴到单引号里面,再删去多余的制表符
                    var tr = '&lt;tr&gt;\n' +
                        '&lt;td&gt;#&#123;tag&#125;&lt;/td&gt;\n' +
                        '&lt;td&gt;#&#123;name&#125;&lt;/td&gt;\n' +
                        '&lt;td&gt;#&#123;address&#125;&lt;/td&gt;\n' +
                        '&lt;td&gt;#&#123;phone&#125;&lt;/td&gt;\n' +
                        '&lt;td&gt;&lt;a class=&quot;btn btn-xs btn-info&quot;&gt;&lt;span class=&quot;fa fa-edit&quot;&gt;&lt;/span&gt; 修改&lt;/a&gt;&lt;/td&gt;\n' +
                        '&lt;td&gt;&lt;a class=&quot;btn btn-xs add-del btn-info&quot;&gt;&lt;span class=&quot;fa fa-trash-o&quot;&gt;&lt;/span&gt; 删除&lt;/a&gt;&lt;/td&gt;\n' +
                        '&lt;td&gt;&lt;a class=&quot;btn btn-xs add-def btn-default&quot;&gt;设为默认&lt;/a&gt;&lt;/td&gt;\n' +
                        '&lt;/tr&gt;';
                    //下面用正则表达式更改字符串,上面的#&#123;tag&#125;#&#123;name&#125;等等只
                    //是占位符,没有任何意义,我也可以把#&#123;tag&#125;写成任何想写的东西
                    //replace的第一个参数/占位符/g可以,&quot;占位符&quot;也可以
                    tr = tr.replace(/#&#123;tag&#125;/g,list[i].tag);
                    tr = tr.replace(/#&#123;name&#125;/g,list[i].name);
                    tr = tr.replace(&quot;#&#123;address&#125;&quot;,list[i].address);
                    tr = tr.replace(&quot;#&#123;phone&#125;&quot;,list[i].phone);

                    $(&quot;#address-list&quot;).append(tr);
                &#125;

                //用hide方法将第一个收货地址的&quot;设为默认&quot;元素隐藏,.add-def:eq(0)表
                //示第一个class为add-def的标签,这样就可以保证隐藏的是第一个收货地址
                $(&quot;.add-def:eq(0)&quot;).hide();
            &#125; else &#123;
                &lt;!--这个其实永远不会执行,因为没有编写
                异常,控制层返回的状态码永远是OK--&gt;
                alert(&quot;用户收货地址数据加载失败&quot;)
            &#125;
        &#125;
    &#125;);
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="设置默认收货地址"><a class="markdownIt-Anchor" href="#设置默认收货地址"></a> 设置默认收货地址</h2>
<h3 id="1设置默认收货地址-持久层"><a class="markdownIt-Anchor" href="#1设置默认收货地址-持久层"></a> 1.设置默认收货地址-持久层</h3>
<h4 id="11规划需要执行的sql语句-3"><a class="markdownIt-Anchor" href="#11规划需要执行的sql语句-3"></a> 1.1规划需要执行的SQL语句</h4>
<p>无论选择的是哪一条数据,都把所有的数据设为非默认,再把当前数据设为默认</p>
<blockquote>
<p>我们可能会想着把第一条设为非默认,再将该条设为默认,但这样处理的话需要额外做一条查询语句拿到默认地址的数据</p>
</blockquote>
<p>1.检测当前用户想设置为默认收货地址的这条数据是否存在</p>
<pre class="highlight"><code class="">select * from t_address where aid=?
</code></pre>
<p>2.在修改用户的默认收货地址之前先将所有的收货地址设置为非默认</p>
<pre class="highlight"><code class="">update t_address set is_default=0 where uid=?
</code></pre>
<p>3.将用户选中的这条记录设置为默认收货地址</p>
<pre class="highlight"><code class="">update t_address set is_default=1,modified_user=?,modified_time=? where aid=?
</code></pre>
<h4 id="12设计接口和抽象方法-5"><a class="markdownIt-Anchor" href="#12设计接口和抽象方法-5"></a> 1.2设计接口和抽象方法</h4>
<p>在AddressMapper接口中来定义实现该模块所需的三个方法</p>
<pre class="highlight"><code class="">/**
* 根据aid查询收货地址数据
* @param aid 收货地址aid
* @return 收货地址数据,如果没有找到则返回null值
*/
Address findByAid(Integer aid);

/**
* 根据用户uid修改用户的收货地址统一设置为非默认
* @param uid 用户uid
* @return 受影响的行数
*/
Integer updateNonDefault(Integer uid);


Integer updateDefaultByAid(
    @Param(&quot;aid&quot;) Integer aid,
    @Param(&quot;modifiedUser&quot;) String modifiedUser,
    @Param(&quot;modifiedTime&quot;) Date modifiedTime);
</code></pre>
<h4 id="13编写映射-5"><a class="markdownIt-Anchor" href="#13编写映射-5"></a> 1.3编写映射</h4>
<p>在AddressMapper.xml中编写映射</p>
<pre class="highlight"><code class="">&lt;select id=&quot;findByAid&quot; resultMap=&quot;AddressEntityMap&quot;&gt;
    select * from t_address where aid=#&#123;aid&#125;
&lt;/select&gt;

&lt;update id=&quot;updateNonDefault&quot;&gt;
    update t_address
    set is_default=0
    where uid=#&#123;uid&#125;
&lt;/update&gt;

&lt;update id=&quot;updateDefaultByAid&quot;&gt;
    update t_address
    set is_default=1,
    modified_user=#&#123;modifiedUser&#125;,
    modified_time=#&#123;modifiedTime&#125;
    where aid=#&#123;aid&#125;
&lt;/update&gt;
</code></pre>
<h4 id="14单元测试-5"><a class="markdownIt-Anchor" href="#14单元测试-5"></a> 1.4单元测试</h4>
<pre class="highlight"><code class="">    @Test
    public void findByAid() &#123;
        System.err.println(addressMapper.findByAid(9));
    &#125;

    @Test
    public void updateNonDefault() &#123;
        System.out.println(addressMapper.updateNonDefault(11));//有几条数据影响行数就输出几
    &#125;

    @Test
    public void updateDefaultByAid() &#123;
        addressMapper.updateDefaultByAid(9,&quot;明明&quot;,new Date());
    &#125;
</code></pre>
<h3 id="2设置默认收货地址-业务层"><a class="markdownIt-Anchor" href="#2设置默认收货地址-业务层"></a> 2.设置默认收货地址-业务层</h3>
<h4 id="21规划异常-7"><a class="markdownIt-Anchor" href="#21规划异常-7"></a> 2.1规划异常</h4>
<ul>
<li>在执行更新时产生未知的UpdateException异常,已经创建无需重复创建</li>
<li>访问的数据不是当前登录用户的收货地址数据,属于非法访问,AccessDeniedException异常(就比如说,展示收货地址列表的sql语句写错了,然后这里展示的是别人的收货地址,此时想要将某个收货地址改为默认就属于非法访问了)</li>
<li>收货地址可能不存在的AddressNotFoundException异常,(比如,刚展示完收货地址列表,管理员误删地址了,此时地址就不存在了)</li>
</ul>
<p>在业务层的ex包下创建如下两个异常类,并使其继承ServiceException类</p>
<pre class="highlight"><code class="">/**收货地址数据不存在的异常*/
public class AddressNotFoundException extends ServiceException &#123;
    /**重写ServiceException的所有构造方法*/
&#125;
</code></pre>
<pre class="highlight"><code class="">/**非法访问的异常*/
public class AccessDeniedException extends ServiceException &#123;
    /**重写ServiceException的所有构造方法*/
&#125;
</code></pre>
<h4 id="22设计接口和抽象方法及实现-7"><a class="markdownIt-Anchor" href="#22设计接口和抽象方法及实现-7"></a> 2.2设计接口和抽象方法及实现</h4>
<p>1.在IAddressService接口中编写抽象方法setDefault,并使其在方法内部统一实现持久层的三个方法</p>
<p>分析一下该方法需要什么参数:</p>
<blockquote>
<p>先看持久层的三个方法需要什么参数:aid,uid,modifiedUser,modifiedTime.</p>
<p>其中aid是从前端一步一步传到业务层的,所以需要该参数</p>
<p>uid和modifiedUser是一样的,都是由控制层从session获取的uid并传给业务层,所以需要该参数</p>
<p>modifiedTime可以在业务层new Date,所以不需要该参数</p>
</blockquote>
<pre class="highlight"><code class="">/**
* 修改某个用户的某条收货地址数据为默认收货地址
* @param aid 收货地址的id
* @param uid 用户id
* @param username 修改执行人
*/
void setDefault(Integer aid,Integer uid,String username);
</code></pre>
<p>2.在AddressServiceImpl类编写该方法的实现</p>
<pre class="highlight"><code class="">    @Override
    public void setDefault(Integer aid, Integer uid, String username) &#123;

        //1.检测是否有该条收货地址数据
        Address result = addressMapper.findByAid(aid);
        if (result == null) &#123;
            throw new AddressNotFoundException(&quot;收货地址不存在&quot;);
        &#125;

        //2.检测当前获取到的收货地址数据的归属
        if (!result.getUid().equals(uid)) &#123;
            throw new AccessDeniedException(&quot;非法数据访问&quot;);
        &#125;

        //3.先将所有的收货地址设置为非默认
        Integer rows = addressMapper.updateNonDefault(uid);
        if (rows &lt; 1) &#123;
            throw new UpdateException(&quot;更新数据时产生未知的异常&quot;);
        &#125;

        //4.将用户选中的地址设置为默认收货地址
        rows = addressMapper.updateDefaultByAid(aid, username, new Date());
        if (rows != 1) &#123;
            throw new UpdateException(&quot;更新数据时产生未知的异常&quot;);
        &#125;
    &#125;
</code></pre>
<h4 id="23单元测试-7"><a class="markdownIt-Anchor" href="#23单元测试-7"></a> 2.3单元测试</h4>
<p>在AddressServiceTests类中编写单元测试方法</p>
<pre class="highlight"><code class="java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDefault</span><span class="hljs-params">()</span> </span>&#123;
    addressService.setDefault(<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-string">"管理员"</span>);
&#125;
</code></pre>
<h3 id="3设置默认收货地址-控制层"><a class="markdownIt-Anchor" href="#3设置默认收货地址-控制层"></a> 3.设置默认收货地址-控制层</h3>
<h4 id="31处理异常-5"><a class="markdownIt-Anchor" href="#31处理异常-5"></a> 3.1处理异常</h4>
<p>在BaseController类中处理业务层抛出的两个异常</p>
<pre class="highlight"><code class="">else if (e instanceof AddressNotFoundException) &#123;
    result.setState(4004);
    result.setMessage(&quot;用户的收货地址数据不存在的异常&quot;);
&#125; else if (e instanceof AccessDeniedException) &#123;
    result.setState(4005);
    result.setMessage(&quot;收货地址数据非法访问的异常&quot;);
&#125;
</code></pre>
<h4 id="32设计请求-5"><a class="markdownIt-Anchor" href="#32设计请求-5"></a> 3.2设计请求</h4>
<ul>
<li>/addresses/{aid}/set_default(以前的数据是通过表单直接提交的,还有一种提交方式就是RestFul风格,这种提交方式可以提交更多的数据,这里用这个提交方式)</li>
<li>GET</li>
<li>Integer aid,HttpSession session(如果这里是id那就必须在Integer aid前加@PathVariable(“aid”)强行将aid的值注入到id中)</li>
<li>JsonResult<Void></li>
</ul>
<h4 id="33处理请求-5"><a class="markdownIt-Anchor" href="#33处理请求-5"></a> 3.3处理请求</h4>
<p>在AddressController类中编写请求处理方法.</p>
<p><strong>RestFul编写时不管参数名和占位符是否一致都必须加@PathVariable(“aid”)</strong></p>
<pre class="highlight"><code class="">//RestFul风格的请求编写
@RequestMapping(&quot;&#123;aid&#125;/set_default&quot;)
public JsonResult&lt;Void&gt; setDefault(
    @PathVariable(&quot;aid&quot;) Integer aid,HttpSession session) &#123;
    addressService.setDefault(
        aid,
        getUidFromSession(session),
        getUsernameFromSession(session));
    return new JsonResult&lt;&gt;(OK);
&#125;
</code></pre>
<p>启动服务,登录账号后在地址栏输入http://localhost:8080/addresses/8/set_default进行测试</p>
<h3 id="4设置默认收货地址-前端页面"><a class="markdownIt-Anchor" href="#4设置默认收货地址-前端页面"></a> 4.设置默认收货地址-前端页面</h3>
<p>观察address.html代码发现&quot;设为默认&quot;按钮没有id属性,那应该怎么获取&quot;设为默认&quot;按钮以监听是否被点击了呢?</p>
<p>法一:给&quot;设为默认&quot;的标签添加id属性(我觉得不对,因为id必须是唯一的,如果给该按钮加id属性,那么该用户有几个收货地址就会给几个按钮加同样的id,这显然不对,我认为可以用按钮上本就存在的class属性)。</p>
<p>法二:给&quot;设置默认&quot;按钮添加一个onclick属性,指向一个方法的调用,在这个方法中来完成ajax请求的方法</p>
<p>在这里用第二种方法:</p>
<p>1.展示用户收货地址数据列表的js函数中用for循环给页面增加地址数据的tr标签,我们需要在for循环中为每一个tr标签增加onclick属性并指向setDefault(#{aid})函数,括号里面占位符是为了给外部的setDefault函数传参,可以随便写,只要给占位符赋值时对应就可以了,.<strong>注意,即使调用的是无参函数也要加括号</strong></p>
<pre class="highlight"><code class="">&lt;td&gt;&lt;a onclick=&quot;setDefault(#&#123;aid&#125;)&quot; class=&quot;btn btn-xs add-def btn-default&quot;&gt;设为默认&lt;/a&gt;&lt;/td&gt;
</code></pre>
<p>2.在for循环中为占位符赋值:</p>
<pre class="highlight"><code class="">tr = tr.replace(&quot;#&#123;aid&#125;&quot;,list[i].aid);
</code></pre>
<p>3.完成setDefault方法的声明</p>
<pre class="highlight"><code class="">function setDefault(aid) &#123;
    $.ajax(&#123;
        url: &quot;/addresses/&quot;+aid+&quot;/set_default&quot;,
        type: &quot;POST&quot;,
        //data: $(&quot;#form-change-password&quot;).serialize(),
        dataType: &quot;JSON&quot;,
        success: function (json) &#123;
            if (json.state == 200) &#123;
                //重新加载收货地址列表页面
                showAddressList();
            &#125; else &#123;
                alert(&quot;设置默认收货地址失败&quot;)
            &#125;
        &#125;,
        error: function (xhr) &#123;
            alert(&quot;设置默认收货地址时产生未知的异常!&quot;+xhr.message);
        &#125;
    &#125;);
&#125;
</code></pre>
<h2 id="删除收货地址"><a class="markdownIt-Anchor" href="#删除收货地址"></a> 删除收货地址</h2>
<h3 id="1删除收货地址-持久层"><a class="markdownIt-Anchor" href="#1删除收货地址-持久层"></a> 1.删除收货地址-持久层</h3>
<h4 id="11规划需要执行的sql语句-4"><a class="markdownIt-Anchor" href="#11规划需要执行的sql语句-4"></a> 1.1规划需要执行的SQL语句</h4>
<p>1.在删除之前判断该数据是否存在,需要执行查询语句看能否查到该数据,还需要根据返回的aid获取uid并和session中的uid进行比较判断归属是否正确,这一条SQL语句在设置收货地址时已经开发,无需重复开发</p>
<p>2.开发执行删除的SQL语句</p>
<pre class="highlight"><code class="">delete from t_address where aid=?
</code></pre>
<p>3.需要判断删除的地址是否是默认地址(使用aid查询到的地址对象的getIsDefault方法),如果判断出删的是默认地址,则还需要定义把哪个地址设为默认,这里定义最新修改的为默认地址.</p>
<p>开发该SQL语句</p>
<pre class="highlight"><code class="">select * from t_address where uid=? order by modified_time DESC limit 0,1
</code></pre>
<p><strong>其中limit 0,1表示查询到的第一条数据(limit (n-1),pageSize),这样查询后就只会获得第一条数据</strong></p>
<p>4.如果用户本身就只有一条地址,那么删除后其他操作就可以不进行了,所以需要查询该用户的所有地址数量,在设置收货地址时已经开发,无需重复开发</p>
<h4 id="12设计接口和抽象方法-6"><a class="markdownIt-Anchor" href="#12设计接口和抽象方法-6"></a> 1.2设计接口和抽象方法</h4>
<p>在AddressMapper接口中进行抽象方法的设计</p>
<pre class="highlight"><code class="">/**
 * 根据收货地址id删除收货地址数据
 * @param aid 收货地址的id
 * @return 受影响的行数
 */
Integer deleteByAid(Integer aid);

/**
 * 根据用户uid查询用户最后一次被修改的收货地址数据
 * @param uid 用户id
 * @return 收货地址数据
 */
Address findLastModified(Integer uid);
</code></pre>
<h4 id="13编写映射-6"><a class="markdownIt-Anchor" href="#13编写映射-6"></a> 1.3编写映射</h4>
<p>在AddressMapper.xml文件中进行映射</p>
<pre class="highlight"><code class="">&lt;delete id=&quot;deleteByAid&quot;&gt;
    delete from t_address where aid=#&#123;aid&#125;
&lt;/delete&gt;

&lt;select id=&quot;findLastModified&quot; resultMap=&quot;AddressEntityMap&quot;&gt;
    select * from t_address
    where uid=#&#123;uid&#125;
    order by modified_time DESC limit 0,1
&lt;/select&gt;
</code></pre>
<h4 id="14单元测试-6"><a class="markdownIt-Anchor" href="#14单元测试-6"></a> 1.4单元测试</h4>
<pre class="highlight"><code class="">@Test
public void deleteByAid() &#123;
    addressMapper.deleteByAid(11);
&#125;

@Test
public void findLastModified() &#123;
    System.out.println(addressMapper.findLastModified(11));
&#125;
&#125;
</code></pre>
<h3 id="2删除收货地址-业务层"><a class="markdownIt-Anchor" href="#2删除收货地址-业务层"></a> 2.删除收货地址-业务层</h3>
<h4 id="21规划异常-8"><a class="markdownIt-Anchor" href="#21规划异常-8"></a> 2.1规划异常</h4>
<ul>
<li>
<p>可能没有该条地址数据(已开发)</p>
</li>
<li>
<p>可能地址数据归属错误(已开发)</p>
</li>
<li>
<p>在执行删除的时候可能会产生未知的异常导致数据不能够删除成功,则抛出DeleteException异常,在service创建该异常并使其继承业务层异常</p>
</li>
</ul>
<pre class="highlight"><code class="">/**删除数据时产生的异常*/
public class DeleteException extends ServiceException&#123;
    /**重写ServiceException的所有构造方法*/
&#125;
</code></pre>
<h4 id="22设计接口和抽象方法及实现-8"><a class="markdownIt-Anchor" href="#22设计接口和抽象方法及实现-8"></a> 2.2设计接口和抽象方法及实现</h4>
<p>1.在IAddressService接口中定义抽象方法</p>
<p>需要给抽象方法声明哪些参数呢:</p>
<blockquote>
<p>根据分析可得,该抽象方法的实现依赖于持久层的以下方法:</p>
<p>1.findByAid:查询该条地址数据是否存在,参数是aid</p>
<p>3.deleteByAid:删除地址数据,参数是aid</p>
<p>5.countByUid:统计用户地址数量,参数是uid</p>
<p>6.findLastModified:查询得到最后修改的一条地址,参数是uid</p>
<p>7.updateDefaultByAid:设置默认收货地址,参数是aid,modifiedUser,modifiedTime</p>
<p>稍加分析可以得出接下来定义的抽象方法的参数是:aid,uid,username</p>
</blockquote>
<p><strong>把上面的分析补上:2.判断地址数据归属是否正确4.判断删除的是否是默认地址.这七步就是业务层完整的开发流程</strong></p>
<pre class="highlight"><code class="">/**
* 删除用户选中的收货地址数据
* @param aid 收货地址id
* @param uid 用户id
* @param username 用户名
*/
void delete(Integer aid,Integer uid,String username);
</code></pre>
<p>2.实现该抽象方法</p>
<pre class="highlight"><code class="">@Override
public void delete(Integer aid, Integer uid, String username) &#123;
    Address result = addressMapper.findByAid(aid);
    //1.
    if (result == null) &#123;
        throw new AddressNotFoundException(&quot;收货地址数据不存在&quot;);
    &#125;
    //2.
    if (!result.getUid().equals(uid)) &#123;
        throw new AccessDeniedException(&quot;非法数据访问&quot;);
    &#125;
    //3.
    Integer rows = addressMapper.deleteByAid(aid);
    if (rows != 1) &#123;
        throw new DeleteException(&quot;删除数据时产生未知的异常&quot;);
    &#125;
    //4.如果删除的是非默认地址则不需要再做后面的任何操作,终止程序
    if (result.getIsDefault() == 0) &#123;
        return;
    &#125;
    //5.
    Integer count = addressMapper.countByUid(uid);
    if (count == 0) &#123;
        return;
    &#125;
    //6.
    Address address = addressMapper.findLastModified(uid);
    //7.
    rows = addressMapper.updateDefaultByAid(address.getAid(), username, new Date());
    if (rows != 1) &#123;
        throw new UpdateException(&quot;更新数据时产生未知的异常&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="23单元测试-8"><a class="markdownIt-Anchor" href="#23单元测试-8"></a> 2.3单元测试</h4>
<pre class="highlight"><code class="">@Test
public void delete() &#123;
    addressService.delete(1,11,&quot;4.11删除&quot;);
&#125;
</code></pre>
<h3 id="3删除收货地址-控制层"><a class="markdownIt-Anchor" href="#3删除收货地址-控制层"></a> 3.删除收货地址-控制层</h3>
<h4 id="31处理异常-6"><a class="markdownIt-Anchor" href="#31处理异常-6"></a> 3.1处理异常</h4>
<p>需要在BaseController类中处理异常类</p>
<pre class="highlight"><code class="">else if (e instanceof DeleteException) &#123;
    result.setState(5002);
    result.setMessage(&quot;删除数据时产生未知的异常&quot;);
&#125;
</code></pre>
<h4 id="32设计请求-6"><a class="markdownIt-Anchor" href="#32设计请求-6"></a> 3.2设计请求</h4>
<ul>
<li>/addresses/{aid}/delete</li>
<li>POST</li>
<li>Integer aid,HttpSession session</li>
<li>JsonResult<Void></li>
</ul>
<h4 id="33处理请求-6"><a class="markdownIt-Anchor" href="#33处理请求-6"></a> 3.3处理请求</h4>
<pre class="highlight"><code class="">@RequestMapping(&quot;&#123;aid&#125;/delete&quot;)
public JsonResult&lt;Void&gt; delete(@PathVariable(&quot;aid&quot;) Integer aid,HttpSession session) &#123;
    addressService.delete(
        aid,
        getUidFromSession(session),
        getUsernameFromSession(session));
    return new JsonResult&lt;&gt;(OK);
&#125;
</code></pre>
<h4 id="34单元测试-4"><a class="markdownIt-Anchor" href="#34单元测试-4"></a> 3.4单元测试</h4>
<p>在AddressController类编写请求处理方法的实现</p>
<p>这个方法就只是调用业务层方法然后给前端返回一些信息,可以选择不用测试</p>
<h3 id="4删除收货地址-前端页面"><a class="markdownIt-Anchor" href="#4删除收货地址-前端页面"></a> 4.删除收货地址-前端页面</h3>
<p>处理该前端页面的所有步骤和处理&quot;设置默认收货地址&quot;的一样</p>
<p>1.给&quot;删除&quot;按钮添加onclick属性并指向deleteByAid(aid)方法</p>
<pre class="highlight"><code class="">&lt;td&gt;&lt;a onclick=&quot;delete(#&#123;aid&#125;)&quot; class=&quot;btn btn-xs add-del btn-info&quot;&gt;&lt;span class=&quot;fa fa-trash-o&quot;&gt;&lt;/span&gt; 删除&lt;/a&gt;&lt;/td&gt;
</code></pre>
<p>2.给占位符赋值</p>
<p>因为处理&quot;设置默认收货地址&quot;时已经编写tr = tr.replace(“#{aid}”,list[i].aid);用来给占位符#{aid}赋值,所以这里不需要再写.但是需要把replace改为replaceAll</p>
<p>3.完成deleteByAid(aid)方法的声明</p>
<pre class="highlight"><code class="">function setDefault(aid) &#123;
    $.ajax(&#123;
        url: &quot;/addresses/&quot;+aid+&quot;/set_default&quot;,
        type: &quot;POST&quot;,
        //data: $(&quot;#form-change-password&quot;).serialize(),
        dataType: &quot;JSON&quot;,
        success: function (json) &#123;
            if (json.state == 200) &#123;
                //重新加载收货地址列表页面
                showAddressList();
            &#125; else &#123;
                alert(&quot;删除收货地址失败&quot;)
            &#125;
        &#125;,
        error: function (xhr) &#123;
            alert(&quot;删除收货地址时产生未知的异常!&quot;+xhr.message);
        &#125;
    &#125;);
&#125;
</code></pre>
<h2 id="商品热销排行"><a class="markdownIt-Anchor" href="#商品热销排行"></a> 商品热销排行</h2>
<h3 id="1创建数据表-4"><a class="markdownIt-Anchor" href="#1创建数据表-4"></a> 1.创建数据表</h3>
<p>1.在store数据库中创建t_product数据表</p>
<pre class="highlight"><code class="">CREATE TABLE t_product (
  id int(20) NOT NULL COMMENT '商品id',
  category_id int(20) DEFAULT NULL COMMENT '分类id',
  item_type varchar(100) DEFAULT NULL COMMENT '商品系列',
  title varchar(100) DEFAULT NULL COMMENT '商品标题',
  sell_point varchar(150) DEFAULT NULL COMMENT '商品卖点',
  price bigint(20) DEFAULT NULL COMMENT '商品单价',
  num int(10) DEFAULT NULL COMMENT '库存数量',
  image varchar(500) DEFAULT NULL COMMENT '图片路径',
  `status` int(1) DEFAULT '1' COMMENT '商品状态  1：上架   2：下架   3：删除',
  priority int(10) DEFAULT NULL COMMENT '显示优先级',
  created_time datetime DEFAULT NULL COMMENT '创建时间',
  modified_time datetime DEFAULT NULL COMMENT '最后修改时间',
  created_user varchar(50) DEFAULT NULL COMMENT '创建人',
  modified_user varchar(50) DEFAULT NULL COMMENT '最后修改人',
  PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre>
<p>2.向该表插入数据</p>
<pre class="highlight"><code class="">LOCK TABLES t_product WRITE;
INSERT INTO t_product VALUES (10000001,238,'牛皮纸记事本','广博(GuangBo)10本装40张A5牛皮纸记事本子日记本办公软抄本GBR0731','经典回顾！超值特惠！',23,99999,'/images/portal/00GuangBo1040A5GBR0731/',1,62,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),等等等等;
UNLOCK TABLES;
</code></pre>
<h3 id="2创建商品的实体类"><a class="markdownIt-Anchor" href="#2创建商品的实体类"></a> 2.创建商品的实体类</h3>
<p>创建Product实体类并使其继承BaseEntity类</p>
<pre class="highlight"><code class="">/** 商品数据的实体类 */
public class Product extends BaseEntity &#123;
    private Integer id;
    private Integer categoryId;
    private String itemType;
    private String title;
    private String sellPoint;
    private Long price;
    private Integer num;
    private String image;
    private Integer status;
    private Integer priority;
 /**
 * get,set
 * equals和hashCode
 * toString
 */
&#125;
</code></pre>
<h3 id="3商品热销排行-持久层"><a class="markdownIt-Anchor" href="#3商品热销排行-持久层"></a> 3.商品热销排行-持久层</h3>
<h4 id="31-规划需要执行的sql语句"><a class="markdownIt-Anchor" href="#31-规划需要执行的sql语句"></a> 3.1 规划需要执行的SQL语句</h4>
<p>查询热销商品列表的SQL语句</p>
<pre class="highlight"><code class="">SELECT * FROM t_product WHERE status=1 ORDER BY priority DESC LIMIT 0,4
</code></pre>
<h4 id="32-设计接口和抽象方法"><a class="markdownIt-Anchor" href="#32-设计接口和抽象方法"></a> 3.2 设计接口和抽象方法</h4>
<p>在mapper包下创建ProductMapper接口并在接口中添加查询热销商品findHotList()的方法</p>
<pre class="highlight"><code class="">public interface ProductMapper &#123;
    /**
     * 查询热销商品的前四名
     * @return 热销商品前四名的集合
     */
    List&lt;Product&gt; findHotList();
&#125;
</code></pre>
<h4 id="33-编写映射"><a class="markdownIt-Anchor" href="#33-编写映射"></a> 3.3 编写映射</h4>
<p>在main\resources\mapper文件夹下创建ProductMapper.xml文件，并在文件中配置findHotList()方法的映射</p>
<pre class="highlight"><code class="">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.cy.store.mapper.ProductMapper&quot;&gt;
    &lt;resultMap id=&quot;ProductEntityMap&quot; type=&quot;com.cy.store.entity.Product&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;category_id&quot; property=&quot;categoryId&quot;/&gt;
        &lt;result column=&quot;item_type&quot; property=&quot;itemType&quot;/&gt;
        &lt;result column=&quot;sell_point&quot; property=&quot;sellPoint&quot;/&gt;
        &lt;result column=&quot;created_user&quot; property=&quot;createdUser&quot;/&gt;
        &lt;result column=&quot;created_time&quot; property=&quot;createdTime&quot;/&gt;
        &lt;result column=&quot;modified_user&quot; property=&quot;modifiedUser&quot;/&gt;
        &lt;result column=&quot;modified_time&quot; property=&quot;modifiedTime&quot;/&gt;
    &lt;/resultMap&gt;
    
    &lt;select id=&quot;findHotList&quot; resultMap=&quot;ProductEntityMap&quot;&gt;
        select * from t_product where status=1 order by priority desc limit 0,4
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="4商品热销排行-业务层"><a class="markdownIt-Anchor" href="#4商品热销排行-业务层"></a> 4.商品热销排行-业务层</h3>
<h4 id="41-规划异常"><a class="markdownIt-Anchor" href="#41-规划异常"></a> 4.1 规划异常</h4>
<blockquote>
<p>只要是查询,不涉及到增删改的,都没有异常,无非就是没有该数据然后返回空</p>
</blockquote>
<h4 id="42-设计接口和抽象方法及实现"><a class="markdownIt-Anchor" href="#42-设计接口和抽象方法及实现"></a> 4.2 设计接口和抽象方法及实现</h4>
<p>1.创建IProductService接口，并在接口中添加findHotList()方法</p>
<pre class="highlight"><code class="">public interface IProductService &#123;
    /**
     * 查询热销商品的前四名
     * @return 热销商品前四名的集合
     */
    List&lt;Product&gt; findHotList();
&#125;
</code></pre>
<p>2.在业务层创建ProductServiceImpl类并实现该方法</p>
<pre class="highlight"><code class="">package com.cy.store.service.impl;
import com.cy.store.entity.Product;
import com.cy.store.mapper.ProductMapper;
import com.cy.store.service.IProductService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.List;

/** 处理商品数据的业务层实现类 */
@Service
public class ProductServiceImpl implements IProductService &#123;
    @Autowired
    private ProductMapper productMapper;

    @Override
    public List&lt;Product&gt; findHotList() &#123;
        List&lt;Product&gt; list = productMapper.findHotList();
        for (Product product : list) &#123;
            product.setPriority(null);
            product.setCreatedUser(null);
            product.setCreatedTime(null);
            product.setModifiedUser(null);
            product.setModifiedTime(null);
        &#125;
        return list;
    &#125;
&#125;
</code></pre>
<h3 id="5商品热销排行-控制层"><a class="markdownIt-Anchor" href="#5商品热销排行-控制层"></a> 5.商品热销排行-控制层</h3>
<h4 id="51-处理异常"><a class="markdownIt-Anchor" href="#51-处理异常"></a> 5.1 处理异常</h4>
<blockquote>
<p>无异常。</p>
</blockquote>
<h4 id="52-设计请求"><a class="markdownIt-Anchor" href="#52-设计请求"></a> 5.2 设计请求</h4>
<ul>
<li>/products/hot_list</li>
<li>GET</li>
<li>不需要请求参数</li>
<li>JsonResult&lt;List<Product>&gt;</li>
</ul>
<h4 id="53-处理请求"><a class="markdownIt-Anchor" href="#53-处理请求"></a> 5.3 处理请求</h4>
<p>1.创建ProductController类并使其继承BaseController类,在类中编写处理请求的方法</p>
<pre class="highlight"><code class="">@RestController
@RequestMapping(&quot;products&quot;)
public class ProductController extends BaseController &#123;
    @Autowired
    private IProductService productService;

    @RequestMapping(&quot;hot_list&quot;)
    public JsonResult&lt;List&lt;Product&gt;&gt; getHotList() &#123;
        List&lt;Product&gt; data = productService.findHotList();
        return new JsonResult&lt;List&lt;Product&gt;&gt;(OK, data);
    &#125;
&#125;

</code></pre>
<p>2.为了能不登录也可以访问该数据,需要将products/**请求添加到白名单中:</p>
<p>在LoginInterceptorConfigure类的addInterceptors方法中添加代码:</p>
<pre class="highlight"><code class="">patterns.add(&quot;/products/**&quot;);
</code></pre>
<h3 id="6商品-热销排行-前端页面"><a class="markdownIt-Anchor" href="#6商品-热销排行-前端页面"></a> 6.商品-热销排行-前端页面</h3>
<p>1.在index.html页面给“热销排行”列表的div标签设置id属性值</p>
<pre class="highlight"><code class="">&lt;div id=&quot;hot-list&quot; class=&quot;panel-body panel-item&quot;&gt;
&lt;!-- ... --&gt;
&lt;/div&gt;
</code></pre>
<p>2.在index.html页面中添加展示热销排行商品的js代码</p>
<pre class="highlight"><code class="">&lt;script type=&quot;text/javascript&quot;&gt;
    $(document).ready(function() &#123;
    showHotList();
&#125;);

function showHotList() &#123;
    $(&quot;#hot-list&quot;).empty();
    $.ajax(&#123;
        url: &quot;/products/hot_list&quot;,
        type: &quot;GET&quot;,
        dataType: &quot;JSON&quot;,
        success: function(json) &#123;
            var list = json.data;
            for (var i = 0; i &lt; list.length; i++) &#123;
                console.log(list[i].title);//调试用
                var html = '&lt;div class=&quot;col-md-12&quot;&gt;'
                + '&lt;div class=&quot;col-md-7 text-row-2&quot;&gt;&lt;a href=&quot;product.html?id=#&#123;id&#125;&quot;&gt;#&#123;title&#125;&lt;/a&gt;&lt;/div&gt;'
                + '&lt;div class=&quot;col-md-2&quot;&gt;¥#&#123;price&#125;&lt;/div&gt;'
                + '&lt;div class=&quot;col-md-3&quot;&gt;&lt;img src=&quot;..#&#123;image&#125;collect.png&quot; class=&quot;img-responsive&quot; /&gt;&lt;/div&gt;'
                + '&lt;/div&gt;';

                html = html.replace(/#&#123;id&#125;/g, list[i].id);
                html = html.replace(/#&#123;title&#125;/g, list[i].title);
                html = html.replace(/#&#123;price&#125;/g, list[i].price);
                html = html.replace(/#&#123;image&#125;/g, list[i].image);

                $(&quot;#hot-list&quot;).append(html);
            &#125;
        &#125;
    &#125;);
&#125;
&lt;/script&gt;
</code></pre>
<p>关于image标签里面的属性src=“…#{image}collect.png” class=“img-responsive”</p>
<ul>
<li>…代表跳到父文件夹,即index.html的父文件夹static</li>
<li>…后面和collect前面不需要单斜杠,因为数据库中图片地址的数据前面后面加的有</li>
</ul>
<p>关于a标签里面的href=“product.html?id=#{id}”</p>
<ul>
<li>这里是为了点击超链接进入商品详情页时可以把商品id传给详情页,使两个页面形成联系</li>
</ul>
<h2 id="显示商品详情"><a class="markdownIt-Anchor" href="#显示商品详情"></a> 显示商品详情</h2>
<h3 id="1显示商品详情-持久层"><a class="markdownIt-Anchor" href="#1显示商品详情-持久层"></a> 1.显示商品详情-持久层</h3>
<h4 id="11规划需要执行的sql语句-5"><a class="markdownIt-Anchor" href="#11规划需要执行的sql语句-5"></a> 1.1规划需要执行的SQL语句</h4>
<p>根据商品id显示商品详情的SQL语句</p>
<pre class="highlight"><code class="">SELECT * FROM t_product WHERE id=?
</code></pre>
<h4 id="12设计接口和抽象方法-7"><a class="markdownIt-Anchor" href="#12设计接口和抽象方法-7"></a> 1.2设计接口和抽象方法</h4>
<p>在ProductMapper接口中添加抽象方法</p>
<pre class="highlight"><code class="">/**
 * 根据商品id查询商品详情
 * @param id 商品id
 * @return 匹配的商品详情，如果没有匹配的数据则返回null
 */
Product findById(Integer id);
</code></pre>
<h4 id="13编写映射-7"><a class="markdownIt-Anchor" href="#13编写映射-7"></a> 1.3编写映射</h4>
<p>在ProductMapper.xml文件中配置findById(Integer id)方法的映射</p>
<pre class="highlight"><code class="">&lt;select id=&quot;findById&quot; resultMap=&quot;ProductEntityMap&quot;&gt;
    select * from t_product where id=#&#123;id&#125;
&lt;/select&gt;
</code></pre>
<h3 id="2显示商品详情-业务层"><a class="markdownIt-Anchor" href="#2显示商品详情-业务层"></a> 2.显示商品详情-业务层</h3>
<h4 id="21规划异常-9"><a class="markdownIt-Anchor" href="#21规划异常-9"></a> 2.1规划异常</h4>
<p>如果商品数据不存在，应该抛出ProductNotFoundException，所以创建ProductNotFoundException异常类并使其继承ServiceException</p>
<pre class="highlight"><code class="">/** 商品数据不存在的异常 */
public class ProductNotFoundException extends ServiceException &#123;
    /**重写ServiceException的所有构造方法*/
&#125;
</code></pre>
<h4 id="22设计接口和抽象方法及实现-9"><a class="markdownIt-Anchor" href="#22设计接口和抽象方法及实现-9"></a> 2.2设计接口和抽象方法及实现</h4>
<p>1.在业务层IProductService接口中添加findById(Integer id)抽象方法</p>
<pre class="highlight"><code class="">/**
 * 根据商品id查询商品详情
 * @param id 商品id
 * @return 匹配的商品详情，如果没有匹配的数据则返回null
 */
Product findById(Integer id);
</code></pre>
<p>2.在ProductServiceImpl类中，实现接口中的findById(Integer id)抽象方法</p>
<pre class="highlight"><code class="">@Override
public Product findById(Integer id) &#123;
    Product product = productMapper.findById(id);
    // 判断查询结果是否为null
    if (product == null) &#123;
        throw new ProductNotFoundException(&quot;尝试访问的商品数据不存在&quot;);
    &#125;
    // 将查询结果中的部分属性设置为null
    product.setPriority(null);
    product.setCreatedUser(null);
    product.setCreatedTime(null);
    product.setModifiedUser(null);
    product.setModifiedTime(null);

    return product;
&#125;
</code></pre>
<h3 id="3显示商品详情-控制层"><a class="markdownIt-Anchor" href="#3显示商品详情-控制层"></a> 3.显示商品详情-控制层</h3>
<h4 id="31处理异常-7"><a class="markdownIt-Anchor" href="#31处理异常-7"></a> 3.1处理异常</h4>
<p>在BaseController类中的handleException()方法中添加处理ProductNotFoundException的异常</p>
<pre class="highlight"><code class="">else if (e instanceof ProductNotFoundException) &#123;
result.setState(4006);
    result.setMessage(&quot;访问的商品数据不存在的异常&quot;);
&#125;
</code></pre>
<h4 id="32-设计请求"><a class="markdownIt-Anchor" href="#32-设计请求"></a> 3.2 设计请求</h4>
<ul>
<li>/products/{id}/details</li>
<li>Integer id</li>
<li>GET</li>
<li>JsonResult<Product></li>
</ul>
<h4 id="33处理请求-7"><a class="markdownIt-Anchor" href="#33处理请求-7"></a> 3.3处理请求</h4>
<p>在ProductController类中添加处理请求的getById()方法</p>
<pre class="highlight"><code class="">@GetMapping(&quot;&#123;id&#125;/details&quot;)
public JsonResult&lt;Product&gt; getById(@PathVariable(&quot;id&quot;) Integer id) &#123;
    Product data = productService.findById(id);
    return new JsonResult&lt;Product&gt;(OK, data);
&#125;
</code></pre>
<h3 id="4显示商品详情-前端页面"><a class="markdownIt-Anchor" href="#4显示商品详情-前端页面"></a> 4.显示商品详情-前端页面</h3>
<p>1.首页将商品id发送给详情页后,详情页需要从url中裁取获得该id,实现方法在jquery-getUrlParam.js中(目前怎么实现裁取可以先不学),所以需要在product.html页面中导入该js文件,这里我在body标签内部的最后引入该js文件</p>
<pre class="highlight"><code class="">&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-getUrlParam.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>2.在product.html页面中body标签内部的最后添加获取当前商品详情的代码</p>
<pre class="highlight"><code class="">&lt;script type=&quot;text/javascript&quot;&gt;
            //调用jquery-getUrlParam.js文件的getUrlParam方法获取商品id
            var id = $.getUrlParam(&quot;id&quot;);
            console.log(&quot;id=&quot; + id);
            $(document).ready(function() &#123;
                $.ajax(&#123;
                    url: &quot;/products/&quot; + id + &quot;/details&quot;,
                    type: &quot;GET&quot;,
                    dataType: &quot;JSON&quot;,
                    success: function(json) &#123;
                        if (json.state == 200) &#123;
                            console.log(&quot;title=&quot; + json.data.title);
                            //html()方法:
                            // 假设有个标签&lt;div id=&quot;a&quot;&gt;&lt;/div&gt;
                            //那么$(&quot;#a&quot;).html(&lt;p&gt;&lt;/p&gt;)就是给该div标签加p标签
                            //$(&quot;#a&quot;).html(&quot;我爱中国&quot;)就是给该div标签填充&quot;我爱中国&quot;内容
                            $(&quot;#product-title&quot;).html(json.data.title);
                            $(&quot;#product-sell-point&quot;).html(json.data.sellPoint);
                            $(&quot;#product-price&quot;).html(json.data.price);

                            for (var i = 1; i &lt;= 5; i++) &#123;
                                $(&quot;#product-image-&quot; + i + &quot;-big&quot;).attr(&quot;src&quot;, &quot;..&quot; + json.data.image + i + &quot;_big.png&quot;);
                                $(&quot;#product-image-&quot; + i).attr(&quot;src&quot;, &quot;..&quot; + json.data.image + i + &quot;.jpg&quot;);
                            &#125;
                        &#125; else if (json.state == 4006) &#123; // 商品数据不存在的异常
                            location.href = &quot;index.html&quot;;
                        &#125; else &#123;
                            alert(&quot;获取商品信息失败！&quot; + json.message);
                        &#125;
                    &#125;
                &#125;);
            &#125;);
        &lt;/script&gt;
</code></pre>
<h2 id="加入购物车"><a class="markdownIt-Anchor" href="#加入购物车"></a> 加入购物车</h2>
<h3 id="1创建数据表-5"><a class="markdownIt-Anchor" href="#1创建数据表-5"></a> 1.创建数据表</h3>
<p>1.使用use命令先选中store数据库</p>
<pre class="highlight"><code class="">USE store;
</code></pre>
<p>2.在store数据库中创建t_cart用户数据表</p>
<pre class="highlight"><code class="">CREATE TABLE t_cart (
cid INT AUTO_INCREMENT COMMENT '购物车数据id',
uid INT NOT NULL COMMENT '用户id',
pid INT NOT NULL COMMENT '商品id',
price BIGINT COMMENT '加入时商品单价',
num INT COMMENT '商品数量',
created_user VARCHAR(20) COMMENT '创建人',
created_time DATETIME COMMENT '创建时间',
modified_user VARCHAR(20) COMMENT '修改人',
modified_time DATETIME COMMENT '修改时间',
PRIMARY KEY (cid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre>
<h3 id="2创建购物车的实体类"><a class="markdownIt-Anchor" href="#2创建购物车的实体类"></a> 2.创建购物车的实体类</h3>
<p>在entity包下创建购物车的Cart实体类并使其继承BaseEntity</p>
<pre class="highlight"><code class="">/**购物车数据的实体类*/
public class Cart extends BaseEntity &#123;
    private Integer cid;
    private Integer uid;
    private Integer pid;
    private Long price;
    private Integer num;
/**
 * get,set
 * equals和hashCode
 * toString
 */
&#125;
</code></pre>
<h3 id="3加入购物车-持久层"><a class="markdownIt-Anchor" href="#3加入购物车-持久层"></a> 3.加入购物车-持久层</h3>
<h4 id="31规划需要执行的sql语句-3"><a class="markdownIt-Anchor" href="#31规划需要执行的sql语句-3"></a> 3.1规划需要执行的SQL语句</h4>
<p>1.向购物车表中插入商品数据的SQL语句</p>
<pre class="highlight"><code class="">insert into t_cart (除了cid以外的所有字段) values (匹配的值列表);
</code></pre>
<p>2.如果当前商品已经在购物车存在,则直接更新商品即可</p>
<pre class="highlight"><code class="">update t_cart set num=? where cid=?
</code></pre>
<p>3.在插入或者更新具体执行哪个语句,取决于数据库中是否有当前的这个购物车商品的数据,需要查询语句才能确定</p>
<pre class="highlight"><code class="">select * from t_cart where uid=? and pid=?
</code></pre>
<h4 id="32设计接口和抽象方法-3"><a class="markdownIt-Anchor" href="#32设计接口和抽象方法-3"></a> 3.2设计接口和抽象方法</h4>
<p>在mapper包下创建CartMapper接口，并添加抽象方法</p>
<pre class="highlight"><code class="">public interface CartMapper &#123;
    
    /**
     * 插入购物车数据
     * @param cart 购物车数据
     * @return 受影响的行数
     */
    Integer insert(Cart cart);

    /**
     * 修改购物车数据中商品的数量
     * @param cid 购物车数据的id
     * @param num 新的数量
     * @param modifiedUser 修改执行人
     * @param modifiedTime 修改时间
     * @return 受影响的行数
     */
    Integer updateNumByCid(
            @Param(&quot;cid&quot;) Integer cid,
            @Param(&quot;num&quot;) Integer num,
            @Param(&quot;modifiedUser&quot;) String modifiedUser,
            @Param(&quot;modifiedTime&quot;) Date modifiedTime);

    /**
     * 根据用户id和商品id查询购物车中的数据
     * @param uid 用户id
     * @param pid 商品id
     * @return 匹配的购物车数据，如果该用户的购物车中并没有该商品，则返回null
     */
    Cart findByUidAndPid(
            @Param(&quot;uid&quot;) Integer uid,
            @Param(&quot;pid&quot;) Integer pid);
&#125;
</code></pre>
<h4 id="33编写映射-4"><a class="markdownIt-Anchor" href="#33编写映射-4"></a> 3.3编写映射</h4>
<p>在resources.mapper文件夹下创建CartMapper.xml文件，并在文件中配置以上三个方法的映射</p>
<pre class="highlight"><code class="">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.cy.store.mapper.CartMapper&quot;&gt;
    &lt;resultMap id=&quot;CartEntityMap&quot; type=&quot;com.cy.store.entity.Cart&quot;&gt;
        &lt;id column=&quot;cid&quot; property=&quot;cid&quot;/&gt;
        &lt;result column=&quot;created_user&quot; property=&quot;createdUser&quot;/&gt;
        &lt;result column=&quot;created_time&quot; property=&quot;createdTime&quot;/&gt;
        &lt;result column=&quot;modified_user&quot; property=&quot;modifiedUser&quot;/&gt;
        &lt;result column=&quot;modified_time&quot; property=&quot;modifiedTime&quot;/&gt;
    &lt;/resultMap&gt;

    &lt;!-- 插入购物车数据--&gt;
    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;cid&quot;&gt;
        insert into t_cart (uid, pid, price, num, created_user, created_time, modified_user, modified_time)
        values (#&#123;uid&#125;, #&#123;pid&#125;, #&#123;price&#125;, #&#123;num&#125;, #&#123;createdUser&#125;, #&#123;createdTime&#125;, #&#123;modifiedUser&#125;, #&#123;modifiedTime&#125;)
    &lt;/insert&gt;

    &lt;!-- 修改购物车数据中商品的数量--&gt;
    &lt;update id=&quot;updateNumByCid&quot;&gt;
        update t_cart set
            num=#&#123;num&#125;,
            modified_user=#&#123;modifiedUser&#125;,
            modified_time=#&#123;modifiedTime&#125;
        where cid=#&#123;cid&#125;
    &lt;/update&gt;

    &lt;!-- 根据用户id和商品id查询购物车中的数据--&gt;
    &lt;select id=&quot;findByUidAndPid&quot; resultMap=&quot;CartEntityMap&quot;&gt;
        select * from t_cart where uid=#&#123;uid&#125; AND pid=#&#123;pid&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h4 id="34单元测试-5"><a class="markdownIt-Anchor" href="#34单元测试-5"></a> 3.4单元测试</h4>
<p>创建CartMapperTests测试类进行测试</p>
<pre class="highlight"><code class="">@RunWith(SpringRunner.class)
@SpringBootTest
public class CartMapperTests &#123;
    @Autowired
    private CartMapper cartMapper;

    @Test
    public void insert() &#123;
        Cart cart = new Cart();
        cart.setUid(11);
        cart.setPid(10000001);
        cart.setNum(3);
        cart.setPrice(4L);//长整型
        cartMapper.insert(cart);
    &#125;

    @Test
    public void updateNumByCid() &#123;
        cartMapper.updateNumByCid(1, 4, &quot;张三&quot;, new Date());
    &#125;

    @Test
    public void findByUidAndPid() &#123;
        Cart cart = cartMapper.findByUidAndPid(11, 10000001);
        System.out.println(cart);
    &#125;
&#125;
</code></pre>
<h3 id="4加入购物车-业务层"><a class="markdownIt-Anchor" href="#4加入购物车-业务层"></a> 4.加入购物车-业务层</h3>
<h4 id="41规划异常-4"><a class="markdownIt-Anchor" href="#41规划异常-4"></a> 4.1规划异常</h4>
<p>在插入数据时，可能抛出InsertException异常；在修改数据时，可能抛出UpdateException异常.这两个异常已开发</p>
<h4 id="42设计接口和抽象方法及实现-3"><a class="markdownIt-Anchor" href="#42设计接口和抽象方法及实现-3"></a> 4.2设计接口和抽象方法及实现</h4>
<p>1.在com.cy.store.service包下创建ICartService接口，并添加抽象方法</p>
<p>该抽象方法都需要哪些参数呢,还是依据持久层,看持久层三条sql语句的实现需要什么参数:</p>
<blockquote>
<p>findByUidAndPid:查询购物车数据,参数是uid,pid</p>
<p>insert:插入购物车数据,参数是cart对象(属性有cid,uid,pid,price,num)</p>
<p>updateNumByCid:修改购物车中商品数量,参数是cid,num,modifiedUser,modifiedTime</p>
<p>price可以通过业务层中调用ProductMapper接口的findById获取,modifiedTime在业务层实现类的内部创建,所以需要的参数是uid,pid,num,username</p>
</blockquote>
<p>经过这次分析结合以前给业务层方法声明参数,可以发现<strong>即使持久层的方法参数是实体类对象,业务层的方法参数也大多不是实体类对象,因为实体类的部分属性是可以在业务层进行拼接然后封装到实体类对象中,再传给持久层(比如这里的price),这样的话就降低了前端传递数据的压力,如果该对象的所有方法都必须由前端传递过来,那么业务层方法参数可以是实体类对象(如注册用户时业务层的方法参数就是User对象)</strong></p>
<pre class="highlight"><code class="">public interface ICartService &#123;
    /**
     * 将商品添加到购物车
     * @param uid 当前登录用户的id
     * @param pid 商品的id
     * @param amount 增加的数量
     * @param username 当前登录的用户名
     */
    void addToCart(Integer uid, Integer pid, Integer amount, String username);
&#125;
</code></pre>
<p>2.创建CartServiceImpl类，并实现ICartService接口.在类中声明CartMapper持久层对象和IProductService处理商品数据的业务对象,并实现业务层的抽象方法</p>
<pre class="highlight"><code class="">@Service
public class CartServiceImpl implements ICartService &#123;
    /**购物车的业务层依赖于购物车的持久层以及商品的持久层*/
    @Autowired
    private CartMapper cartMapper;
    @Autowired
    private ProductMapper productMapper;

    @Override
    public void addToCart(Integer uid, Integer pid, Integer amount, String username) &#123;

        //根据参数pid和uid查询购物车中该商品是否已经存在
        Cart result = cartMapper.findByUidAndPid(uid, pid);

        Integer cid = result.getCid();
        Date date = new Date();
        if (result == null) &#123;
            Cart cart = new Cart();

            //封装数据：uid,pid,amount
            cart.setUid(uid);
            cart.setPid(pid);
            cart.setNum(amount);//注意前端传来amount时并没有和数据库商品数量进行求和

            //查询商品数据，得到商品价格并封装
            Product product = productMapper.findById(pid);
            cart.setPrice(product.getPrice());

            //封装数据：4个日志
            cart.setCreatedUser(username);
            cart.setCreatedTime(date);
            cart.setModifiedUser(username);
            cart.setModifiedTime(date);

            Integer rows = cartMapper.insert(cart);
            if (rows != 1) &#123;
                throw new InsertException(&quot;插入数据时出现未知异常&quot;);
            &#125;
        &#125; else &#123;
            //从查询结果中取出原数量，与参数amount相加，得到新的数量
            Integer num = result.getNum() + amount;//加入购物车时只会有+不可能有-

            Integer rows = cartMapper.updateNumByCid(
                result.getCid(),
                num,
                username,
                date);
            if (rows != 1) &#123;
                throw new InsertException(&quot;更新数据时产生未知异常&quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="43单元测试-4"><a class="markdownIt-Anchor" href="#43单元测试-4"></a> 4.3单元测试</h4>
<p>创建测试类CartServiceTests并编写测试方法。</p>
<pre class="highlight"><code class="">@RunWith(SpringRunner.class)
@SpringBootTest
public class CartServiceTests &#123;
    @Autowired
    private ICartService cartService;

    @Test
    public void addToCart() &#123;
        cartService.addToCart(11, 10000002, 5, &quot;Tom&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="5加入购物车-控制层"><a class="markdownIt-Anchor" href="#5加入购物车-控制层"></a> 5.加入购物车-控制层</h3>
<h4 id="51处理异常-2"><a class="markdownIt-Anchor" href="#51处理异常-2"></a> 5.1处理异常</h4>
<p>InsertException异常和UpdateException异常都已经设置到BaseController类中了,这里无需重复开发</p>
<h4 id="52设计请求-3"><a class="markdownIt-Anchor" href="#52设计请求-3"></a> 5.2设计请求</h4>
<ul>
<li>/carts/add_to_cart</li>
<li>post</li>
<li>Integer pid, Integer amount, HttpSession session</li>
<li>JsonResult<Void></li>
</ul>
<h4 id="53处理请求-3"><a class="markdownIt-Anchor" href="#53处理请求-3"></a> 5.3处理请求</h4>
<p>在controller包下创建CartController类并继承BaseController类,在类中添加处理请求的addToCart()方法</p>
<pre class="highlight"><code class="">@RestController
@RequestMapping(&quot;carts&quot;)
public class CartController extends BaseController &#123;
    @Autowired
    private ICartService cartService;

    @RequestMapping(&quot;add_to_cart&quot;)
    public JsonResult&lt;Void&gt; addToCart(Integer pid, Integer amount, HttpSession session) &#123;
        cartService.addToCart(
                getUidFromSession(session),
                pid,
                amount,
                getUsernameFromSession(session));
        return new JsonResult&lt;Void&gt;(OK);
    &#125;
&#125;
</code></pre>
<p>启动服务,登录账号后在地址栏输入http://localhost:8080/carts/add_to_cart?pid=10000002&amp;amount=5进行测试</p>
<h3 id="6加入购物车-前端页面"><a class="markdownIt-Anchor" href="#6加入购物车-前端页面"></a> 6.加入购物车-前端页面</h3>
<p>在product.html页面中的body标签内的script标签里为“加入购物车”按钮添加点击事件</p>
<p>回顾一下在ajax函数中data参数的数据设置的方式</p>
<ul>
<li>
<p>data:$(“选择的form表单”).serialize()。当需要提交的参数过多并且在同一个表单中时使用</p>
</li>
<li>
<p>data:new FormData($(“选择的form表单”)[0])。只适用提交文件</p>
</li>
<li>
<p>data:“username=TOM”。手动拼接,适合参数值固定并且参数值列表有限.等同于</p>
<pre class="highlight"><code class="">var user = &quot;控件某属性值或控件文本内容或自己声明的值&quot;
data: &quot;username=&quot;+user
</code></pre>
</li>
<li>
<p>使用JSON格式提交数据</p>
<pre class="highlight"><code class="">data: &#123;
    &quot;username&quot;: &quot;Tom&quot;,
    &quot;age&quot;: 18
&#125;
</code></pre>
</li>
<li>
<p>使用RestFul风格不属于前端给后端传参数</p>
</li>
</ul>
<blockquote>
<p>这里表单里面有很多无用参数,所以不使用表单提交</p>
</blockquote>
<pre class="highlight"><code class="">$(&quot;#btn-add-to-cart&quot;).click(function() &#123;
    $.ajax(&#123;
        url: &quot;/carts/add_to_cart&quot;,
        type: &quot;POST&quot;,
        data: &#123;
            &quot;pid&quot;: id,
            &quot;amount&quot;: $(&quot;#num&quot;).val()
        &#125;,
        dataType: &quot;JSON&quot;,
        success: function(json) &#123;
            if (json.state == 200) &#123;
                alert(&quot;增加成功！&quot;);
            &#125; else &#123;
                alert(&quot;增加失败！&quot; + json.message);
            &#125;
        &#125;,
        error: function(xhr) &#123;
            alert(&quot;您的登录信息已经过期，请重新登录！HTTP响应码：&quot; + xhr.status);
            location.href = &quot;login.html&quot;;
        &#125;
    &#125;);
&#125;);
</code></pre>
<p><strong>点击&quot;加入购物车&quot;按钮后页面跳转的实现:product.html导入的product.js文件里面实现了点击后跳转</strong></p>
<h2 id="显示购物车列表"><a class="markdownIt-Anchor" href="#显示购物车列表"></a> 显示购物车列表</h2>
<h3 id="1显示购物车列表-持久层"><a class="markdownIt-Anchor" href="#1显示购物车列表-持久层"></a> 1.显示购物车列表-持久层</h3>
<h4 id="11规划需要执行的sql语句-6"><a class="markdownIt-Anchor" href="#11规划需要执行的sql语句-6"></a> 1.1规划需要执行的SQL语句</h4>
<p>这里需要将商品表和购物车表进行连表查询</p>
<p>显示某用户的购物车列表数据的SQL语句大致是</p>
<pre class="highlight"><code class="">select
cid, #日后勾选购物车商品模块需要用到cid来确定勾选的是购物车表的哪一条数据

uid, #感觉没必要,因为uid可以从session中拿的呀,难道是为
#了后面提交购物车订单时判断提交的商品的uid和登录的uid是否一致?

pid, #日购提交订单模块需要用到pid来确定购买的是商品表的哪件商
#品,然后对商品表的该商品的库存,销售热度等信息进行修改

t_cart.price, #两个表都有该字段,需要指定获取的是哪个数据表的

t_cart.num, #两个表都有该字段且含义不同,需要指定获取的是哪个数据表的

title,

t_product.price as realPrice, #为了在购物车列表页展示两个价格的差值

image

from t_cart
left join t_product on t_cart.pid = t_product.id #把t_cart作为主表(老师说现在处理的是购物车表的数据所以让其为主表,我不明白)
where
uid = #&#123;uid&#125;
order by
t_cart.created_time desc #进行排序使最新加入购物车的在最上面
</code></pre>
<h4 id="12设计接口和抽象方法-8"><a class="markdownIt-Anchor" href="#12设计接口和抽象方法-8"></a> 1.2设计接口和抽象方法</h4>
<blockquote>
<p>VO全称Value Object,值对象。当进行select查询时,查询的结果属于多张表中的内容,此时发现结果集不能直接使用某个POJO实体类来接收,因为POJO实体类不能包含多表查询出来的信息,解决方式是:重新去构建一个新的对象,这个对象用于存储所查询出来的结果集对应的映射,所以把这个对象称之为值对象.</p>
</blockquote>
<p>在store包下创建一个vo包,在该包下面创建CartVO类,不需要继承BaseController类,那相应的就需要单独实现Serializable接口</p>
<pre class="highlight"><code class="">/** 购物车数据的Value Object类 */
public class CartVO implements Serializable &#123;
    private Integer cid;
    private Integer uid;
    private Integer pid;
    private Long price;
    private Integer num;
    private String title;
    private Long realPrice;
    private String image;
/**
 * get,set
 * equals和hashCode
 * toString
 */
&#125;
</code></pre>
<p>2.在CartMapper接口中添加抽象方法</p>
<pre class="highlight"><code class="">/**
 * 查询某用户的购物车数据
 * @param uid 用户id
 * @return 该用户的购物车数据的列表
 */
List&lt;CartVO&gt; findVOByUid(Integer uid);
</code></pre>
<h4 id="13编写映射-8"><a class="markdownIt-Anchor" href="#13编写映射-8"></a> 1.3编写映射</h4>
<p>1.在CartMapper.xml文件中添加findVOByUid()方法的映射</p>
<pre class="highlight"><code class="">&lt;!-- 查询某用户的购物车数据：List&lt;CartVO&gt; findVOByUid(Integer uid) --&gt;
&lt;select id=&quot;findVOByUid&quot; resultType=&quot;com.cy.store.vo.CartVO&quot;&gt;
    select
        cid,
        uid,
        pid,
        t_cart.price,
        t_cart.num,
        title,
        t_product.price as realPrice,
        image
    from t_cart
    left join t_product on t_cart.pid = t_product.id
    where
    uid = #&#123;uid&#125;
    order by
    t_cart.created_time desc
&lt;/select&gt;
</code></pre>
<h4 id="14单元测试-7"><a class="markdownIt-Anchor" href="#14单元测试-7"></a> 1.4单元测试</h4>
<p>在CartMapperTests测试类中添加findVOByUid()方法的测试</p>
<pre class="highlight"><code class="">@Test
public void findVOByUid() &#123;
    List&lt;CartVO&gt; list = cartMapper.findVOByUid(11);
    System.out.println(list);
&#125;
</code></pre>
<h3 id="2显示购物车列表-业务层"><a class="markdownIt-Anchor" href="#2显示购物车列表-业务层"></a> 2.显示购物车列表-业务层</h3>
<h4 id="21-规划异常"><a class="markdownIt-Anchor" href="#21-规划异常"></a> 2.1 规划异常</h4>
<p>查询不到就返回空,不需要规划异常</p>
<h4 id="22设计接口和抽象方法及实现-10"><a class="markdownIt-Anchor" href="#22设计接口和抽象方法及实现-10"></a> 2.2设计接口和抽象方法及实现</h4>
<p>1.在ICartService接口中添加findVOByUid()抽象方法</p>
<pre class="highlight"><code class="">/**
 * 查询某用户的购物车数据
 * @param uid 用户id
 * @return 该用户的购物车数据的列表
 */
List&lt;CartVO&gt; getVOByUid(Integer uid);
</code></pre>
<p>2.在CartServiceImpl类中重写业务接口中的抽象方法</p>
<pre class="highlight"><code class="">@Override
public List&lt;CartVO&gt; getVOByUid(Integer uid) &#123;
    return cartMapper.findVOByUid(uid);
&#125;
</code></pre>
<h4 id="23单元测试-9"><a class="markdownIt-Anchor" href="#23单元测试-9"></a> 2.3单元测试</h4>
<p>该业务层只是调用了持久层的方法并返回,可以不再测试</p>
<h3 id="3显示购物车列表-控制层"><a class="markdownIt-Anchor" href="#3显示购物车列表-控制层"></a> 3.显示购物车列表-控制层</h3>
<h4 id="31-处理异常"><a class="markdownIt-Anchor" href="#31-处理异常"></a> 3.1 处理异常</h4>
<p>业务层没有抛出异常,所以这里不需要处理异常</p>
<h4 id="32-设计请求-2"><a class="markdownIt-Anchor" href="#32-设计请求-2"></a> 3.2 设计请求</h4>
<ul>
<li>/carts/</li>
<li>GET</li>
<li>HttpSession session</li>
<li>JsonResult&lt;List<CartVO>&gt;</li>
</ul>
<h4 id="33-处理请求"><a class="markdownIt-Anchor" href="#33-处理请求"></a> 3.3 处理请求</h4>
<p>在CartController类中编写处理请求的代码。</p>
<pre class="highlight"><code class="">@RequestMapping(&#123;&quot;&quot;, &quot;/&quot;&#125;)
public JsonResult&lt;List&lt;CartVO&gt;&gt; getVOByUid(HttpSession session) &#123;
    List&lt;CartVO&gt; data = cartService.getVOByUid(getUidFromSession(session));
    return new JsonResult&lt;List&lt;CartVO&gt;&gt;(OK, data);
&#125;
</code></pre>
<p>启动服务,登录后在地址栏输入http://localhost:8080/carts进行测试</p>
<h3 id="4显示购物车列表-前端页面"><a class="markdownIt-Anchor" href="#4显示购物车列表-前端页面"></a> 4.显示购物车列表-前端页面</h3>
<p>1.将cart.html页面的head头标签内引入的cart.js文件注释掉(这个就是文件的功能:点击&quot;+“,”-&quot;,“删除”,&quot;全选&quot;等按钮时执行相应的操作)</p>
<pre class="highlight"><code class="">&lt;!-- &lt;script src=&quot;../js/cart.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; --&gt;
</code></pre>
<blockquote>
<p>多说一下,form标签的action=&quot;orderConfirm.html&quot;属性(规定表单数据提交到哪里)和结算按钮的类型&quot;type=submit&quot;是必不可少的,这样点击&quot;结算&quot;时才能将数据传给&quot;确认订单页&quot;并在&quot;确认订单页&quot;展示选中的商品数据</p>
<p>当然也可以把这两个删掉,然后给结算按钮添加&quot;type=button&quot;然后给该按钮绑定一个点击事件实现页面跳转和数据传递,但是这样太麻烦了</p>
</blockquote>
<p>2.在cart.html页面body标签内的script标签中编写展示购物车列表的代码</p>
<pre class="highlight"><code class="">&lt;script type=&quot;text/javascript&quot;&gt;
    $(document).ready(function() &#123;
    showCartList();
&#125;);

    //展示购物车列表数据
    function showCartList() &#123;
        $(&quot;#cart-list&quot;).empty();
        $.ajax(&#123;
            url: &quot;/carts&quot;,
            type: &quot;GET&quot;,
            dataType: &quot;JSON&quot;,
            success: function(json) &#123;
                var list = json.data;
                for (var i = 0; i &lt; list.length; i++) &#123;
                    var tr = '&lt;tr&gt;\n' +
                        '&lt;td&gt;\n' +
                        '&lt;input name=&quot;cids&quot; value=&quot;#&#123;cid&#125;&quot; type=&quot;checkbox&quot; class=&quot;ckitem&quot; /&gt;\n' +
                        '&lt;/td&gt;\n' +
                        '&lt;td&gt;&lt;img src=&quot;..#&#123;image&#125;collect.png&quot; class=&quot;img-responsive&quot; /&gt;&lt;/td&gt;\n' +
                        '&lt;td&gt;#&#123;title&#125;#&#123;msg&#125;&lt;/td&gt;\n' +
                        '&lt;td&gt;¥&lt;span id=&quot;goodsPrice#&#123;cid&#125;&quot;&gt;#&#123;singlePrice&#125;&lt;/span&gt;&lt;/td&gt;\n' +
                        '&lt;td&gt;\n' +
                        '&lt;input type=&quot;button&quot; value=&quot;-&quot; class=&quot;num-btn&quot; οnclick=&quot;reduceNum(1)&quot; /&gt;\n' +
                        '&lt;input id=&quot;goodsCount#&#123;cid&#125;&quot; type=&quot;text&quot; size=&quot;2&quot; readonly=&quot;readonly&quot; class=&quot;num-text&quot; value=&quot;#&#123;num&#125;&quot;&gt;\n' +
                        '&lt;input class=&quot;num-btn&quot; type=&quot;button&quot; value=&quot;+&quot; οnclick=&quot;addNum(#&#123;cid&#125;)&quot; /&gt;\n' +
                        '&lt;/td&gt;\n' +
                        '&lt;td&gt;&lt;span id=&quot;goodsCast#&#123;cid&#125;&quot;&gt;#&#123;totalPrice&#125;&lt;/span&gt;&lt;/td&gt;\n' +
                        '&lt;td&gt;\n' +
                        '&lt;input type=&quot;button&quot; οnclick=&quot;delCartItem(this)&quot; class=&quot;cart-del btn btn-default btn-xs&quot; value=&quot;删除&quot; /&gt;\n' +
                        '&lt;/td&gt;\n' +
                        '&lt;/tr&gt;';
                    tr = tr.replaceAll(/#&#123;cid&#125;/g, list[i].cid);
                    tr = tr.replaceAll(/#&#123;image&#125;/g, list[i].image);
                    tr = tr.replaceAll(/#&#123;title&#125;/g, list[i].title);
                    tr = tr.replaceAll(/#&#123;singlePrice&#125;/g, list[i].realPrice);
                    tr = tr.replaceAll(/#&#123;num&#125;/g, list[i].num);
                    tr = tr.replaceAll(/#&#123;totalPrice&#125;/g, list[i].realPrice * list[i].num);
                    if (list[i].realPrice &lt; list[i].price) &#123;
                        tr = tr.replace(/#&#123;msg&#125;/g, &quot;比加入时降价&quot; + (list[i].price - list[i].realPrice) + &quot;元&quot;);
                    &#125; else &#123;
                        tr = tr.replace(/#&#123;msg&#125;/g, &quot;&quot;);
                    &#125;
                    $(&quot;#cart-list&quot;).append(tr);
                &#125;
            &#125;,
            error: function (xhr) &#123;
                alert(&quot;加载购物车列表数据时产生未知的异常&quot;+xhr.status);
            &#125;
        &#125;);
    &#125;
&lt;/script&gt;
</code></pre>
<p>这tr变量是怎么声明的呢:</p>
<p><strong>先敲下var=‘’;然后在上面的html里面找到tbody下的任意一个tr标签复制在单引号里面,然后删掉制表符.最后对该字符串稍加改动:</strong></p>
<blockquote>
<p>1.第18行name=“cids” value=&quot;#{cid}&quot;是为&quot;点击结算按钮跳转到确认订单页面&quot;模块做准备。这两个属性都是自己添加的,在tbody复制的tr标签里面没有,这两个属性是为了跳转到&quot;确认订单页&quot;时能够携带该参数(比如传递cids=1)</p>
<p>2.第26οnclick=&quot;addNum(#{cid})“是为&quot;在购物车列表增加商品数量&quot;模块做准备。是为了点击”+&quot;后能调用addNum函数并传入对应的cid</p>
<p>3.第22行id=&quot;goodsPrice#{cid}&quot;和第25行id=&quot;goodsCount#{cid}&quot;和第28行id=&quot;goodsCast#{cid}&quot;都是为&quot;在购物车列表增加商品数量&quot;模块做准备。在后端更新完商品数量相应的前端页面也要更新:</p>
<ul>
<li>根据id=&quot;goodsCount#{cid}&quot;获取数量相关的控件后更新其value属性的值(value属性用.val()赋值)</li>
<li>根据id=&quot;goodsPrice#{cid}&quot;获取价格相关的控件后拿到其单价</li>
<li>将单价和数量相乘后,根据id=&quot;goodsCast#{cid}&quot;获取总价相关的控件并更新其文本值(文本用.html()更新)</li>
</ul>
<p>4.上面这三条都是和本模块无关的,其余的修改都是和本模块相关的,在tbody复制的tr标签里面都有,比葫芦画瓢就可以了</p>
</blockquote>
<p><strong>点击&quot;结算&quot;按钮页面跳转的实现:在cart.html页面点击&quot;结算&quot;后会跳转到&quot;确认订单页&quot;并将表单中的数据作为参数传递给&quot;确认订单页&quot;</strong></p>
<h2 id="增加商品数量"><a class="markdownIt-Anchor" href="#增加商品数量"></a> 增加商品数量</h2>
<blockquote>
<p>购物车详情页点击&quot;+“”-&quot;修改商品数量时<strong>必须和数据库进行交互</strong>,因为这是即使展示给用户的,不能说用户看到的数量是5,结果数据库的购物车表中的数量是4吧?</p>
<p>但是在商品详情页点击&quot;+“”-“修改商品数量时可以不用和数据库进行交互而是等到用户点击&quot;加入购物车&quot;后再进行交互,因为在用户点击&quot;加入购物车&quot;之前并不需要将商品数量更新到购物车表,可以去看看这个项目的商品详情页,那里点击”+“”-“修改商品数量时就是js实现的,并没有和数据库交互.(如果加一个模块:商品详情页点击”+“”-&quot;时要知道库存够不够用户选择的这个数量,此时就需要和数据库交互了)</p>
</blockquote>
<h3 id="1增加购物车商品数量-持久层"><a class="markdownIt-Anchor" href="#1增加购物车商品数量-持久层"></a> 1.增加购物车商品数量-持久层</h3>
<h4 id="11规划需要执行的sql语句-7"><a class="markdownIt-Anchor" href="#11规划需要执行的sql语句-7"></a> 1.1规划需要执行的SQL语句</h4>
<p>1.更新该商品的数量.此SQL语句无需重复开发</p>
<p>2.首先进行查询需要操作的购物车数据信息</p>
<pre class="highlight"><code class="">SELECT * FROM t_cart WHERE cid=?
</code></pre>
<h4 id="12设计接口和抽象方法-9"><a class="markdownIt-Anchor" href="#12设计接口和抽象方法-9"></a> 1.2设计接口和抽象方法</h4>
<p>在CartMapper接口中添加抽象方法</p>
<pre class="highlight"><code class="">Cart findByCid(Integer cid);
</code></pre>
<h4 id="13编写映射-9"><a class="markdownIt-Anchor" href="#13编写映射-9"></a> 1.3编写映射</h4>
<p>在CartMapper文件中添加findByCid(Integer cid)方法的映射</p>
<pre class="highlight"><code class="">&lt;select id=&quot;findByCid&quot; resultMap=&quot;CartEntityMap&quot;&gt;
    select * from t_cart where cid=#&#123;cid&#125;
&lt;/select&gt;
</code></pre>
<h4 id="14单元测试-8"><a class="markdownIt-Anchor" href="#14单元测试-8"></a> 1.4单元测试</h4>
<p>在CartMapperTests测试类中添加findByCid()测试方法</p>
<pre class="highlight"><code class="">@Test
public void findByCid() &#123;
    System.out.println(cartMapper.findByCid(1));
&#125;
</code></pre>
<h3 id="2增加购物车商品数量-业务层"><a class="markdownIt-Anchor" href="#2增加购物车商品数量-业务层"></a> 2.增加购物车商品数量-业务层</h3>
<h4 id="21规划异常-10"><a class="markdownIt-Anchor" href="#21规划异常-10"></a> 2.1规划异常</h4>
<ul>
<li>在更新时产生UpdateException未知异常,此异常类无需再次创建</li>
<li>可能该购物车列表数据归属不是登录的用户,抛AccessDeniedException异常,此异常类无需再次创建</li>
<li>要查询的数据不存在.抛出CartNotFoundException异常,创建该异常类并使其继承ServiceException</li>
</ul>
<pre class="highlight"><code class="">/** 购物车数据不存在的异常 */
public class CartNotFoundException extends ServiceException &#123;
    /**重写ServiceException的所有构造方法*/
&#125;
</code></pre>
<h4 id="22设计接口和抽象方法及实现-11"><a class="markdownIt-Anchor" href="#22设计接口和抽象方法及实现-11"></a> 2.2设计接口和抽象方法及实现</h4>
<p>在业务层ICartService接口中添加addNum()抽象方法</p>
<p>1.先判断需要哪些参数,该抽象方法的实现依赖于CartMapper接口的两个方法:</p>
<blockquote>
<p>updateNumByCid方法.参数是cid,num,String modifiedUser,Date modifiedTime</p>
<p>findByCid方法.参数是cid</p>
<p>在业务层中从购物车表查询到该商品的数量,然后再和前端传过来的增加的数量进行求和得到num</p>
<p>所以该方法的参数是cid,uid,username</p>
</blockquote>
<p>2.判断一下该方法的返回值:</p>
<ul>
<li>该方法返回值void.这样的话就需要在前端页面加location.href使该页面自己跳转到自己,实现刷新页面(不建议,每次都加载整个页面,数据量太大了)</li>
<li>返回值是Integer类型.这样的话就把数据库中更新后的数量层层传给前端,前端接收后填充到控件中就可以了</li>
</ul>
<pre class="highlight"><code class="">/**
* 增加用户的购物车中某商品的数量
* @param cid
* @param uid
* @param username
* @return 增加成功后新的数量
*/
Integer addNum(Integer cid,Integer uid, String username);
</code></pre>
<p>3.在CartServiceImpl类中实现接口中的抽象方法</p>
<pre class="highlight"><code class="">@Override
public Integer addNum(Integer cid, Integer uid, String username) &#123;
    Cart result = cartMapper.findByCid(cid);
    if (result == null) &#123;
        throw new CartNotFoundException(&quot;数据不存在&quot;);
    &#125;
    if (!result.getUid().equals(uid)) &#123;
        throw new AccessDeniedException(&quot;数据非法访问&quot;);
    &#125;
    Integer num = result.getNum() + 1;
    Integer rows = cartMapper.updateNumByCid(cid, num, username, new Date());
    if (rows != 1) &#123;
        throw new UpdateException(&quot;更新数据时产生未知异常&quot;);
    &#125;
    return num;
&#125;
</code></pre>
<h4 id="23单元测试-10"><a class="markdownIt-Anchor" href="#23单元测试-10"></a> 2.3单元测试</h4>
<p>就接收个参数,然后业务层将其加一后返回,不需要再测了</p>
<h3 id="3增加购物车商品数量-控制层"><a class="markdownIt-Anchor" href="#3增加购物车商品数量-控制层"></a> 3.增加购物车商品数量-控制层</h3>
<h4 id="31处理异常-8"><a class="markdownIt-Anchor" href="#31处理异常-8"></a> 3.1处理异常</h4>
<p>在BaseController类中添加CartNotFoundException异常类的统一管理</p>
<pre class="highlight"><code class="">else if (e instanceof CartNotFoundException) &#123;
    result.setState(4007);
    result.setMessage(&quot;购物车表不存在该商品的异常&quot;);
&#125;
</code></pre>
<h4 id="32设计请求-7"><a class="markdownIt-Anchor" href="#32设计请求-7"></a> 3.2设计请求</h4>
<ul>
<li>/carts/{cid}/num/add</li>
<li>post</li>
<li>@PathVariable(“cid”) Integer cid, HttpSession session</li>
<li>JsonResult<Integer></li>
</ul>
<h4 id="33处理请求-8"><a class="markdownIt-Anchor" href="#33处理请求-8"></a> 3.3处理请求</h4>
<p>在CartController类中添加处理请求的addNum()方法</p>
<pre class="highlight"><code class="">@RequestMapping(&quot;&#123;cid&#125;/num/add&quot;)
public JsonResult&lt;Integer&gt; addNum(@PathVariable(&quot;cid&quot;) Integer cid, HttpSession session) &#123;
    Integer data = cartService.addNum(
        cid,
        getUidFromSession(session),
        getUsernameFromSession(session));
    return new JsonResult&lt;Integer&gt;(OK, data);
&#125;
</code></pre>
<p>启动服务,登录后在地址栏输入http://localhost:8080/carts/1/num/add进行验证</p>
<h3 id="4增加购物车商品数量-前端页面"><a class="markdownIt-Anchor" href="#4增加购物车商品数量-前端页面"></a> 4.增加购物车商品数量-前端页面</h3>
<p>1.首先确定在showCartList()函数中动态拼接的增加购物车按钮是绑定了addNum()事件，如果已经添加无需重复添加</p>
<pre class="highlight"><code class="">&lt;input class=&quot;num-btn&quot; type=&quot;button&quot; value=&quot;+&quot; onclick=&quot;addNum(#&#123;cid&#125;)&quot; /&gt;
</code></pre>
<p>2.在script标签中定义addNum()函数并编写增加购物车数量的逻辑代码</p>
<pre class="highlight"><code class="">function addNum(cid) &#123;
    $.ajax(&#123;
        url: &quot;/carts/&quot;+cid+&quot;/num/add&quot;,
        type: &quot;POST&quot;,
        dataType: &quot;JSON&quot;,
        success: function (json) &#123;
            if (json.state == 200) &#123;
                $(&quot;#goodsCount&quot;+cid).val(json.data);//字符串+整数cid后结果为字符串

                //更新该商品总价
                /*
                            html()方法:
                            不传参:是获取某个标签内部的内容(文本或标签)
                            传参:将参数放到标签里面替换掉该标签原有内容
                            * */
                var price = $(&quot;#goodsPrice&quot;+cid).html();
                var totalPrice = price * json.data;

                //将商品总价更新到控件中
                $(&quot;#goodsCast&quot;+cid).html(totalPrice);
            &#125; else &#123;
                alert(&quot;增加购物车商品数量失败&quot;+json.message);
            &#125;
        &#125;,
        error: function (xhr) &#123;
            alert(&quot;增加购物车商品数量时产生未知的异常!&quot;+xhr.message);
        &#125;
    &#125;);
&#125;
</code></pre>
<h2 id="确认订单"><a class="markdownIt-Anchor" href="#确认订单"></a> 确认订单</h2>
<h3 id="1确认订单-持久层"><a class="markdownIt-Anchor" href="#1确认订单-持久层"></a> 1.确认订单-持久层</h3>
<h4 id="11规划需要执行的sql语句-8"><a class="markdownIt-Anchor" href="#11规划需要执行的sql语句-8"></a> 1.1规划需要执行的SQL语句</h4>
<blockquote>
<p>用户在购物车列表页中通过随机勾选相关的商品,在点击&quot;结算&quot;按钮后跳转到&quot;确认订单页&quot;,在这个页面中需要展示用户在上个页面所勾选的&quot;购物车列表页&quot;中对应的数据.说白了也就是列表展示,且展示的内容还是来自于购物车表.但是用户勾选了哪些商品呢,所以&quot;购物车列表页&quot;需要将用户勾选的商品id传递给&quot;确认订单页&quot;</p>
</blockquote>
<p>所以在持久层需要完成“根据若干个不确定的id值，查询购物车数据表，显示购物车中的数据信息”。则需要执行的SQL语句大致是。</p>
<pre class="highlight"><code class="">select
    cid,
    uid,
    pid,
    t_cart.price,
    t_cart.num,
    title,
    t_product.price as realPrice,
    image
from t_cart
left join t_product on t_cart.pid = t_product.id
where
cid in (?,?,?)
order by
t_cart.created_time desc
</code></pre>
<p>注意where cid in (?,?,?),这里是需要传入cid的集合</p>
<h4 id="12设计接口和抽象方法-10"><a class="markdownIt-Anchor" href="#12设计接口和抽象方法-10"></a> 1.2设计接口和抽象方法</h4>
<p>在CartMapper接口中添加findVOByCids抽象方法</p>
<pre class="highlight"><code class="">List&lt;CartVO&gt; findVOByCids(Integer[] cids);
</code></pre>
<h4 id="13配置映射"><a class="markdownIt-Anchor" href="#13配置映射"></a> 1.3配置映射</h4>
<p>1.在CartMapper.xml文件中添加SQL语句的映射配置</p>
<pre class="highlight"><code class="">&lt;select id=&quot;findVOByCids&quot; resultType=&quot;com.cy.store.vo.CartVO&quot;&gt;
    select
        cid,
        uid,
        pid,
        t_cart.price,
        t_cart.num,
        title,
        t_product.price as realPrice,
        image
    from t_cart
    left join t_product on t_cart.pid = t_product.id
    where
        cid in (
            &lt;foreach collection=&quot;array&quot; item=&quot;cid&quot; separator=&quot;,&quot;&gt;
                #&#123;cid&#125;
            &lt;/foreach&gt;
            )
    order by
    t_cart.created_time desc
&lt;/select&gt;
</code></pre>
<blockquote>
<p>foreach循环就是一个for循环</p>
<ul>
<li>collection标识循环的是list集合还是数组,如果是list集合就用collection=“list”</li>
<li>item用来接收每次循环获取的值</li>
<li>separator标识循环出来的值中间用什么隔开,且最后循环出来的值后面不加</li>
</ul>
</blockquote>
<h4 id="14单元测试-9"><a class="markdownIt-Anchor" href="#14单元测试-9"></a> 1.4单元测试</h4>
<p>在CartMapperTests测试类中添加findVOByCids方法进行测试</p>
<pre class="highlight"><code class="">@Test
public void findVOByCids() &#123;
    Integer[] cids = &#123;1, 2, 6, 8, 100&#125;;//可以写表中不存在的,无非就是查不到数据,并不会报错
    List&lt;CartVO&gt; list = cartMapper.findVOByCids(cids);
    for (CartVO item : list) &#123;
        System.out.println(item);
    &#125;
&#125;
</code></pre>
<h3 id="2确认订单-业务层"><a class="markdownIt-Anchor" href="#2确认订单-业务层"></a> 2.确认订单-业务层</h3>
<h4 id="21规划异常-11"><a class="markdownIt-Anchor" href="#21规划异常-11"></a> 2.1规划异常</h4>
<p>查询语句,没有需要规划的异常,在业务层判断这几条购物车商品的数据归属是否正确,如果不正确也不需要抛出异常,直接从查询到的数据中移除该商品就行了</p>
<h4 id="22设计接口和抽象方法及实现-12"><a class="markdownIt-Anchor" href="#22设计接口和抽象方法及实现-12"></a> 2.2设计接口和抽象方法及实现</h4>
<p>1.在ICartService接口中添加getVOByCids()抽象方法</p>
<pre class="highlight"><code class="">List&lt;CartVO&gt; getVOByCids(Integer uid, Integer[] cids);//uid是为了判断数据归属是否正确
</code></pre>
<p>2.在CartServiceImpl类中重写业务接口中的抽象方法</p>
<pre class="highlight"><code class="">@Override
public List&lt;CartVO&gt; getVOByCids(Integer uid, Integer[] cids) &#123;
    List&lt;CartVO&gt; list = cartMapper.findVOByCids(cids);

    //可以使用for遍历,这里玩个新的,用迭代器遍历
    Iterator&lt;CartVO&gt; it = list.iterator();
    while (it.hasNext()) &#123;

        //指向的是该元素之前,所以需要next得到该元素
        CartVO cart = it.next();

        if (!cart.getUid().equals(uid)) &#123;
            /**
             * 不能用list.remove(cart)
             * 在迭代器进行遍历的时候不能使用集合的移除
             * 方法,需要用迭代器特有的移除方法
             */
            it.remove();
        &#125;
    &#125;
    return list;
&#125;
</code></pre>
<h4 id="23单元测试-11"><a class="markdownIt-Anchor" href="#23单元测试-11"></a> 2.3单元测试</h4>
<p>业务层只是调用持久层获取数据并判断归属是否正确,这里不再测试</p>
<h3 id="3确认订单-控制层"><a class="markdownIt-Anchor" href="#3确认订单-控制层"></a> 3.确认订单-控制层</h3>
<h4 id="31处理异常-9"><a class="markdownIt-Anchor" href="#31处理异常-9"></a> 3.1处理异常</h4>
<p>业务层没有抛出异常,所以不需要处理异常</p>
<h4 id="32设计请求-8"><a class="markdownIt-Anchor" href="#32设计请求-8"></a> 3.2设计请求</h4>
<ul>
<li>/carts/list</li>
<li>GET</li>
<li>Integer[] cids, HttpSession session</li>
<li>JsonResult&lt;List<CartVO>&gt;</li>
</ul>
<h4 id="33处理请求-9"><a class="markdownIt-Anchor" href="#33处理请求-9"></a> 3.3处理请求</h4>
<p>1.在CartController类中添加处理请求的getVOByCids()方法。</p>
<pre class="highlight"><code class="">@RequestMapping(&quot;list&quot;)
public JsonResult&lt;List&lt;CartVO&gt;&gt; findVOByCids(Integer[] cids, HttpSession session) &#123;
    List&lt;CartVO&gt; data = cartService.getVOByCids(getUidFromSession(session), cids);
    return new JsonResult&lt;&gt;(OK, data);
&#125;
</code></pre>
<p>启动服务,登录后在地址栏输入http://localhost:8080/carts/list?cids=1&amp;cids=5&amp;cids=7进行测试</p>
<h3 id="4确认订单-前端页面"><a class="markdownIt-Anchor" href="#4确认订单-前端页面"></a> 4.确认订单-前端页面</h3>
<h4 id="41显示勾选的购物车数据"><a class="markdownIt-Anchor" href="#41显示勾选的购物车数据"></a> 4.1显示勾选的购物车数据</h4>
<p>1.检查cart.html页面,里面form标签的action=&quot;orderConfirm.html&quot;属性(规定表单数据提交到哪里)和结算按钮的类型&quot;type=submit&quot;是必不可少的,这样点击&quot;结算&quot;时才能将数据传给&quot;确认订单页&quot;并在&quot;确认订单页&quot;展示选中的商品数据</p>
<p>2.在orderConfirm.html页面中实现自动加载从cart.html页面中传递过来的cids数据,再去请求ajax,然后将后端返回的数据填充在页面的某个区域中</p>
<p>3.orderConfirm.js文件中</p>
<ul>
<li>
<p>$(“.link-pay”).click(……)作用:点击&quot;在线支付&quot;后跳转到支付页面,这个其实就是下个模块要做的&quot;创建订单&quot;功能,该功能需要和数据库交互,所以不是在前端实现的,所以这行代码无用</p>
</li>
<li>
<p>$(“.link-success”).click(…):在orderConfirm.html页面没有class为link-success的标签,所以这行代码不会被执行</p>
<p>综上两条,orderConfirm.js文件在orderConfirm.html页面中无用,但存在可能会和下个模块&quot;创建订单&quot;功能冲突(下个模块会实现点击&quot;创建订单&quot;后页面跳转),所以注释掉</p>
</li>
</ul>
<hr />
<p>下面在orderConfirm.html页面编写js代码</p>
<pre class="highlight"><code class="">&lt;script type=&quot;text/javascript&quot;&gt;
    $(document).ready(function() &#123;
    showCartList();
&#125;);

    function showCartList() &#123;
        $(&quot;#cart-list&quot;).empty();
        $.ajax(&#123;
            url: &quot;/carts/list&quot;,
            type: &quot;GET&quot;,
            data: location.search.substr(1),
            dataType: &quot;JSON&quot;,
            success: function(json) &#123;
                if (json.state == 200) &#123;
                    var list = json.data;
                    console.log(location.search.substr(1));//调试用

                    //声明两个变量用于更新&quot;确认订单&quot;页的总件数和总价
                    var allCount = 0;
                    var allPrice = 0;

                    for (var i = 0; i &lt; list.length; i++) &#123;
                        var tr = '&lt;tr&gt;\n' +
                            '&lt;td&gt;&lt;img src=&quot;..#&#123;image&#125;collect.png&quot; class=&quot;img-responsive&quot; /&gt;&lt;/td&gt;\n' +
                            '&lt;td&gt;#&#123;title&#125;&lt;/td&gt;\n' +
                            '&lt;td&gt;¥&lt;span&gt;#&#123;price&#125;&lt;/span&gt;&lt;/td&gt;\n' +
                            '&lt;td&gt;#&#123;num&#125;&lt;/td&gt;\n' +
                            '&lt;td&gt;&lt;span&gt;#&#123;totalPrice&#125;&lt;/span&gt;&lt;/td&gt;\n' +
                            '&lt;/tr&gt;';
                        tr = tr.replace(&quot;#&#123;image&#125;&quot;,list[i].image);
                        tr = tr.replace(&quot;#&#123;title&#125;&quot;,list[i].title);
                        tr = tr.replace(&quot;#&#123;price&#125;&quot;,list[i].realPrice);
                        tr = tr.replace(&quot;#&#123;num&#125;&quot;,list[i].num);
                        tr = tr.replace(&quot;#&#123;totalPrice&#125;&quot;,list[i].realPrice*list[i].num);
                        $(&quot;#cart-list&quot;).append(tr);

                        //更新&quot;确认订单&quot;页的总件数和总价
                        allCount += list[i].num;
                        allPrice += list[i].realPrice*list[i].num;
                    &#125;
                    $(&quot;#all-count&quot;).html(allCount);
                    $(&quot;#all-price&quot;).html(allPrice);
                &#125;
            &#125;,
            error: function (xhr) &#123;
                alert(&quot;在确认订单页加载勾选的购物车数据时发生未知的异常&quot;+xhr.status);
            &#125;
        &#125;);
    &#125;
&lt;/script&gt;
</code></pre>
<blockquote>
<p>1.为什么点击购物车列表页面的&quot;结算&quot;按钮后地址栏中会请求http://localhost:8080/web/orderConfirm.html?cids=6&amp;cids=5呢,因为该按钮有一个type=submit属性,且表单有一个action=&quot;orderConfirm.html&quot;属性,所以点击该按钮后会携带表单中参数自动跳转</p>
<p>会携带哪些参数呢:把表单中有name属性的标签的value值传递出去,针对这个请求传递的是name&quot;cids&quot;,其value值根据勾选的商品而定,可以是1或3或10</p>
<p>2.<strong>data: location.search.substr(1)这个API的参数为0表示截取地址栏中?后面的数据,即参数</strong></p>
<p><strong>如果这个API的参数为0则表示截取地址栏中?前面的数据,即请求地址</strong></p>
</blockquote>
<h4 id="42显示选择收货地址"><a class="markdownIt-Anchor" href="#42显示选择收货地址"></a> 4.2显示选择收货地址</h4>
<p>收货地址存放在前端的一个select下拉列表中,我们需要将查询到的当前登录用户的收货地址动态的加载到这个下拉列表中.从数据库的角度看,是一个select查询语句,在&quot;收货地址列表展示&quot;模块已经编写了该持久层,业务层,控制层,所以这里只需要编写对应的前端页面就可以了</p>
<p>1.在orderConfirm.html页面中的ready函数中添加showAddressList方法的调用,使确认订单页加载时能够自动从后端获取该用户地址填充到select控件中并将第一个地址显示出来</p>
<pre class="highlight"><code class="">$(document).ready(function() &#123;
    showCartList();
    showAddressList();
&#125;);
</code></pre>
<p>2.在orderConfirm.html页面中编写showAddressList方法</p>
<pre class="highlight"><code class="">function showAddressList() &#123;
    $(&quot;#address-list&quot;).empty();
    $.ajax(&#123;
        url: &quot;/addresses&quot;,
        type: &quot;GET&quot;,
        dataType: &quot;JSON&quot;,
        success: function(json) &#123;
            if (json.state == 200) &#123;
                var list = json.data;
                for (var i = 0; i &lt; list.length; i++) &#123;

                    /*
                                value=&quot;#&#123;aid&#125;&quot;在该模块没有用,但是扔写上,只要是从数据库查到到的数据,都要让前端页
                                面的该条数据和id绑定(因为可能干别的什么时需要用到,就比如说下一个&quot;创建订单&quot;模块
                                就需要根据前端传给后端的aid查询用户选中的是哪一个地址然后将其加入订单表)
                     * */
                    var opt = '&lt;option value=&quot;#&#123;aid&#125;&quot;&gt;#&#123;name&#125;&amp;nbsp;&amp;nbsp;&amp;nbsp;#&#123;tag&#125;&amp;nbsp;&amp;nbsp;&amp;nbsp;#&#123;provinceName&#125;#&#123;cityName&#125;#&#123;areaName&#125;#&#123;address&#125;&amp;nbsp;&amp;nbsp;&amp;nbsp;#&#123;tel&#125;&lt;/option&gt;';
                    opt = opt.replace(&quot;#&#123;aid&#125;&quot;,list[i].aid);
                    opt = opt.replace(&quot;#&#123;name&#125;&quot;,list[i].name);
                    opt = opt.replace(&quot;#&#123;tag&#125;&quot;,list[i].tag);
                    opt = opt.replace(&quot;#&#123;provinceName&#125;&quot;,list[i].provinceName);
                    opt = opt.replace(&quot;#&#123;cityName&#125;&quot;,list[i].cityName);
                    opt = opt.replace(&quot;#&#123;areaName&#125;&quot;,list[i].areaName);
                    opt = opt.replace(&quot;#&#123;address&#125;&quot;,list[i].address);
                    opt = opt.replace(&quot;#&#123;tel&#125;&quot;,list[i].tel);

                    $(&quot;#address-list&quot;).append(opt);
                &#125;
            &#125;
        &#125;,
        error: function (xhr) &#123;
            alert(&quot;在确认订单页加载用户地址时发生未知的异常&quot;+xhr.status);
        &#125;
    &#125;);
&#125;
</code></pre>
<h2 id="创建订单"><a class="markdownIt-Anchor" href="#创建订单"></a> 创建订单</h2>
<h3 id="1创建数据表-6"><a class="markdownIt-Anchor" href="#1创建数据表-6"></a> 1.创建数据表</h3>
<p>1.使用use命令先选中store数据库。</p>
<pre class="highlight"><code class="">USE store;
</code></pre>
<p>2.在store数据库中创建t_order和t_order_item数据表</p>
<blockquote>
<p>针对该模块可以将t_order_item表和t_order表合并,但是以后可能开发某个模块可能单独用到t_order_item(比如用户查看订单时只需要t_order_item表就可以实现)所以,建议这两个表分开创建</p>
</blockquote>
<pre class="highlight"><code class="">CREATE TABLE t_order (
oid INT AUTO_INCREMENT COMMENT '订单id',
uid INT NOT NULL COMMENT '用户id',
recv_name VARCHAR(20) NOT NULL COMMENT '收货人姓名',
recv_phone VARCHAR(20) COMMENT '收货人电话',
recv_province VARCHAR(15) COMMENT '收货人所在省',
recv_city VARCHAR(15) COMMENT '收货人所在市',
recv_area VARCHAR(15) COMMENT '收货人所在区',
recv_address VARCHAR(50) COMMENT '收货详细地址',
total_price BIGINT COMMENT '总价',
status INT COMMENT '状态：0-未支付，1-已支付，2-已取消，3-已关闭，4-已完成',
order_time DATETIME COMMENT '下单时间',
pay_time DATETIME COMMENT '支付时间',
created_user VARCHAR(20) COMMENT '创建人',
created_time DATETIME COMMENT '创建时间',
modified_user VARCHAR(20) COMMENT '修改人',
modified_time DATETIME COMMENT '修改时间',
PRIMARY KEY (oid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE t_order_item (
id INT AUTO_INCREMENT COMMENT '订单中的商品记录的id',
oid INT NOT NULL COMMENT '所归属的订单的id',
pid INT NOT NULL COMMENT '商品的id',
title VARCHAR(100) NOT NULL COMMENT '商品标题',
image VARCHAR(500) COMMENT '商品图片',
price BIGINT COMMENT '商品价格',
num INT COMMENT '购买数量',
created_user VARCHAR(20) COMMENT '创建人',
created_time DATETIME COMMENT '创建时间',
modified_user VARCHAR(20) COMMENT '修改人',
modified_time DATETIME COMMENT '修改时间',
PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre>
<h3 id="2创建用户的实体类-2"><a class="markdownIt-Anchor" href="#2创建用户的实体类-2"></a> 2.创建用户的实体类</h3>
<p>1.entity包下创建Order实体类并继承BaseEntity类</p>
<pre class="highlight"><code class="">/** 订单数据的实体类 */
public class Order extends BaseEntity &#123;
    private Integer oid;
    private Integer uid;
    private String recvName;
    private String recvPhone;
    private String recvProvince;
    private String recvCity;
    private String recvArea;
    private String recvAddress;
    private Long totalPrice;
    private Integer status;
    private Date orderTime;
    private Date payTime;
    /**
     * get,set
     * equals和hashCode
     * toString
     */
&#125;    
</code></pre>
<p>2.在com.cy.store.entity包下创建OrderItem实体类并继承BaseEntity类</p>
<pre class="highlight"><code class="">/** 订单中的商品数据 */
public class OrderItem extends BaseEntity &#123;
    private Integer id;
    private Integer oid;
    private Integer pid;
    private String title;
    private String image;
    private Long price;
    private Integer num;
    /**
     * get,set
     * equals和hashCode
     * toString
     */
&#125;    
</code></pre>
<h3 id="3创建订单-持久层"><a class="markdownIt-Anchor" href="#3创建订单-持久层"></a> 3.创建订单-持久层</h3>
<h4 id="31规划需要执行的sql语句-4"><a class="markdownIt-Anchor" href="#31规划需要执行的sql语句-4"></a> 3.1规划需要执行的SQL语句</h4>
<p>1.插入订单数据的SQL语句</p>
<pre class="highlight"><code class="">inert into t_order (aid除外的所有字段) values (字段的值)
</code></pre>
<p>2.插入某一个订单中商品数据的SQL语句</p>
<pre class="highlight"><code class="">inert into t_order (id除外的所有字段) values (字段的值)
</code></pre>
<h4 id="32实现接口和抽象方法"><a class="markdownIt-Anchor" href="#32实现接口和抽象方法"></a> 3.2实现接口和抽象方法</h4>
<p>在mapper包下创建OrderMapper接口并在接口中添加抽象方法</p>
<pre class="highlight"><code class="">public interface OrderMapper &#123;
    /**
     * 插入订单数据
     * @param order 订单数据
     * @return 受影响的行数
     */
    Integer insertOrder(Order order);

    /**
     * 插入某一个订单中商品数据
     * @param orderItem 订单中商品数据
     * @return 受影响的行数
     */
    Integer insertOrderItem(OrderItem orderItem);
&#125;
</code></pre>
<h4 id="33编写映射-5"><a class="markdownIt-Anchor" href="#33编写映射-5"></a> 3.3编写映射</h4>
<p>创建OrderMapper.xml文件,并添加抽象方法的映射</p>
<pre class="highlight"><code class="">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.cy.store.mapper.OrderMapper&quot;&gt;

    &lt;!-- 插入订单数据 --&gt;
    &lt;insert id=&quot;insertOrder&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;oid&quot;&gt;
        insert into t_order (
        uid, recv_name, recv_phone, recv_province, recv_city, recv_area, recv_address,
        total_price,status, order_time, pay_time, created_user, created_time, modified_user,
        modified_time
        ) values (
        #&#123;uid&#125;, #&#123;recvName&#125;, #&#123;recvPhone&#125;, #&#123;recvProvince&#125;, #&#123;recvCity&#125;, #&#123;recvArea&#125;,
        #&#123;recvAddress&#125;, #&#123;totalPrice&#125;, #&#123;status&#125;, #&#123;orderTime&#125;, #&#123;payTime&#125;, #&#123;createdUser&#125;,
        #&#123;createdTime&#125;, #&#123;modifiedUser&#125;, #&#123;modifiedTime&#125;
        )
    &lt;/insert&gt;

    &lt;!-- 插入订单商品数据 --&gt;
    &lt;insert id=&quot;insertOrderItem&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into t_order_item (
        oid, pid, title, image, price, num, created_user,
        created_time, modified_user, modified_time
        ) values (
        #&#123;oid&#125;, #&#123;pid&#125;, #&#123;title&#125;, #&#123;image&#125;, #&#123;price&#125;, #&#123;num&#125;, #&#123;createdUser&#125;,
        #&#123;createdTime&#125;, #&#123;modifiedUser&#125;, #&#123;modifiedTime&#125;
        )
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<h4 id="34单元测试-6"><a class="markdownIt-Anchor" href="#34单元测试-6"></a> 3.4单元测试</h4>
<p>创建OrderMapperTests测试类并添加测试方法</p>
<pre class="highlight"><code class="">@RunWith(SpringRunner.class)
@SpringBootTest
public class OrderMapperTests &#123;
    @Autowired
    private OrderMapper orderMapper;

    @Test
    public void insertOrder() &#123;
        Order order = new Order();
        order.setUid(31);
        order.setRecvName(&quot;小王&quot;);
        order.setRecvPhone(&quot;133333&quot;);
        orderMapper.insertOrder(order);
    &#125;

    @Test
    public void insertOrderItem() &#123;
        OrderItem orderItem = new OrderItem();
        orderItem.setOid(1);
        orderItem.setPid(10000001);
        orderItem.setTitle(&quot;高档铅笔&quot;);
        orderMapper.insertOrderItem(orderItem);
    &#125;
&#125;
</code></pre>
<h3 id="4创建订单-业务层"><a class="markdownIt-Anchor" href="#4创建订单-业务层"></a> 4.创建订单-业务层</h3>
<h4 id="41规划异常-5"><a class="markdownIt-Anchor" href="#41规划异常-5"></a> 4.1规划异常</h4>
<p>无异常</p>
<h4 id="42实现接口和抽象方法及实现"><a class="markdownIt-Anchor" href="#42实现接口和抽象方法及实现"></a> 4.2实现接口和抽象方法及实现</h4>
<blockquote>
<p>查看订单表的字段从而分析业务层方法需要哪些参数:</p>
<p>oid:主键自增,所以不需要该参数</p>
<p>uid:由控制层获取session中uid传给业务层,所以需要该参数<br />
recv_name:通过&quot;确认订单页&quot;传递选中的地址aid,根据aid在在业务层调用已经声明的findByAid方法(该方法是在做&quot;设置默认地址&quot;模块时创建的,只在持久层创建了,并没有在业务层继续实现),所以需要参数aid<br />
recv_phone:同上<br />
recv_province:同上<br />
recv_city:同上<br />
recv_area:同上<br />
recv_address:同上<br />
total_price:根据前端传来的cids查询出每类商品数量和单价,然后相乘后求和,所以需要参数Integer[] cids<br />
status:默认是0,所以不需要该参数<br />
order_time:业务层实现方法内部可以声明,所以不需要该参数<br />
pay_time:&quot;创建订单&quot;模块不需要此参数<br />
created_user:由控制层获取session中username传给业务层,所以需要该参数<br />
created_time:业务层实现方法内部可以声明,所以不需要该参数<br />
modified_user:由控制层获取session中username传给业务层,所以需要该参数<br />
modified_time:业务层实现方法内部可以声明,所以不需要该参数</p>
</blockquote>
<p>综上分析,需要的参数是uid和aid,且需要在IAddressService接口添加getByAid()方法来获取选中的收货地址的详细数据:</p>
<p>1.在IAddressService接口中添加getByAid()方法</p>
<pre class="highlight"><code class="">Address getByAid(Integer aid, Integer uid);
</code></pre>
<p>2.在AddressServiceImpl类中实现接口中的getByAid()抽象方法</p>
<pre class="highlight"><code class="">@Override
public Address getByAid(Integer aid, Integer uid) &#123;

    Address address = addressMapper.findByAid(aid);

    if (address == null) &#123;
        throw new AddressNotFoundException(&quot;收货地址数据不存在的异常&quot;);
    &#125;
    if (!address.getUid().equals(uid)) &#123;
        throw new AccessDeniedException(&quot;非法访问&quot;);
    &#125;
    address.setProvinceCode(null);
    address.setCityCode(null);
    address.setAreaCode(null);
    address.setCreatedUser(null);
    address.setCreatedTime(null);
    address.setModifiedUser(null);
    address.setModifiedTime(null);
    return address;
&#125;
</code></pre>
<p>3.在service包下创建IOrderService业务层接口并添加抽象方法用于创建订单</p>
<pre class="highlight"><code class="">public interface IOrderService &#123;
    Order create(Integer aid, Integer[] cids, Integer uid, String username);
&#125;
</code></pre>
<p><strong>返回值是Order是因为还要在下个页面展示订单详细信息</strong></p>
<p>4.在impl包下创建OrderServiceImpl并编写代码实现订单和订单中所有商品数据的插入操作</p>
<pre class="highlight"><code class="">@Service
public class OrderServiceImpl implements IOrderService &#123;

    @Autowired
    private OrderMapper orderMapper;

    //需要调用业务层的getByAid方法
    @Autowired
    private IAddressService addressService;

    //需要调用业务层的getVOByCids方法
    @Autowired
    private ICartService cartService;

    //需要调用业务层的getByUid方法
    private IUserService userService;

    @Override
    public Order create(Integer aid, Integer[] cids, Integer uid, String username) &#123;

        //返回的列表中的对象都是即将下单的
        List&lt;CartVO&gt; list = cartService.getVOByCids(uid, cids);

        long totalPrice = 0L;
        for (CartVO cartVO : list) &#123;
            totalPrice += cartVO.getRealPrice()*cartVO.getNum();

        &#125;
        Address address = addressService.getByAid(aid, uid);
        Order order = new Order();
        order.setUid(uid);

        //封装收货地址
        order.setRecvName(address.getName());
        order.setRecvPhone(address.getPhone());
        order.setRecvProvince(address.getProvinceName());
        order.setRecvCity(address.getCityName());
        order.setRecvArea(address.getAreaName());
        order.setRecvAddress(address.getAddress());

        //封装创建时间,支付状态和总价
        order.setOrderTime(new Date());
        order.setStatus(0);
        order.setTotalPrice(totalPrice);

        //封装四个日志
        order.setCreatedUser(username);
        order.setCreatedTime(new Date());
        order.setModifiedUser(username);
        order.setModifiedTime(new Date());
        Integer rows = orderMapper.insertOrder(order);
        if (rows != 1) &#123;
            throw new InsertException(&quot;插入数据时产生未知的异常&quot;);
        &#125;

        //插入数据——将某条订单的所有商品的详细数据插入
        for (CartVO cartVO : list) &#123;
            OrderItem orderItem = new OrderItem();

            /**
             * 此时获取的oid不为空,因为在配置文件里面开启了oid主
             * 键自增,所以上面的代码执行插入时就自动将oid赋值了
             */
            orderItem.setOid(order.getOid());

            orderItem.setPid(cartVO.getPid());
            orderItem.setTitle(cartVO.getTitle());
            orderItem.setImage(cartVO.getImage());
            orderItem.setPrice(cartVO.getRealPrice());
            orderItem.setNum(cartVO.getNum());

            orderItem.setCreatedUser(username);
            orderItem.setCreatedTime(new Date());
            orderItem.setModifiedUser(username);
            orderItem.setModifiedTime(new Date());

            rows = orderMapper.insertOrderItem(orderItem);
            if (rows != 1) &#123;
                throw new InsertException(&quot;插入数据时产生未知的异常&quot;);
            &#125;
        &#125;
        return order;
    &#125;
&#125;
</code></pre>
<h4 id="43单元测试-5"><a class="markdownIt-Anchor" href="#43单元测试-5"></a> 4.3单元测试</h4>
<p>创建OrderServiceTests测试类并添加create()方法进行功能测试</p>
<pre class="highlight"><code class="">@SpringBootTest
@RunWith(SpringRunner.class)
public class OrderServiceTests &#123;
    @Autowired
    private IOrderService orderService;

    @Autowired
    IUserService userService;

    @Test
    public void create() &#123;
        Integer[] cids = &#123;2,4,6&#125;;
        Order order = orderService.create(13, cids, 11, &quot;小红&quot;);
        System.out.println(order);
    &#125;
&#125;
</code></pre>
<h3 id="5创建订单-控制层"><a class="markdownIt-Anchor" href="#5创建订单-控制层"></a> 5.创建订单-控制层</h3>
<h4 id="51处理异常-3"><a class="markdownIt-Anchor" href="#51处理异常-3"></a> 5.1处理异常</h4>
<p>没有异常需要处理</p>
<h4 id="52设计请求-4"><a class="markdownIt-Anchor" href="#52设计请求-4"></a> 5.2设计请求</h4>
<ul>
<li>/orders/create</li>
<li>GET</li>
<li>Integer aid, Integer[] cids, HttpSession session</li>
<li>JsonResult<Order></li>
</ul>
<h4 id="53处理请求-4"><a class="markdownIt-Anchor" href="#53处理请求-4"></a> 5.3处理请求</h4>
<p>controller包下创建OrderController类，并继承自BaseController类,在类中编写请求方法</p>
<pre class="highlight"><code class="">@RestController
@RequestMapping(&quot;orders&quot;)
public class OrderController extends BaseController &#123;
    @Autowired
    private IOrderService orderService;

    @RequestMapping(&quot;create&quot;)
    public JsonResult&lt;Order&gt; create(Integer aid, Integer[] cids, HttpSession session) &#123;
        Order data = orderService.create(
                aid,
                cids,
                getUidFromSession(session),
                getUsernameFromSession(session));
        return new JsonResult&lt;&gt;(OK,data);
    &#125;
&#125;
</code></pre>
<h3 id="6创建订单-前端页面"><a class="markdownIt-Anchor" href="#6创建订单-前端页面"></a> 6.创建订单-前端页面</h3>
<p>在&quot;确认订单页&quot;添加发送请求的处理方法使点击&quot;在线支付&quot;按钮可以创建订单并跳转到&quot;支付信息页&quot;(支付页显示详细商品信息这个功能这里不做了)</p>
<p><strong>请求参数是通过字符串拼接得到的,那么就必须用get请求,因为post请求不能拼接字符串</strong></p>
<pre class="highlight"><code class="">$(&quot;#btn-create-order&quot;).click(function() &#123;
    var aid = $(&quot;#address-list&quot;).val();//12
    var cids = location.search.substr(1);//cids=4&amp;cids=6&amp;cids=8
    $.ajax(&#123;
        url: &quot;/orders/create&quot;,
        data: &quot;aid=&quot; + aid + &quot;&amp;&quot; + cids,//aid=12&amp;cids=4&amp;cids=6&amp;cids=8
        type: &quot;GET&quot;,
        dataType: &quot;JSON&quot;,
        success: function(json) &#123;
            if (json.state == 200) &#123;
                location.href = &quot;payment.html&quot;;
            &#125; else &#123;
                alert(&quot;创建订单失败！&quot; + json.message);
            &#125;
        &#125;,
        error: function(xhr) &#123;
            alert(&quot;创建订单数据时产生未知的异常&quot; + xhr.status);
        &#125;
    &#125;);
&#125;);
</code></pre>
<h2 id="aop"><a class="markdownIt-Anchor" href="#aop"></a> AOP</h2>
<p>检测项目所有业务层方法的耗时(开始执行时间和结束执行时间只差值),再在不改变项目主体流程代码的前提条件下完成此功能,就要用到AOP</p>
<blockquote>
<p>如果我们想对业务某一些方法同时添加相同的功能需求,并且在不改变业务功能逻辑的基础之上进行完成,就可以使用AOP的切面编程进行开发</p>
</blockquote>
<h3 id="1spring-aop"><a class="markdownIt-Anchor" href="#1spring-aop"></a> 1.Spring AOP</h3>
<p>AOP：面向切面（Aspect）编程。AOP并不是Spring框架的特性(Spring已经被整合到了SpringBoot中,所以如果AOP是Spring框架的特性,那么就不需要手动导包,只需要在一个类上写@Aspect注解,鼠标放到该注解上按alt+enter就可以自动导包了,但是事与愿违,所以说AOP并不是Spring框架的特性)，只是Spring很好的支持了AOP。</p>
<p>使用步骤:</p>
<ol>
<li>首先定义一个类,将这个类作为切面类</li>
<li>在这个类中定义切面方法(5种:前置,后置,环绕,异常,最终)</li>
<li>将这个切面方法中的业务逻辑对应的代码进行编写和设计</li>
<li>通过连接点来连接目标方法,就是用粗粒度表达式和细粒度表达式来进行连接</li>
</ol>
<h3 id="2切面方法"><a class="markdownIt-Anchor" href="#2切面方法"></a> 2.切面方法</h3>
<p>1.切面方法的访问权限是public。</p>
<p>2.切面方法的返回值类型可以是void或Object，如果该方法被@Around注解修饰，必须使用Object作为返回值类型，并返回连接点方法的返回值；如果使用的注解是@Before或@After等其他注解时，则自行决定。</p>
<p>3.切面方法的名称可以自定义。</p>
<p>4.切面方法可以接收参数,参数是ProccedingJoinPoint接口类型的参数.但是@Around所修饰的方法必须要传递这个参数.其他注解修饰的方法要不要该参数都可以</p>
<h3 id="3-统计业务方法执行时长"><a class="markdownIt-Anchor" href="#3-统计业务方法执行时长"></a> 3 统计业务方法执行时长</h3>
<p>1.因为AOP不是Spring内部封装的技术,所以需要进行导包操作:在pom.xml文件中添加两个关于AOP的依赖aspectjweaver和aspectjtools。</p>
<pre class="highlight"><code class="">&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2.在com.cy.store.aop包下创建TimerAspect切面类,给类添加两个注解进行修饰:</p>
<ul>
<li>@Aspect(将当前类标记为切面类)</li>
<li>@Component(将当前类的对象创建使用维护交由Spring容器维护)</li>
</ul>
<pre class="highlight"><code class="">@Aspect
@Component
public class TimerAspect &#123;
&#125;
</code></pre>
<p>3.在类中添加切面方法,这里使用环绕通知的方式来进行编写</p>
<p><strong>参数ProceedingJoinPoint接口表示连接点,也就是是目标方法的对象</strong></p>
<pre class="highlight"><code class="">public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;
    //开始时间
    long start = System.currentTimeMillis();
    //调用目标方法,比如login方法,getByUid方法
    Object result = pjp.proceed();
    //结束时间
    long end = System.currentTimeMillis();
    System.out.println(&quot;耗时:&quot;+(end-start));
    return result;
&#125;
</code></pre>
<p>4.将当前环绕通知映射到某个切面上,也就是指定连接的点.给around方法添加注解@Around</p>
<pre class="highlight"><code class="">@Around(&quot;execution(* com.cy.store.service.impl.*.*(..))&quot;)
</code></pre>
<ul>
<li>第一个*表示方法返回值是任意的</li>
<li>第二个*表示imp包下的类是任意的</li>
<li>第三个*表示类里面的方法是任意的</li>
<li>(…)表示方法的参数是任意的</li>
</ul>
<p>5.启动项目，在前端浏览器访问任意一个功能模块进行功能的测试</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://www.orangecatdpman.cn">Clarence</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://www.orangecatdpman.cn/2022/10/15/%E7%94%B5%E8%84%91%E5%95%86%E5%9F%8E/">https://www.orangecatdpman.cn/2022/10/15/%E7%94%B5%E8%84%91%E5%95%86%E5%9F%8E/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/Bg4.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/11/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0%E9%A2%98/"><img class="prev-cover" src="/img/Bg4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">软件测试复习题</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Clarence</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/chenhong1875435468"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chenhong1875435468" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1875435468@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text"> 文章目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number"></span> <span class="toc-text"> 项目环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text"> 1.项目分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83"><span class="toc-number">2.</span> <span class="toc-text"> 2.项目基本环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA"><span class="toc-number">3.</span> <span class="toc-text"> 3.项目创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E9%A1%B9%E7%9B%AE%E6%B5%8B%E8%AF%95"><span class="toc-number">4.</span> <span class="toc-text"> 4.项目测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#41%E6%B5%8B%E8%AF%95%E8%83%BD%E5%90%A6%E6%88%90%E5%8A%9F%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">4.1.</span> <span class="toc-text"> 4.1测试能否成功连接数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42%E6%B5%8B%E8%AF%95%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%83%BD%E5%90%A6%E6%AD%A3%E5%B8%B8%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.2.</span> <span class="toc-text"> 4.2测试静态资源能否正常加载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD"><span class="toc-number"></span> <span class="toc-text"> 用户注册功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text"> 1.创建数据表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text"> 2.创建用户的实体类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E6%B3%A8%E5%86%8C-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.注册-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E8%A7%84%E5%88%92%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1规划需要执行的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2设计接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3编写映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">3.4.</span> <span class="toc-text"> 3.4单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E6%B3%A8%E5%86%8C-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text"> 4.注册-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#41%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8"><span class="toc-number">4.1.</span> <span class="toc-text"> 4.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text"> 4.2设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">4.3.</span> <span class="toc-text"> 4.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E6%B3%A8%E5%86%8C-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">5.</span> <span class="toc-text"> 5.注册-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#51%E5%88%9B%E5%BB%BA%E5%93%8D%E5%BA%94"><span class="toc-number">5.1.</span> <span class="toc-text"> 5.1创建响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82"><span class="toc-number">5.2.</span> <span class="toc-text"> 5.2设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="toc-number">5.3.</span> <span class="toc-text"> 5.3处理请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#54%E6%8E%A7%E5%88%B6%E5%B1%82%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.4.</span> <span class="toc-text"> 5.4控制层优化设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E6%B3%A8%E5%86%8C-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">6.</span> <span class="toc-text"> 6.注册-前端页面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#61%E7%86%9F%E6%82%89ajax"><span class="toc-number">6.1.</span> <span class="toc-text"> 6.1熟悉ajax</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#62%E5%89%8D%E7%AB%AFjs%E7%BC%96%E5%86%99"><span class="toc-number">6.2.</span> <span class="toc-text"> 6.2前端js编写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD"><span class="toc-number"></span> <span class="toc-text"> 用户登录功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E7%99%BB%E5%BD%95-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text"> 1.登录-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%92%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.</span> <span class="toc-text"> 规划需要执行的SQL语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E7%99%BB%E5%BD%95-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text"> 2.登录-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2设计接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E7%99%BB%E5%BD%95-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.登录-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E7%99%BB%E5%BD%95-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.</span> <span class="toc-text"> 4.登录-前端页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E7%94%A8session%E5%AD%98%E5%82%A8%E5%92%8C%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE"><span class="toc-number">5.</span> <span class="toc-text"> 5.用session存储和获取用户数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text"> 6.拦截器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81"><span class="toc-number"></span> <span class="toc-text"> 修改密码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text"> 1.修改密码-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E8%A7%84%E5%88%92%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1规划需要执行的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84"><span class="toc-number">1.3.</span> <span class="toc-text"> 1.3编写映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">1.4.</span> <span class="toc-text"> 1.4单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text"> 2.修改密码-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8-2"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2设计接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-2"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.修改密码-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8-2"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82-2"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82-2"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.</span> <span class="toc-text"> 4.修改密码-前端页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99"><span class="toc-number"></span> <span class="toc-text"> 个人资料</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text"> 1.个人资料-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E8%A7%84%E5%88%92sql%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1规划SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-2"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84-2"><span class="toc-number">1.3.</span> <span class="toc-text"> 1.3编写映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-2"><span class="toc-number">1.4.</span> <span class="toc-text"> 1.4单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text"> 2.个人资料-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8-3"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2设计接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-3"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.个人资料-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8-3"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82-3"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82-3"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.</span> <span class="toc-text"> 4.个人资料-前端页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F"><span class="toc-number"></span> <span class="toc-text"> 上传头像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text"> 1.上传头像-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%A7%84%E5%88%92"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1SQL语句的规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-3"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84-3"><span class="toc-number">1.3.</span> <span class="toc-text"> 1.3编写映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-3"><span class="toc-number">1.4.</span> <span class="toc-text"> 1.4单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text"> 2.上传头像-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8-4"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2设计接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-4"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.上传头像-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="toc-number">3.4.</span> <span class="toc-text"> 3.4处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.</span> <span class="toc-text"> 4.上传头像-前端页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96%E4%BF%AE%E5%A4%8Dbug"><span class="toc-number">5.</span> <span class="toc-text"> 5.前端页面优化——修复bug</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#51%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E7%9A%84%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6"><span class="toc-number">5.1.</span> <span class="toc-text"> 5.1更改默认的大小限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52%E4%B8%8A%E4%BC%A0%E5%90%8E%E6%98%BE%E7%A4%BA%E5%A4%B4%E5%83%8F"><span class="toc-number">5.2.</span> <span class="toc-text"> 5.2上传后显示头像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53%E7%99%BB%E5%BD%95%E5%90%8E%E6%98%BE%E7%A4%BA%E5%A4%B4%E5%83%8F"><span class="toc-number">5.3.</span> <span class="toc-text"> 5.3登录后显示头像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#54%E6%98%BE%E7%A4%BA%E6%9C%80%E6%96%B0%E5%A4%B4%E5%83%8F"><span class="toc-number">5.4.</span> <span class="toc-text"> 5.4显示最新头像</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80"><span class="toc-number"></span> <span class="toc-text"> 新增收货地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8-2"><span class="toc-number">1.</span> <span class="toc-text"> 1.创建数据表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%88%9B%E5%BB%BA%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text"> 2.创建收货地址的实体类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E6%96%B0%E5%A2%9E%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.新增收货地址-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E5%90%84%E5%8A%9F%E8%83%BD%E7%9A%84%E5%BC%80%E5%8F%91%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1各功能的开发顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E8%A7%84%E5%88%92%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2规划需要执行的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84"><span class="toc-number">3.4.</span> <span class="toc-text"> 3.4编写映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">3.5.</span> <span class="toc-text"> 3.5单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E6%96%B0%E5%A2%9E%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text"> 4.新增收货地址-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#41%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8-2"><span class="toc-number">4.1.</span> <span class="toc-text"> 4.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text"> 4.2设计接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-2"><span class="toc-number">4.3.</span> <span class="toc-text"> 4.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E6%96%B0%E5%A2%9E%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">5.</span> <span class="toc-text"> 5.新增收货地址-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#51%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">5.1.</span> <span class="toc-text"> 5.1处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82-2"><span class="toc-number">5.2.</span> <span class="toc-text"> 5.2设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82-2"><span class="toc-number">5.3.</span> <span class="toc-text"> 5.3处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E6%96%B0%E5%A2%9E%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">6.</span> <span class="toc-text"> 6.新增收货地址-前端页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%9C%81%E5%B8%82%E5%8C%BA%E5%88%97%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text"> 获取省市区列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8-3"><span class="toc-number">1.</span> <span class="toc-text"> 1.创建数据表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%88%9B%E5%BB%BA%E7%9C%81%E5%B8%82%E5%8C%BA%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text"> 2.创建省市区的实体类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E8%8E%B7%E5%8F%96%E7%9C%81%E5%B8%82%E5%8C%BA%E5%88%97%E8%A1%A8-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.获取省市区列表-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E8%A7%84%E5%88%92%E9%9C%80%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1规划需执行的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84-2"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3编写映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-2"><span class="toc-number">3.4.</span> <span class="toc-text"> 3.4单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E8%8E%B7%E5%8F%96%E7%9C%81%E5%B8%82%E5%8C%BA%E5%88%97%E8%A1%A8-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text"> 4.获取省市区列表-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#41%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8-3"><span class="toc-number">4.1.</span> <span class="toc-text"> 4.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.2.</span> <span class="toc-text"> 4.2设计接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-3"><span class="toc-number">4.3.</span> <span class="toc-text"> 4.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E8%8E%B7%E5%8F%96%E7%9C%81%E5%B8%82%E5%8C%BA%E5%88%97%E8%A1%A8-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">5.</span> <span class="toc-text"> 5.获取省市区列表-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#51%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82"><span class="toc-number">5.1.</span> <span class="toc-text"> 5.1设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="toc-number">5.2.</span> <span class="toc-text"> 5.2处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E8%8E%B7%E5%8F%96%E7%9C%81%E5%B8%82%E5%8C%BA%E5%88%97%E8%A1%A8-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">6.</span> <span class="toc-text"> 6.获取省市区列表-前端页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%9C%81%E5%B8%82%E5%8C%BA%E5%90%8D%E7%A7%B0"><span class="toc-number"></span> <span class="toc-text"> 获取省市区名称</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E8%8E%B7%E5%8F%96%E7%9C%81%E5%B8%82%E5%8C%BA%E5%90%8D%E7%A7%B0-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text"> 1.获取省市区名称-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E8%A7%84%E5%88%92%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5-2"><span class="toc-number">1.1.</span> <span class="toc-text"> 3.1规划需要执行的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-2"><span class="toc-number">1.2.</span> <span class="toc-text"> 3.2设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84-3"><span class="toc-number">1.3.</span> <span class="toc-text"> 3.3编写映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-3"><span class="toc-number">1.4.</span> <span class="toc-text"> 3.4单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E8%8E%B7%E5%8F%96%E7%9C%81%E5%B8%82%E5%8C%BA%E5%90%8D%E7%A7%B0-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text"> 2.获取省市区名称-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8-5"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2设计接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-5"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E8%8E%B7%E5%8F%96%E7%9C%81%E5%B8%82%E5%8C%BA%E5%90%8D%E7%A7%B0-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.获取省市区名称-控制层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E8%8E%B7%E5%8F%96%E7%9C%81%E5%B8%82%E5%8C%BA%E5%90%8D%E7%A7%B0-%E4%B8%9A%E5%8A%A1%E5%B1%82%E4%BC%98%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text"> 4.获取省市区名称-业务层优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E8%8E%B7%E5%8F%96%E7%9C%81%E5%B8%82%E5%8C%BA%E5%90%8D%E7%A7%B0-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">5.</span> <span class="toc-text"> 5.获取省市区名称-前端页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA"><span class="toc-number"></span> <span class="toc-text"> 收货地址列表展示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text"> 1.收货地址列表展示-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E8%A7%84%E5%88%92%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5-2"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1规划需要执行的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-4"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84-4"><span class="toc-number">1.3.</span> <span class="toc-text"> 1.3编写映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-4"><span class="toc-number">1.4.</span> <span class="toc-text"> 1.4单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text"> 2.收货地址列表展示-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8-6"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2设计接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-6"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.收货地址列表展示-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8-4"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82-4"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82-4"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3处理请求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80"><span class="toc-number"></span> <span class="toc-text"> 设置默认收货地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text"> 1.设置默认收货地址-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E8%A7%84%E5%88%92%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5-3"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1规划需要执行的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-5"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84-5"><span class="toc-number">1.3.</span> <span class="toc-text"> 1.3编写映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-5"><span class="toc-number">1.4.</span> <span class="toc-text"> 1.4单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text"> 2.设置默认收货地址-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8-7"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0-7"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2设计接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-7"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.设置默认收货地址-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8-5"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82-5"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82-5"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.</span> <span class="toc-text"> 4.设置默认收货地址-前端页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80"><span class="toc-number"></span> <span class="toc-text"> 删除收货地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%88%A0%E9%99%A4%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text"> 1.删除收货地址-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E8%A7%84%E5%88%92%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5-4"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1规划需要执行的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-6"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84-6"><span class="toc-number">1.3.</span> <span class="toc-text"> 1.3编写映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-6"><span class="toc-number">1.4.</span> <span class="toc-text"> 1.4单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%88%A0%E9%99%A4%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text"> 2.删除收货地址-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8-8"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0-8"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2设计接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-8"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%88%A0%E9%99%A4%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.删除收货地址-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8-6"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82-6"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82-6"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3处理请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-4"><span class="toc-number">3.4.</span> <span class="toc-text"> 3.4单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%88%A0%E9%99%A4%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.</span> <span class="toc-text"> 4.删除收货地址-前端页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%95%86%E5%93%81%E7%83%AD%E9%94%80%E6%8E%92%E8%A1%8C"><span class="toc-number"></span> <span class="toc-text"> 商品热销排行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8-4"><span class="toc-number">1.</span> <span class="toc-text"> 1.创建数据表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%88%9B%E5%BB%BA%E5%95%86%E5%93%81%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text"> 2.创建商品的实体类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%95%86%E5%93%81%E7%83%AD%E9%94%80%E6%8E%92%E8%A1%8C-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.商品热销排行-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E8%A7%84%E5%88%92%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1 规划需要执行的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2 设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3 编写映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%95%86%E5%93%81%E7%83%AD%E9%94%80%E6%8E%92%E8%A1%8C-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text"> 4.商品热销排行-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#41-%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8"><span class="toc-number">4.1.</span> <span class="toc-text"> 4.1 规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text"> 4.2 设计接口和抽象方法及实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E5%95%86%E5%93%81%E7%83%AD%E9%94%80%E6%8E%92%E8%A1%8C-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">5.</span> <span class="toc-text"> 5.商品热销排行-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#51-%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">5.1.</span> <span class="toc-text"> 5.1 处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52-%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82"><span class="toc-number">5.2.</span> <span class="toc-text"> 5.2 设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53-%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="toc-number">5.3.</span> <span class="toc-text"> 5.3 处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E5%95%86%E5%93%81-%E7%83%AD%E9%94%80%E6%8E%92%E8%A1%8C-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">6.</span> <span class="toc-text"> 6.商品-热销排行-前端页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85"><span class="toc-number"></span> <span class="toc-text"> 显示商品详情</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%98%BE%E7%A4%BA%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text"> 1.显示商品详情-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E8%A7%84%E5%88%92%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5-5"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1规划需要执行的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-7"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84-7"><span class="toc-number">1.3.</span> <span class="toc-text"> 1.3编写映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E6%98%BE%E7%A4%BA%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text"> 2.显示商品详情-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8-9"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0-9"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2设计接口和抽象方法及实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E6%98%BE%E7%A4%BA%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.显示商品详情-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8-7"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2 设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82-7"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E6%98%BE%E7%A4%BA%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.</span> <span class="toc-text"> 4.显示商品详情-前端页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%85%A5%E8%B4%AD%E7%89%A9%E8%BD%A6"><span class="toc-number"></span> <span class="toc-text"> 加入购物车</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8-5"><span class="toc-number">1.</span> <span class="toc-text"> 1.创建数据表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%88%9B%E5%BB%BA%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text"> 2.创建购物车的实体类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%8A%A0%E5%85%A5%E8%B4%AD%E7%89%A9%E8%BD%A6-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.加入购物车-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E8%A7%84%E5%88%92%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5-3"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1规划需要执行的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-3"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84-4"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3编写映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-5"><span class="toc-number">3.4.</span> <span class="toc-text"> 3.4单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%8A%A0%E5%85%A5%E8%B4%AD%E7%89%A9%E8%BD%A6-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text"> 4.加入购物车-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#41%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8-4"><span class="toc-number">4.1.</span> <span class="toc-text"> 4.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">4.2.</span> <span class="toc-text"> 4.2设计接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-4"><span class="toc-number">4.3.</span> <span class="toc-text"> 4.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E5%8A%A0%E5%85%A5%E8%B4%AD%E7%89%A9%E8%BD%A6-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">5.</span> <span class="toc-text"> 5.加入购物车-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#51%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8-2"><span class="toc-number">5.1.</span> <span class="toc-text"> 5.1处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82-3"><span class="toc-number">5.2.</span> <span class="toc-text"> 5.2设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82-3"><span class="toc-number">5.3.</span> <span class="toc-text"> 5.3处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E5%8A%A0%E5%85%A5%E8%B4%AD%E7%89%A9%E8%BD%A6-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">6.</span> <span class="toc-text"> 6.加入购物车-前端页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%88%97%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text"> 显示购物车列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%98%BE%E7%A4%BA%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%88%97%E8%A1%A8-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text"> 1.显示购物车列表-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E8%A7%84%E5%88%92%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5-6"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1规划需要执行的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-8"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84-8"><span class="toc-number">1.3.</span> <span class="toc-text"> 1.3编写映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-7"><span class="toc-number">1.4.</span> <span class="toc-text"> 1.4单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E6%98%BE%E7%A4%BA%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%88%97%E8%A1%A8-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text"> 2.显示购物车列表-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1 规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0-10"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2设计接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-9"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E6%98%BE%E7%A4%BA%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%88%97%E8%A1%A8-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.显示购物车列表-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1 处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82-2"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2 设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3 处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E6%98%BE%E7%A4%BA%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%88%97%E8%A1%A8-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.</span> <span class="toc-text"> 4.显示购物车列表-前端页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E5%95%86%E5%93%81%E6%95%B0%E9%87%8F"><span class="toc-number"></span> <span class="toc-text"> 增加商品数量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%A2%9E%E5%8A%A0%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%95%86%E5%93%81%E6%95%B0%E9%87%8F-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text"> 1.增加购物车商品数量-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E8%A7%84%E5%88%92%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5-7"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1规划需要执行的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-9"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84-9"><span class="toc-number">1.3.</span> <span class="toc-text"> 1.3编写映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-8"><span class="toc-number">1.4.</span> <span class="toc-text"> 1.4单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%A2%9E%E5%8A%A0%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%95%86%E5%93%81%E6%95%B0%E9%87%8F-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text"> 2.增加购物车商品数量-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8-10"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0-11"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2设计接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-10"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%A2%9E%E5%8A%A0%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%95%86%E5%93%81%E6%95%B0%E9%87%8F-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.增加购物车商品数量-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8-8"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82-7"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82-8"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%A2%9E%E5%8A%A0%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%95%86%E5%93%81%E6%95%B0%E9%87%8F-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.</span> <span class="toc-text"> 4.增加购物车商品数量-前端页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4%E8%AE%A2%E5%8D%95"><span class="toc-number"></span> <span class="toc-text"> 确认订单</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E7%A1%AE%E8%AE%A4%E8%AE%A2%E5%8D%95-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text"> 1.确认订单-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E8%A7%84%E5%88%92%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5-8"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1规划需要执行的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-10"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2设计接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E9%85%8D%E7%BD%AE%E6%98%A0%E5%B0%84"><span class="toc-number">1.3.</span> <span class="toc-text"> 1.3配置映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-9"><span class="toc-number">1.4.</span> <span class="toc-text"> 1.4单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E7%A1%AE%E8%AE%A4%E8%AE%A2%E5%8D%95-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text"> 2.确认订单-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8-11"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0-12"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2设计接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-11"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E7%A1%AE%E8%AE%A4%E8%AE%A2%E5%8D%95-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.确认订单-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8-9"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82-8"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82-9"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E7%A1%AE%E8%AE%A4%E8%AE%A2%E5%8D%95-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.</span> <span class="toc-text"> 4.确认订单-前端页面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#41%E6%98%BE%E7%A4%BA%E5%8B%BE%E9%80%89%E7%9A%84%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%95%B0%E6%8D%AE"><span class="toc-number">4.1.</span> <span class="toc-text"> 4.1显示勾选的购物车数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42%E6%98%BE%E7%A4%BA%E9%80%89%E6%8B%A9%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80"><span class="toc-number">4.2.</span> <span class="toc-text"> 4.2显示选择收货地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%A2%E5%8D%95"><span class="toc-number"></span> <span class="toc-text"> 创建订单</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8-6"><span class="toc-number">1.</span> <span class="toc-text"> 1.创建数据表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB-2"><span class="toc-number">2.</span> <span class="toc-text"> 2.创建用户的实体类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%88%9B%E5%BB%BA%E8%AE%A2%E5%8D%95-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text"> 3.创建订单-持久层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E8%A7%84%E5%88%92%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84sql%E8%AF%AD%E5%8F%A5-4"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1规划需要执行的SQL语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2实现接口和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84-5"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3编写映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-6"><span class="toc-number">3.4.</span> <span class="toc-text"> 3.4单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%88%9B%E5%BB%BA%E8%AE%A2%E5%8D%95-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text"> 4.创建订单-业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#41%E8%A7%84%E5%88%92%E5%BC%82%E5%B8%B8-5"><span class="toc-number">4.1.</span> <span class="toc-text"> 4.1规划异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text"> 4.2实现接口和抽象方法及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-5"><span class="toc-number">4.3.</span> <span class="toc-text"> 4.3单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E5%88%9B%E5%BB%BA%E8%AE%A2%E5%8D%95-%E6%8E%A7%E5%88%B6%E5%B1%82"><span class="toc-number">5.</span> <span class="toc-text"> 5.创建订单-控制层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#51%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8-3"><span class="toc-number">5.1.</span> <span class="toc-text"> 5.1处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52%E8%AE%BE%E8%AE%A1%E8%AF%B7%E6%B1%82-4"><span class="toc-number">5.2.</span> <span class="toc-text"> 5.2设计请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82-4"><span class="toc-number">5.3.</span> <span class="toc-text"> 5.3处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E5%88%9B%E5%BB%BA%E8%AE%A2%E5%8D%95-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">6.</span> <span class="toc-text"> 6.创建订单-前端页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aop"><span class="toc-number"></span> <span class="toc-text"> AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1spring-aop"><span class="toc-number">1.</span> <span class="toc-text"> 1.Spring AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%88%87%E9%9D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text"> 2.切面方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%9F%E8%AE%A1%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%97%B6%E9%95%BF"><span class="toc-number">3.</span> <span class="toc-text"> 3 统计业务方法执行时长</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/16/%E5%A4%8D%E4%B9%A0/" title="2022网络与分布计算复习概览"><img src="/img/Bg4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2022网络与分布计算复习概览"/></a><div class="content"><a class="title" href="/2022/11/16/%E5%A4%8D%E4%B9%A0/" title="2022网络与分布计算复习概览">2022网络与分布计算复习概览</a><time datetime="2022-11-16T13:23:03.141Z" title="Created 2022-11-16 21:23:03">2022-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/05/%E7%8A%B6%E6%80%81%E6%9C%BADP/" title="状态机DP"><img src="/img/Bg4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="状态机DP"/></a><div class="content"><a class="title" href="/2022/11/05/%E7%8A%B6%E6%80%81%E6%9C%BADP/" title="状态机DP">状态机DP</a><time datetime="2022-11-05T12:45:08.029Z" title="Created 2022-11-05 20:45:08">2022-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0%E9%A2%98/" title="软件测试复习题"><img src="/img/Bg4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件测试复习题"/></a><div class="content"><a class="title" href="/2022/11/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0%E9%A2%98/" title="软件测试复习题">软件测试复习题</a><time datetime="2022-11-01T12:05:39.005Z" title="Created 2022-11-01 20:05:39">2022-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/15/%E7%94%B5%E8%84%91%E5%95%86%E5%9F%8E/" title="电脑商城项目教程"><img src="/img/Bg4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="电脑商城项目教程"/></a><div class="content"><a class="title" href="/2022/10/15/%E7%94%B5%E8%84%91%E5%95%86%E5%9F%8E/" title="电脑商城项目教程">电脑商城项目教程</a><time datetime="2022-10-15T12:28:36.431Z" title="Created 2022-10-15 20:28:36">2022-10-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/Bg4.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Clarence</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="Chat"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.orangecatdpman.cn/',
      region: 'ap-shanghai',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.orangecatdpman.cn/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="true" async="async"></script><div class="fb-customerchat" id="fb-customer-chat" attribution="biz_inbox"></div><script>document.getElementById('fb-root') ? '' : document.body.insertAdjacentHTML('afterend', '<div id="fb-root"></div>')

window.fbAsyncInit = function() {
  FB.init({
    xfbml: true,
    version: 'v14.0'
  });
};

(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = 'https://connect.facebook.net/zh_CN/sdk/xfbml.customerchat.js';
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      FB.CustomerChat.show();
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      FB.CustomerChat.hide()
    }
    function chatBtnShow () {
      FB.CustomerChat.show(false)
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>